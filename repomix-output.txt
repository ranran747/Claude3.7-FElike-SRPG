This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-27T01:16:00.177Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
advanced_ai.py
adventurer_guild.py
church.py
combat_integration.py
combat.py
constants.py
dialogue_system.py
game_manager.py
game_state_manager.py
growth_system.py
item_storage_ui.py
legendary_items_ui.py
legendary_items.py
level_sync_manager.py
level_sync.py
level_up_window.py
main.py
map.py
movement_system.py
renderer.py
save_shop.py
save_system.py
scenario_select_screen.py
setup.py
skills.py
support_conversation_ui.py
support_system.py
tavern.py
title_screen.py
town_screen.py
ui_encoding_fix.py
ui_system.py
unit.py
weapon_shop.py
weapon.py

================================================================
Repository Files
================================================================

================
File: advanced_ai.py
================
# advanced_ai.py
from typing import List, Dict, Tuple, Set, Optional
import random
import math
from constants import TerrainType
from movement_system import MovementType

class TacticalAction:
    """AIが実行する戦術的行動を表すクラス"""
    def __init__(self, 
                 action_type: str,            # 'move', 'attack', 'use_item', 'wait', etc.
                 priority: int,               # 行動の優先度（高いほど優先）
                 unit = None,                 # 実行するユニット
                 target_position: Tuple = None,  # 対象位置 (x, y)
                 target_unit = None,          # 対象ユニット（攻撃対象など）
                 item = None,                 # 使用するアイテム
                 expected_damage: int = 0,    # 期待される与ダメージ
                 expected_risk: int = 0):     # 期待されるリスク（被ダメージなど）
        self.action_type = action_type
        self.priority = priority
        self.unit = unit
        self.target_position = target_position
        self.target_unit = target_unit
        self.item = item
        self.expected_damage = expected_damage
        self.expected_risk = expected_risk
    
    def __str__(self):
        """デバッグ用の文字列表現"""
        return (
            f"{self.action_type.upper()} | "
            f"Priority: {self.priority} | "
            f"Unit: {self.unit.name if self.unit else 'None'} | "
            f"Target Pos: {self.target_position} | "
            f"Target Unit: {self.target_unit.name if self.target_unit else 'None'} | "
            f"Expected Damage: {self.expected_damage} | "
            f"Expected Risk: {self.expected_risk}"
        )


class AIRole:
    """AIユニットの役割定義"""
    ATTACKER = "attacker"       # 攻撃重視
    DEFENDER = "defender"       # 防御重視
    HEALER = "healer"           # 回復役
    SUPPORT = "support"         # バフ/デバフ役
    ASSASSIN = "assassin"       # 高機動・高火力
    TANK = "tank"               # 壁役（タンク）


class AdvancedAI:
    """強化されたAIシステム"""
    def __init__(self, game_manager, movement_system=None):
        self.game_manager = game_manager
        self.movement_system = movement_system
        
        # ユニットごとの役割
        self.unit_roles = {}
        
        # 撤退判断に使うHP閾値
        self.retreat_threshold = 0.3  # HPが最大の30%以下で撤退を検討
        
        # 記憶（ターン間でのAI判断を改善するための情報）
        self.memory = {
            'player_targeting': {},  # プレイヤーの標的になりやすいユニット
            'player_damage_dealt': {},  # プレイヤーの与ダメージ量
            'player_tendencies': {
                'aggressive': 0,     # 積極的な攻撃傾向
                'defensive': 0,      # 守備的な傾向
                'focus_weak': 0,     # 弱いユニットを集中攻撃する傾向
                'focus_strong': 0,   # 強いユニットを優先する傾向
            },
            'terrain_preference': {},  # 地形の選好傾向
        }
        
        # 危険地帯（プレイヤーの攻撃範囲）
        self.danger_map = []
        
        # 初期セットアップ
        self._initialize()
    
    def _initialize(self):
        """初期セットアップ"""
        # 役割の自動割り当て
        self._assign_roles()
    
    def _assign_roles(self):
        """AIユニットに役割を割り当てる"""
        ai_units = [unit for unit in self.game_manager.game_map.units if unit.team == 1]
        
        # ユニットごとに役割を判断
        for unit in ai_units:
            if hasattr(unit, "ai_role") and unit.ai_role:
                # 既に役割が設定されている場合はそれを使用
                self.unit_roles[unit.name] = unit.ai_role
                continue
            
            # 自動的に役割を割り当て
            role = self._determine_role(unit)
            self.unit_roles[unit.name] = role
    
    def _determine_role(self, unit) -> str:
        """ユニットに適した役割を判断"""
        # 回復役の判定
        if any(weapon.name.lower() in ['heal', 'heal staff', 'mend', 'recover', '回復', 'ヒール'] 
               for weapon in unit.weapons if weapon):
            return AIRole.HEALER
        
        # 役割の判定基準
        if unit.current_hp >= 40 and unit.defense >= 10:
            return AIRole.TANK
        elif unit.speed >= 10 and unit.skill >= 10:
            return AIRole.ASSASSIN
        elif unit.defense >= 8 and unit.resistance >= 8:
            return AIRole.DEFENDER
        elif hasattr(unit, 'is_support') and unit.is_support:
            return AIRole.SUPPORT
        else:
            return AIRole.ATTACKER
    
    def update_danger_map(self):
        """プレイヤーユニットの攻撃可能範囲を計算してマップ化"""
        game_map = self.game_manager.game_map
        rows, cols = game_map.rows, game_map.cols
        
        # 危険度マップを初期化（0 = 安全, 数値が大きいほど危険）
        self.danger_map = [[0 for _ in range(cols)] for _ in range(rows)]
        
        # プレイヤーユニットの攻撃可能範囲を計算
        player_units = [unit for unit in game_map.units if unit.team == 0 and not unit.is_dead()]
        
        for unit in player_units:
            # ユニットの移動可能範囲を計算
            move_positions = game_map.calculate_movement_range(unit)
            
            # 各移動位置から攻撃可能な範囲を計算
            for pos_x, pos_y in move_positions:
                attack_positions = game_map.calculate_attack_range(unit, (pos_x, pos_y))
                
                # 攻撃範囲の各マスの危険度を上げる
                for attack_x, attack_y in attack_positions:
                    if 0 <= attack_x < cols and 0 <= attack_y < rows:
                        # 危険度に攻撃力を加味する
                        attack_power = unit.get_attack_power()
                        self.danger_map[attack_y][attack_x] += attack_power
    
    def execute_turn(self) -> bool:
        """AIターンを実行する"""
        if self.game_manager.turn_player != 1:  # AIは1番のチーム
            return False
        
        # 危険マップを更新
        self.update_danger_map()
        
        # AIユニットのリスト
        ai_units = [unit for unit in self.game_manager.game_map.units 
                    if unit.team == 1 and not unit.has_moved and not unit.is_dead()]
        
        # 役割に応じて行動順を調整
        ai_units.sort(key=lambda unit: self._get_action_priority(unit))
        
        # 各ユニットの行動を決定して実行
        for unit in ai_units:
            # 行動可能な最適なアクションを決定
            action = self._decide_best_action(unit)
            
            # アクションを実行
            if action:
                self._execute_action(action)
        
        # ターン終了
        self.game_manager.end_player_turn()
        return True
    
    def _get_action_priority(self, unit) -> int:
        """ユニットの行動優先順位を決定"""
        role = self.unit_roles.get(unit.name, AIRole.ATTACKER)
        
        # 役割ごとの優先度
        priorities = {
            AIRole.HEALER: 1,      # 回復役が最初に行動
            AIRole.SUPPORT: 2,     # 次にサポート役
            AIRole.TANK: 3,        # その次に壁役
            AIRole.DEFENDER: 4,
            AIRole.ATTACKER: 5,
            AIRole.ASSASSIN: 6,    # 攻撃役は後半
        }
        
        # 基本優先度
        priority = priorities.get(role, 5)
        
        # HP残量が少ないユニットは優先的に行動
        hp_ratio = unit.current_hp / unit.max_hp
        if hp_ratio < self.retreat_threshold:
            priority -= 3  # 撤退が必要なユニットは最優先
        
        return priority
    
    def _decide_best_action(self, unit) -> Optional[TacticalAction]:
        """ユニットの最適な行動を決定"""
        # 役割に応じた行動生成
        role = self.unit_roles.get(unit.name, AIRole.ATTACKER)
        
        actions = []
        
        # HP残量に応じた行動生成
        hp_ratio = unit.current_hp / unit.max_hp
        if hp_ratio < self.retreat_threshold:
            # 撤退アクション
            retreat_action = self._generate_retreat_action(unit)
            if retreat_action:
                actions.append(retreat_action)
        
        # 役割に応じたアクション生成
        if role == AIRole.HEALER:
            actions.extend(self._generate_healer_actions(unit))
        elif role == AIRole.SUPPORT:
            actions.extend(self._generate_support_actions(unit))
        elif role == AIRole.TANK:
            actions.extend(self._generate_tank_actions(unit))
        elif role == AIRole.ASSASSIN:
            actions.extend(self._generate_assassin_actions(unit))
        elif role == AIRole.DEFENDER:
            actions.extend(self._generate_defender_actions(unit))
        else:  # ATTACKER またはその他
            actions.extend(self._generate_attacker_actions(unit))
        
        # 待機アクションを追加（他に選択肢がない場合のフォールバック）
        actions.append(TacticalAction(
            action_type='wait',
            priority=0,
            unit=unit,
            target_position=(unit.x, unit.y)
        ))
        
        # 優先度でソート
        actions.sort(key=lambda action: action.priority, reverse=True)
        
        # 最も優先度の高い行動を選択
        return actions[0] if actions else None
    
    def _generate_healer_actions(self, unit) -> List[TacticalAction]:
        """回復役の行動を生成"""
        actions = []
        game_map = self.game_manager.game_map
        
        # 回復アイテムや杖を持っているか確認
        heal_weapons = [weapon for weapon in unit.weapons 
                        if weapon and weapon.name.lower() in ['heal', 'heal staff', 'mend', 'recover', '回復', 'ヒール']]
        
        if heal_weapons:
            heal_weapon = heal_weapons[0]
            unit.equipped_weapon = heal_weapon
            
            # 移動可能範囲
            move_positions = game_map.calculate_movement_range(unit)
            
            for pos_x, pos_y in move_positions:
                # この位置から回復可能なマスを計算
                heal_range = heal_weapon.range_max
                potential_heal_targets = []
                
                # 同じチームの負傷したユニットを探す
                for ally in game_map.units:
                    if ally.team == unit.team and not ally.is_dead() and ally != unit:
                        # HPが最大値より少ないユニットのみ
                        if ally.current_hp < ally.max_hp:
                            distance = abs(pos_x - ally.x) + abs(pos_y - ally.y)
                            if distance <= heal_range:
                                # 回復量を計算（実際のゲームロジックに合わせて調整）
                                heal_amount = min(ally.max_hp - ally.current_hp, unit.magic + 5)
                                potential_heal_targets.append((ally, heal_amount))
                
                # 潜在的な回復対象があれば行動を追加
                for target, heal_amount in potential_heal_targets:
                    # 優先度は回復量と対象ユニットの重要度で決定
                    priority = heal_amount * 2
                    
                    # 対象が重要なユニット（タンクなど）なら優先度上げ
                    target_role = self.unit_roles.get(target.name, "")
                    if target_role in [AIRole.TANK, AIRole.HEALER]:
                        priority += 20
                    
                    # HPが低いほど優先
                    target_hp_ratio = target.current_hp / target.max_hp
                    priority += int((1 - target_hp_ratio) * 50)
                    
                    actions.append(TacticalAction(
                        action_type='heal',
                        priority=priority,
                        unit=unit,
                        target_position=(pos_x, pos_y),
                        target_unit=target,
                        item=heal_weapon,
                        expected_damage=-heal_amount  # 負の値は回復量
                    ))
        
        # 回復手段がなければ、他のユニットをサポートする行動を生成
        if not actions:
            actions.extend(self._generate_support_actions(unit))
        
        return actions
    
    def _generate_retreat_action(self, unit) -> Optional[TacticalAction]:
        """撤退アクションを生成"""
        game_map = self.game_manager.game_map
        
        # 移動可能範囲
        move_positions = game_map.calculate_movement_range(unit)
        
        best_retreat_pos = None
        lowest_danger = float('inf')
        
        for pos_x, pos_y in move_positions:
            # 危険度を確認
            danger_level = self.danger_map[pos_y][pos_x]
            
            # 最も安全な位置を選択
            if danger_level < lowest_danger:
                lowest_danger = danger_level
                best_retreat_pos = (pos_x, pos_y)
        
        if best_retreat_pos:
            return TacticalAction(
                action_type='move',
                priority=100,  # 撤退は高優先度
                unit=unit,
                target_position=best_retreat_pos,
                expected_risk=lowest_danger
            )
        
        return None
    
    def _generate_support_actions(self, unit) -> List[TacticalAction]:
        """サポート役の行動を生成"""
        actions = []
        game_map = self.game_manager.game_map
        
        # バフを付与できる武器/アイテムをチェック（実際のゲームロジックに合わせて調整）
        buff_items = [weapon for weapon in unit.weapons 
                      if weapon and hasattr(weapon, 'effect_type') and 'buff' in weapon.effect_type]
        
        if buff_items:
            buff_item = buff_items[0]
            unit.equipped_weapon = buff_item
            
            # 移動可能範囲
            move_positions = game_map.calculate_movement_range(unit)
            
            for pos_x, pos_y in move_positions:
                # この位置からバフを付与可能なマスを計算
                buff_range = buff_item.range_max if hasattr(buff_item, 'range_max') else 1
                
                # 同じチームのユニットを探す
                for ally in game_map.units:
                    if ally.team == unit.team and not ally.is_dead() and ally != unit:
                        distance = abs(pos_x - ally.x) + abs(pos_y - ally.y)
                        if distance <= buff_range:
                            # 優先度はユニットの役割などで決定
                            priority = 30
                            
                            # 重要なユニットならより高い優先度
                            ally_role = self.unit_roles.get(ally.name, "")
                            if ally_role in [AIRole.ATTACKER, AIRole.ASSASSIN]:
                                priority += 20
                            
                            actions.append(TacticalAction(
                                action_type='buff',
                                priority=priority,
                                unit=unit,
                                target_position=(pos_x, pos_y),
                                target_unit=ally,
                                item=buff_item
                            ))
        
        # バフアイテムがなければ、安全な位置に移動する行動を生成
        if not actions:
            # 移動可能範囲
            move_positions = game_map.calculate_movement_range(unit)
            
            for pos_x, pos_y in move_positions:
                # 危険度を確認
                danger_level = self.danger_map[pos_y][pos_x]
                
                # 安全な位置ほど優先度高
                safety = 100 - min(100, danger_level)
                
                actions.append(TacticalAction(
                    action_type='move',
                    priority=safety // 10,
                    unit=unit,
                    target_position=(pos_x, pos_y),
                    expected_risk=danger_level
                ))
        
        return actions
    
    def _generate_tank_actions(self, unit) -> List[TacticalAction]:
        """タンク役（壁役）の行動を生成"""
        actions = []
        game_map = self.game_manager.game_map
        
        # 移動可能範囲
        move_positions = game_map.calculate_movement_range(unit)
        
        # プレイヤーユニットを守るための位置を探す
        player_units = [u for u in game_map.units if u.team == 0 and not u.is_dead()]
        ally_units = [u for u in game_map.units if u.team == 1 and not u.is_dead() and u != unit]
        
        for pos_x, pos_y in move_positions:
            # この位置から攻撃可能なユニットを探す
            attack_positions = []
            if unit.equipped_weapon:
                attack_positions = game_map.calculate_attack_range(unit, (pos_x, pos_y))
            
            # 攻撃可能なプレイヤーユニット
            attackable_enemies = []
            for attack_x, attack_y in attack_positions:
                enemy = game_map.get_unit_at(attack_x, attack_y)
                if enemy and enemy.team == 0:
                    attackable_enemies.append(enemy)
            
            # 防御位置の評価
            defense_score = 0
            
            # 他の味方ユニットを守れる位置
            for ally in ally_units:
                if ally.current_hp / ally.max_hp < 0.5:  # HPが半分以下の仲間を優先
                    distance = abs(pos_x - ally.x) + abs(pos_y - ally.y)
                    if distance <= 2:  # 近くにいる仲間
                        # 仲間と敵の間に立つ位置なら良い
                        for enemy in player_units:
                            enemy_to_ally = abs(enemy.x - ally.x) + abs(enemy.y - ally.y)
                            enemy_to_pos = abs(enemy.x - pos_x) + abs(enemy.y - pos_y)
                            if enemy_to_pos < enemy_to_ally:
                                defense_score += 30
            
            # 地形の防御性能も考慮
            terrain = game_map.tiles[pos_y][pos_x].terrain_type
            if terrain == TerrainType.FOREST:
                defense_score += 15
            elif terrain == TerrainType.MOUNTAIN:
                defense_score += 20
            
            # 攻撃可能な敵がいれば攻撃行動を追加
            for enemy in attackable_enemies:
                expected_damage = self._calculate_expected_damage(unit, enemy)
                counter_damage = self._calculate_expected_damage(enemy, unit, is_counter=True)
                
                # タンクは自身の被ダメージを気にしない
                priority = defense_score + expected_damage - counter_damage / 3
                
                actions.append(TacticalAction(
                    action_type='attack',
                    priority=int(priority),
                    unit=unit,
                    target_position=(pos_x, pos_y),
                    target_unit=enemy,
                    expected_damage=expected_damage,
                    expected_risk=counter_damage
                ))
            
            # 攻撃できなくても守備位置として評価
            if not attackable_enemies and defense_score > 0:
                actions.append(TacticalAction(
                    action_type='move',
                    priority=defense_score // 5,
                    unit=unit,
                    target_position=(pos_x, pos_y),
                    expected_risk=self.danger_map[pos_y][pos_x]
                ))
        
        return actions
    
    def _generate_assassin_actions(self, unit) -> List[TacticalAction]:
        """暗殺者（高機動・高火力）の行動を生成"""
        actions = []
        game_map = self.game_manager.game_map
        
        # 移動可能範囲
        move_positions = game_map.calculate_movement_range(unit)
        
        for pos_x, pos_y in move_positions:
            # この位置から攻撃可能なユニットを探す
            attack_positions = []
            if unit.equipped_weapon:
                attack_positions = game_map.calculate_attack_range(unit, (pos_x, pos_y))
            
            # 攻撃可能なプレイヤーユニット
            attackable_enemies = []
            for attack_x, attack_y in attack_positions:
                enemy = game_map.get_unit_at(attack_x, attack_y)
                if enemy and enemy.team == 0:
                    attackable_enemies.append(enemy)
            
            for enemy in attackable_enemies:
                expected_damage = self._calculate_expected_damage(unit, enemy)
                counter_damage = self._calculate_expected_damage(enemy, unit, is_counter=True)
                
                # 敵を倒せるかどうか
                can_kill = expected_damage >= enemy.current_hp
                
                # 反撃で自分が死なないか
                risk_of_death = counter_damage >= unit.current_hp
                
                # 優先度計算
                priority = expected_damage * 2
                
                # 敵を倒せるなら大幅に優先度上昇
                if can_kill:
                    priority += 100
                
                # 反撃で死ぬリスクが高いなら優先度下げる
                if risk_of_death:
                    priority -= 150
                
                # 敵が回復役なら優先
                if hasattr(enemy, 'unit_class') and enemy.unit_class.lower() in ['healer', 'priest', 'cleric', '僧侶', '神官']:
                    priority += 50
                
                # 敵が魔法使いで自分の耐性が低いなら優先度下げる
                if (hasattr(enemy, 'unit_class') and enemy.unit_class.lower() in ['mage', 'sage', 'wizard', '魔道士']):
                    if unit.resistance < 5:
                        priority -= 40
                
                actions.append(TacticalAction(
                    action_type='attack',
                    priority=priority,
                    unit=unit,
                    target_position=(pos_x, pos_y),
                    target_unit=enemy,
                    expected_damage=expected_damage,
                    expected_risk=counter_damage
                ))
            
            # 攻撃できなくても、次ターンの位置取りとして評価
            if not attackable_enemies:
                # 危険度確認
                danger_level = self.danger_map[pos_y][pos_x]
                
                # プレイヤーユニットへの接近度
                closest_distance = float('inf')
                for enemy in game_map.units:
                    if enemy.team == 0 and not enemy.is_dead():
                        distance = abs(pos_x - enemy.x) + abs(pos_y - enemy.y)
                        if distance < closest_distance:
                            closest_distance = distance
                
                # 危険度が低く、敵に近い位置を優先
                if danger_level < 10 and closest_distance <= 5:
                    priority = 20 - closest_distance * 2
                    actions.append(TacticalAction(
                        action_type='move',
                        priority=int(priority),
                        unit=unit,
                        target_position=(pos_x, pos_y),
                        expected_risk=danger_level
                    ))
        
        return actions
    
    def _generate_defender_actions(self, unit) -> List[TacticalAction]:
        """防御役の行動を生成"""
        actions = []
        game_map = self.game_manager.game_map
        
        # 移動可能範囲
        move_positions = game_map.calculate_movement_range(unit)
        
        for pos_x, pos_y in move_positions:
            # この位置から攻撃可能なユニットを探す
            attack_positions = []
            if unit.equipped_weapon:
                attack_positions = game_map.calculate_attack_range(unit, (pos_x, pos_y))
            
            # 攻撃可能なプレイヤーユニット
            attackable_enemies = []
            for attack_x, attack_y in attack_positions:
                enemy = game_map.get_unit_at(attack_x, attack_y)
                if enemy and enemy.team == 0:
                    attackable_enemies.append(enemy)
            
            # 防御者は自軍の重要ユニットを守る
            defense_score = 0
            for ally in game_map.units:
                if ally.team == 1 and not ally.is_dead() and ally != unit:
                    ally_role = self.unit_roles.get(ally.name, "")
                    
                    # 回復役や重要ユニットを守る
                    if ally_role in [AIRole.HEALER, AIRole.SUPPORT]:
                        distance = abs(pos_x - ally.x) + abs(pos_y - ally.y)
                        if distance <= 2:
                            defense_score += 30
            
            # 攻撃行動の生成
            for enemy in attackable_enemies:
                expected_damage = self._calculate_expected_damage(unit, enemy)
                counter_damage = self._calculate_expected_damage(enemy, unit, is_counter=True)
                
                # 攻撃優先度計算（防御者は反撃ダメージを重視）
                damage_ratio = expected_damage / (counter_damage + 1)  # ゼロ除算回避
                priority = int(expected_damage + defense_score * 2 + damage_ratio * 10)
                
                actions.append(TacticalAction(
                    action_type='attack',
                    priority=priority,
                    unit=unit,
                    target_position=(pos_x, pos_y),
                    target_unit=enemy,
                    expected_damage=expected_damage,
                    expected_risk=counter_damage
                ))
            
            # 防御位置としての評価
            if defense_score > 0:
                # 危険度確認
                danger_level = self.danger_map[pos_y][pos_x]
                
                actions.append(TacticalAction(
                    action_type='move',
                    priority=defense_score - danger_level // 5,
                    unit=unit,
                    target_position=(pos_x, pos_y),
                    expected_risk=danger_level
                ))
        
        return actions
    
    def _generate_attacker_actions(self, unit) -> List[TacticalAction]:
        """攻撃役の行動を生成"""
        actions = []
        game_map = self.game_manager.game_map
        
        # 移動可能範囲
        move_positions = game_map.calculate_movement_range(unit)
        
        for pos_x, pos_y in move_positions:
            # この位置から攻撃可能なユニットを探す
            attack_positions = []
            if unit.equipped_weapon:
                attack_positions = game_map.calculate_attack_range(unit, (pos_x, pos_y))
            
            # 攻撃可能なプレイヤーユニット
            attackable_enemies = []
            for attack_x, attack_y in attack_positions:
                enemy = game_map.get_unit_at(attack_x, attack_y)
                if enemy and enemy.team == 0:
                    attackable_enemies.append(enemy)
            
            for enemy in attackable_enemies:
                expected_damage = self._calculate_expected_damage(unit, enemy)
                counter_damage = self._calculate_expected_damage(enemy, unit, is_counter=True)
                
                # 敵を倒せるかどうか
                can_kill = expected_damage >= enemy.current_hp
                
                # 反撃で自分が死なないか
                risk_of_death = counter_damage >= unit.current_hp
                
                # 攻撃者の優先度計算
                priority = expected_damage * 2 - counter_damage
                
                # 敵を倒せるなら大幅に優先度上昇
                if can_kill:
                    priority += 80
                
                # 反撃で死ぬリスクが高いなら優先度下げる
                if risk_of_death:
                    priority -= 100
                
                actions.append(TacticalAction(
                    action_type='attack',
                    priority=int(priority),
                    unit=unit,
                    target_position=(pos_x, pos_y),
                    target_unit=enemy,
                    expected_damage=expected_damage,
                    expected_risk=counter_damage
                ))
            
            # 攻撃できなくても、敵への接近を評価
            if not attackable_enemies:
                # 敵への接近評価
                closest_distance = float('inf')
                for enemy in game_map.units:
                    if enemy.team == 0 and not enemy.is_dead():
                        distance = abs(pos_x - enemy.x) + abs(pos_y - enemy.y)
                        if distance < closest_distance:
                            closest_distance = distance
                
                # 危険度確認
                danger_level = self.danger_map[pos_y][pos_x]
                
                # 敵に接近するが危険すぎない位置を選択
                if closest_distance < 6 and danger_level < 20:
                    priority = 15 - closest_distance
                    actions.append(TacticalAction(
                        action_type='move',
                        priority=int(priority),
                        unit=unit,
                        target_position=(pos_x, pos_y),
                        expected_risk=danger_level
                    ))
        
        return actions
    
    def _calculate_expected_damage(self, attacker, defender, is_counter=False) -> int:
        """予想される与ダメージを計算"""
        if not attacker.equipped_weapon:
            return 0
        
        # 実際のダメージ計算はゲームシステムを使用
        if hasattr(self.game_manager, 'combat_system'):
            damage = self.game_manager.combat_system.calculate_damage(
                attacker, defender, self.game_manager.game_map
            )
            hit_chance = self.game_manager.combat_system.calculate_hit_chance(
                attacker, defender, self.game_manager.game_map
            )
            crit_chance = self.game_manager.combat_system.calculate_crit_chance(
                attacker, defender
            )
        else:
            # 簡易的なダメージ計算（実際のゲームロジックに合わせて調整）
            attack_power = attacker.get_attack_power()
            is_magic = attacker.equipped_weapon and hasattr(attacker.equipped_weapon, 'weapon_type') and \
                       attacker.equipped_weapon.weapon_type.name == 'MAGIC'
            
            defense_stat = defender.resistance if is_magic else defender.defense
            damage = max(0, attack_power - defense_stat)
            
            # 命中率・必殺率（簡易計算）
            hit_chance = min(100, max(0, attacker.get_hit_rate() - defender.get_avoid()))
            crit_chance = max(0, attacker.get_critical_rate() - defender.luck)
        
        # 期待値として、命中率とクリティカル率を考慮
        normal_damage = damage * (hit_chance / 100) * (1 - crit_chance / 100)
        crit_damage = damage * 3 * (hit_chance / 100) * (crit_chance / 100)
        
        expected_damage = int(normal_damage + crit_damage)
        
        # 反撃の場合、命中率などに補正をかける
        if is_counter:
            # 反撃不可能な場合
            if not defender.equipped_weapon:
                return 0
                
            # 射程外なら反撃不可
            range_check = False
            if hasattr(defender.equipped_weapon, 'range_min') and hasattr(defender.equipped_weapon, 'range_max'):
                distance = abs(attacker.x - defender.x) + abs(attacker.y - defender.y)
                range_check = defender.equipped_weapon.range_min <= distance <= defender.equipped_weapon.range_max
            
            if not range_check:
                return 0
        
        return expected_damage
    
    def _execute_action(self, action: TacticalAction) -> bool:
        """AIの行動を実行"""
        if action.action_type == 'attack':
            return self._execute_attack_action(action)
        elif action.action_type == 'move':
            return self._execute_move_action(action)
        elif action.action_type == 'heal':
            return self._execute_heal_action(action)
        elif action.action_type == 'buff':
            return self._execute_buff_action(action)
        elif action.action_type == 'wait':
            return self._execute_wait_action(action)
        else:
            return False
    
    def _execute_attack_action(self, action: TacticalAction) -> bool:
        """攻撃行動を実行"""
        unit = action.unit
        target_pos = action.target_position
        target_unit = action.target_unit
        
        if not unit or not target_pos or not target_unit:
            return False
        
        # ユニットを移動
        self.game_manager.game_map.move_unit(unit, target_pos[0], target_pos[1])
        unit.has_moved = True
        
        # 攻撃実行
        combat_results = self.game_manager.combat_system.perform_combat(
            unit, target_unit, self.game_manager.game_map, self.game_manager.support_system
        )
        unit.has_attacked = True
        
        return True
    
    def _execute_move_action(self, action: TacticalAction) -> bool:
        """移動行動を実行"""
        unit = action.unit
        target_pos = action.target_position
        
        if not unit or not target_pos:
            return False
        
        # ユニットを移動
        self.game_manager.game_map.move_unit(unit, target_pos[0], target_pos[1])
        unit.has_moved = True
        unit.has_attacked = True  # 他の行動を取らない
        
        return True
    
    def _execute_heal_action(self, action: TacticalAction) -> bool:
        """回復行動を実行"""
        unit = action.unit
        target_pos = action.target_position
        target_unit = action.target_unit
        
        if not unit or not target_pos or not target_unit:
            return False
        
        # ユニットを移動
        self.game_manager.game_map.move_unit(unit, target_pos[0], target_pos[1])
        unit.has_moved = True
        
        # 実際のゲームで回復を実行するロジックをここに
        # 仮の実装：回復量を予測値から取得
        heal_amount = -action.expected_damage  # 負の値は回復量として使用
        target_unit.current_hp = min(target_unit.max_hp, target_unit.current_hp + heal_amount)
        
        unit.has_attacked = True
        
        return True
    
    def _execute_buff_action(self, action: TacticalAction) -> bool:
        """バフ付与行動を実行"""
        unit = action.unit
        target_pos = action.target_position
        
        if not unit or not target_pos:
            return False
        
        # ユニットを移動
        self.game_manager.game_map.move_unit(unit, target_pos[0], target_pos[1])
        unit.has_moved = True
        
        # 実際のゲームでバフを付与するロジックをここに
        # （実際のゲームシステムに合わせて実装）
        
        unit.has_attacked = True
        
        return True
    
    def _execute_wait_action(self, action: TacticalAction) -> bool:
        """待機行動を実行"""
        unit = action.unit
        
        if not unit:
            return False
        
        # 現在の位置で待機
        unit.has_moved = True
        unit.has_attacked = True
        
        return True

================
File: adventurer_guild.py
================
# adventurer_guild.py
import pygame
import random
from ui_system import Panel, Label, Button, ScrollPanel
from unit import Unit
from constants import WeaponType

class AdventurerGuild(Panel):
    def __init__(self, x, y, width, height, game_manager, on_close=None):
        super().__init__(x, y, width, height)
        self.game_manager = game_manager
        self.on_close = on_close
        
        # ギルドタイトル
        title_label = Label(width // 2, 20, "冒険者ギルド", None, 30, (255, 255, 200), None, "center")
        self.add_child(title_label)
        
        # タブボタン
        tab_y = 60
        tab_width = width // 3 - 20
        
        recruit_tab = Button(20, tab_y, tab_width, 30, "仲間を探す", None, 20, 
                            (80, 60, 100), (255, 255, 255), (120, 80, 150),
                            (0, 0, 0), 1, lambda: self.change_tab("recruit"))
        self.add_child(recruit_tab)
        
        class_change_tab = Button(30 + tab_width, tab_y, tab_width, 30, "転職", None, 20,
                                 (60, 80, 100), (255, 255, 255), (80, 120, 150),
                                 (0, 0, 0), 1, lambda: self.change_tab("class_change"))
        self.add_child(class_change_tab)
        
        dismiss_tab = Button(40 + tab_width * 2, tab_y, tab_width, 30, "解雇", None, 20,
                            (100, 60, 60), (255, 255, 255), (150, 80, 80),
                            (0, 0, 0), 1, lambda: self.change_tab("dismiss"))
        self.add_child(dismiss_tab)
        
        # コンテンツパネル
        content_panel = Panel(20, tab_y + 40, width - 40, height - tab_y - 100, (40, 40, 50), (0, 0, 0), 1, 220)
        self.add_child(content_panel)
        self.content_panel = content_panel
        
        # 閉じるボタン
        close_btn = Button(width - 80, 20, 60, 30, "閉じる", None, 20,
                          (100, 60, 60), (255, 255, 255), (150, 80, 80),
                          (0, 0, 0), 1, self.close_guild)
        self.add_child(close_btn)
        
        # 現在のタブ
        self.current_tab = "recruit"
        
        # タブの内容を更新
        self.update_tab_content()
    
    def change_tab(self, tab_name):
        """タブを切り替える"""
        self.current_tab = tab_name
        self.update_tab_content()
    
    def update_tab_content(self):
        """現在のタブに応じた内容を表示"""
        self.content_panel.clear_children()
        
        if self.current_tab == "recruit":
            self.show_recruit_tab()
        elif self.current_tab == "class_change":
            self.show_class_change_tab()
        elif self.current_tab == "dismiss":
            self.show_dismiss_tab()
    
    def show_recruit_tab(self):
        """仲間を探すタブの表示"""
        # 募集中のユニット（例えば3人）を表示
        available_units = self.get_available_recruits(3)
        
        for i, unit in enumerate(available_units):
            unit_panel = Panel(10, i * 120 + 10, self.content_panel.width - 20, 110, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # ユニット名と職業
            unit_panel.add_child(Label(10, 10, f"{unit['name']} ({unit['class']})", None, 20, (255, 255, 255)))
            
            # レベルと主要ステータス
            stats_text = f"Lv.{unit['level']}  HP:{unit['hp']}  力:{unit['strength']}  速:{unit['speed']}  技:{unit['skill']}"
            unit_panel.add_child(Label(10, 35, stats_text, None, 16, (200, 200, 200)))
            
            # スキル
            skills_text = "スキル: " + (", ".join([s['name'] for s in unit['skills']]) if unit['skills'] else "なし")
            unit_panel.add_child(Label(10, 55, skills_text, None, 16, (200, 200, 200)))
            
            # 雇用費用
            cost_text = f"雇用費: {unit['cost']}G"
            unit_panel.add_child(Label(10, 80, cost_text, None, 18, (255, 255, 0)))
            
            # 雇用ボタン
            recruit_btn = Button(unit_panel.width - 90, 75, 80, 30, "雇用", None, 18,
                                (60, 100, 60), (255, 255, 255), (80, 150, 80),
                                (0, 0, 0), 1, lambda u=unit: self.recruit_unit(u))
            unit_panel.add_child(recruit_btn)
            
            self.content_panel.add_child(unit_panel)
    
    def show_class_change_tab(self):
        """転職タブの表示"""
        # プレイヤーユニットのリスト
        units = [unit for unit in self.game_manager.game_map.units if unit.team == 0]
        
        # スクロール可能なユニットリスト
        unit_list = ScrollPanel(0, 0, self.content_panel.width // 2 - 10, self.content_panel.height, 
                               self.content_panel.height, (40, 40, 50), None, 0, 220)
        self.content_panel.add_child(unit_list)
        
        # 各ユニットを表示
        for i, unit in enumerate(units):
            unit_panel = Panel(10, i * 70 + 10, unit_list.width - 20, 60, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # ユニット名と職業
            unit_panel.add_child(Label(10, 10, f"{unit.name} (Lv.{unit.level})", None, 18, (255, 255, 255)))
            unit_panel.add_child(Label(10, 35, f"職業: {unit.unit_class}", None, 16, (200, 200, 200)))
            
            # クリックハンドラを設定
            unit_index = i
            
            def make_handler(idx):
                return lambda: self.select_unit_for_class_change(units[idx])
            
            unit_panel.handle_event = make_handler(unit_index)
            
            unit_list.add_child(unit_panel)
        
        # コンテンツ高さを更新
        unit_list.update_content_height()
        
        # 職業リストと詳細（右側）- 初期状態では非表示
        class_panel = Panel(self.content_panel.width // 2 + 10, 0, self.content_panel.width // 2 - 10, self.content_panel.height,
                           (40, 40, 50), None, 0, 220)
        self.content_panel.add_child(class_panel)
        class_panel.add_child(Label(class_panel.width // 2, 20, "ユニットを選択してください", None, 18, (200, 200, 200), None, "center"))
        
        # 職業リストパネルを保存
        self.class_panel = class_panel
    
    def show_dismiss_tab(self):
        """解雇タブの表示"""
        # プレイヤーユニットのリスト
        units = [unit for unit in self.game_manager.game_map.units if unit.team == 0]
        
        # 各ユニットを表示
        for i, unit in enumerate(units):
            unit_panel = Panel(10, i * 70 + 10, self.content_panel.width - 20, 60, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # ユニット名と職業
            unit_panel.add_child(Label(10, 10, f"{unit.name} (Lv.{unit.level} {unit.unit_class})", None, 18, (255, 255, 255)))
            
            # ステータス
            stats_text = f"HP:{unit.max_hp}  力:{unit.strength}  速:{unit.speed}  技:{unit.skill}"
            unit_panel.add_child(Label(10, 35, stats_text, None, 16, (200, 200, 200)))
            
            # 解雇ボタン（主人公など重要キャラは解雇不可）
            if not unit.is_important:
                dismiss_btn = Button(unit_panel.width - 90, 15, 80, 30, "解雇", None, 18,
                                    (150, 60, 60), (255, 255, 255), (200, 80, 80),
                                    (0, 0, 0), 1, lambda u=unit: self.confirm_dismiss(u))
                unit_panel.add_child(dismiss_btn)
            
            self.content_panel.add_child(unit_panel)
    
    def get_available_recruits(self, count):
        """募集可能なユニットのリストを取得"""
        # 実際のゲームではデータベースから取得するなど
        recruits = []
        
        classes = ["戦士", "ナイト", "アーチャー", "シーフ", "魔道士", "僧侶"]
        names = ["アルフレッド", "ベアトリス", "カルロス", "デイジー", "エドワード", "フローラ"]
        
        for i in range(count):
            unit_class = random.choice(classes)
            level = random.randint(1, 5)
            
            # クラスに応じた基本ステータス
            base_stats = {
                "戦士": {"hp": 20, "strength": 7, "magic": 0, "skill": 5, "speed": 5},
                "ナイト": {"hp": 22, "strength": 8, "magic": 0, "skill": 3, "speed": 3},
                "アーチャー": {"hp": 18, "strength": 5, "magic": 0, "skill": 7, "speed": 6},
                "シーフ": {"hp": 16, "strength": 4, "magic": 0, "skill": 8, "speed": 9},
                "魔道士": {"hp": 15, "strength": 2, "magic": 7, "skill": 5, "speed": 5},
                "僧侶": {"hp": 17, "strength": 3, "magic": 6, "skill": 4, "speed": 4}
            }
            
            # レベルに応じた成長（簡易的）
            stats = base_stats[unit_class].copy()
            for stat in stats:
                stats[stat] += (level - 1) * random.randint(0, 2)
            
            # スキルの追加（ランダム）
            skills = []
            if random.random() < 0.7:  # 70%の確率でスキルを持つ
                skills.append({"name": "会心", "description": "クリティカル率+10%"})
            
            recruit = {
                "name": random.choice(names),
                "class": unit_class,
                "level": level,
                "hp": stats["hp"],
                "strength": stats["strength"],
                "magic": stats["magic"],
                "skill": stats["skill"],
                "speed": stats["speed"],
                "skills": skills,
                "cost": level * 1000 + random.randint(100, 500)  # レベルに応じたコスト
            }
            
            recruits.append(recruit)
        
        return recruits
    
    def recruit_unit(self, unit_data):
        """ユニットを雇用"""
        # お金のチェック
        if self.game_manager.player_gold < unit_data["cost"]:
            # お金が足りないメッセージ
            return
        
        # 雇用処理
        self.game_manager.player_gold -= unit_data["cost"]
        
        # ユニットの生成
        new_unit = Unit(
            unit_data["name"],
            unit_data["class"],
            unit_data["level"],
            unit_data["hp"],
            unit_data["strength"],
            unit_data["magic"],
            unit_data["skill"],
            unit_data["speed"],
            random.randint(3, 7),  # 幸運
            random.randint(3, 7),  # 守備
            random.randint(2, 5),  # 魔防
            4,  # 移動力
            0,  # プレイヤーチーム
            []  # 武器（後で装備）
        )
        
        # スキルの追加
        for skill_data in unit_data["skills"]:
            # スキルの生成と追加（実際のコードでは適切なスキルオブジェクトを生成）
            pass
        
        # 新しいユニットのチームに追加
        self.game_manager.add_unit_to_party(new_unit)
        
        # タブの内容を更新
        self.update_tab_content()
        
        # 雇用完了メッセージ（未実装）
    
    def select_unit_for_class_change(self, unit):
        """転職のためのユニット選択"""
        self.class_panel.clear_children()
        
        # ユニット情報
        self.class_panel.add_child(Label(10, 10, f"ユニット: {unit.name}", None, 18, (255, 255, 255)))
        self.class_panel.add_child(Label(10, 35, f"現在の職業: {unit.unit_class}", None, 16, (200, 200, 200)))
        
        # 転職可能な職業リスト
        self.class_panel.add_child(Label(10, 60, "転職先:", None, 18, (255, 255, 200)))
        
        # 転職可能な職業を取得（実際のゲームではユニットの条件に基づいて）
        available_classes = self.get_available_classes(unit)
        
        for i, class_info in enumerate(available_classes):
            class_panel = Panel(10, 90 + i * 80, self.class_panel.width - 20, 70, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # 職業名
            class_panel.add_child(Label(10, 10, class_info["name"], None, 18, (255, 255, 255)))
            
            # 特徴
            class_panel.add_child(Label(10, 35, f"特徴: {class_info['feature']}", None, 16, (200, 200, 200)))
            
            # 必要条件
            req_text = "条件: "
            if class_info["requirements"]:
                req_text += ", ".join([f"{req}" for req in class_info["requirements"]])
            else:
                req_text += "なし"
            class_panel.add_child(Label(10, 55, req_text, None, 14, (180, 180, 220)))
            
            # 転職ボタン
            change_btn = Button(class_panel.width - 90, 20, 80, 30, "転職", None, 18,
                               (60, 100, 60), (255, 255, 255), (80, 150, 80),
                               (0, 0, 0), 1, lambda c=class_info: self.change_class(unit, c))
            
            # 条件を満たしているかチェック
            can_change = True
            for req in class_info["requirements"]:
                if "レベル" in req:
                    req_level = int(req.split(" ")[1])
                    if unit.level < req_level:
                        can_change = False
            
            # 条件を満たしていない場合はボタンを無効化
            if not can_change:
                change_btn.set_active(False)
                change_btn.color = (100, 100, 100)
            
            class_panel.add_child(change_btn)
            
            self.class_panel.add_child(class_panel)
    
    def get_available_classes(self, unit):
        """ユニットの転職可能な職業を取得"""
        # 実際のゲームでは職業ツリーなどに基づいて
        current_class = unit.unit_class
        
        # 職業ツリー（簡易的な例）
        class_tree = {
            "戦士": [
                {"name": "勇者", "feature": "バランスの取れた強力なユニット", "requirements": ["レベル 10"]},
                {"name": "バーサーカー", "feature": "圧倒的な攻撃力", "requirements": ["レベル 10", "力 12以上"]}
            ],
            "ナイト": [
                {"name": "ジェネラル", "feature": "鉄壁の守備力", "requirements": ["レベル 10"]},
                {"name": "パラディン", "feature": "高い機動力", "requirements": ["レベル 10", "技 8以上"]}
            ],
            "アーチャー": [
                {"name": "スナイパー", "feature": "高い命中率と射程", "requirements": ["レベル 10"]},
                {"name": "ボウナイト", "feature": "弓と機動力を兼ね備える", "requirements": ["レベル 10", "速さ 12以上"]}
            ],
            "シーフ": [
                {"name": "アサシン", "feature": "高い必殺率", "requirements": ["レベル 10"]},
                {"name": "ローグ", "feature": "扉や宝箱を開けられる", "requirements": ["レベル 10", "技 10以上"]}
            ],
            "魔道士": [
                {"name": "セージ", "feature": "高い魔力とスキル", "requirements": ["レベル 10"]},
                {"name": "ダークマージ", "feature": "暗黒魔法が使える", "requirements": ["レベル 10", "魔力 12以上"]}
            ],
            "僧侶": [
                {"name": "ビショップ", "feature": "高い回復力と魔防", "requirements": ["レベル 10"]},
                {"name": "ヴァルキリー", "feature": "回復と攻撃魔法の両立", "requirements": ["レベル 10", "速さ 10以上"]}
            ]
        }
        
        if current_class in class_tree:
            return class_tree[current_class]
        return []
    
    def change_class(self, unit, class_info):
        """職業を変更"""
        # 職業変更の処理
        old_class = unit.unit_class
        unit.unit_class = class_info["name"]
        
        # 職業変更に伴うステータス変更（実際のゲームではより複雑な処理）
        if "勇者" in class_info["name"] or "バーサーカー" in class_info["name"]:
            unit.strength += 2
        elif "ジェネラル" in class_info["name"]:
            unit.defense += 3
        elif "スナイパー" in class_info["name"]:
            unit.skill += 3
        # 他の職業に応じた処理...
        
        # クラスパネルを更新
        self.select_unit_for_class_change(unit)
        
        # 職業変更完了メッセージ（未実装）
    
    def confirm_dismiss(self, unit):
        """解雇の確認"""
        # 確認ダイアログの表示（実際のゲームではダイアログUIを使用）
        response = True  # 仮の確認結果
        
        if response:
            # 解雇処理
            self.game_manager.remove_unit_from_party(unit)
            
            # タブの内容を更新
            self.update_tab_content()
    
    def close_guild(self):
        """ギルドを閉じる"""
        if self.on_close:
            self.on_close()

================
File: church.py
================
# church.py
import pygame
import random
from ui_system import Panel, Label, Button, ScrollPanel

class Church(Panel):
    def __init__(self, x, y, width, height, game_manager, on_close=None):
        super().__init__(x, y, width, height)
        self.game_manager = game_manager
        self.on_close = on_close
        
        # 教会タイトル
        title_label = Label(width // 2, 20, "教会", None, 30, (255, 255, 200), None, "center")
        self.add_child(title_label)
        
        # 所持金表示
        gold_label = Label(width - 20, 20, f"所持金: {game_manager.player_gold}G", None, 24, (255, 255, 0), None, "right")
        self.add_child(gold_label)
        self.gold_label = gold_label
        
        # 閉じるボタン
        close_btn = Button(width - 80, 20, 60, 30, "閉じる", None, 20,
                          (100, 60, 60), (255, 255, 255), (150, 80, 80),
                          (0, 0, 0), 1, self.close_church)
        self.add_child(close_btn)
        
        # 聖職者の言葉
        message_label = Label(width // 2, 60, "ここは神の御加護があるところじゃ。何をしてほしい？", None, 24, (200, 200, 255), None, "center")
        self.add_child(message_label)
        
        # 戦死したユニットリスト
        dead_units_panel = ScrollPanel(20, 100, width - 40, height - 180, height, (40, 40, 50), (0, 0, 0), 1, 220)
        self.add_child(dead_units_panel)
        self.dead_units_panel = dead_units_panel
        
        # 戦死ユニットの表示
        self.update_dead_units_list()
    
    def update_dead_units_list(self):
        """戦死したユニットリストを更新"""
        self.dead_units_panel.clear_children()
        
        # 戦死ユニットの取得（実際のゲームではゲームマネージャーから取得）
        dead_units = self.game_manager.get_dead_units()
        
        if not dead_units:
            # 戦死者がいない場合のメッセージ
            self.dead_units_panel.add_child(Label(
                self.dead_units_panel.width // 2, 30,
                "戦死したユニットはいません。",
                None, 24, (200, 200, 200), None, "center"
            ))
            return
        
        for i, unit in enumerate(dead_units):
            unit_panel = Panel(10, i * 100 + 10, self.dead_units_panel.width - 30, 90, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # ユニット名と情報
            unit_panel.add_child(Label(10, 10, f"{unit.name} (Lv.{unit.level} {unit.unit_class})", None, 20, (255, 255, 255)))
            
            # 戦死した状態（通常、灰、ロスト）
            status_text = "状態: "
            if unit.death_status == "ash":
                status_text += "灰（復活確率低下）"
                status_color = (180, 180, 180)
            elif unit.death_status == "lost":
                status_text += "ロスト（復活不能）"
                status_color = (255, 100, 100)
            else:
                status_text += "戦死"
                status_color = (255, 200, 200)
            
            unit_panel.add_child(Label(10, 35, status_text, None, 18, status_color))
            
            # 復活にかかる費用
            if unit.death_status != "lost":
                cost = self.calculate_revival_cost(unit)
                cost_text = f"復活費用: {cost}G"
                unit_panel.add_child(Label(10, 60, cost_text, None, 18, (255, 255, 0)))
                
                # 復活ボタン
                revive_btn = Button(unit_panel.width - 90, 30, 80, 30, "復活", None, 18,
                                   (60, 100, 60), (255, 255, 255), (80, 150, 80),
                                   (0, 0, 0), 1, lambda u=unit: self.revive_unit(u))
                unit_panel.add_child(revive_btn)
            else:
                # ロスト状態の場合は復活不可のメッセージ
                unit_panel.add_child(Label(10, 60, "復活不能", None, 18, (255, 100, 100)))
            
            self.dead_units_panel.add_child(unit_panel)
        
        # コンテンツ高さの更新
        self.dead_units_panel.update_content_height()
    
    def calculate_revival_cost(self, unit):
        """復活にかかる費用を計算"""
        # レベルに基づく基本コスト
        base_cost = unit.level * 1000
        
        # 灰状態の場合はコスト増加
        if unit.death_status == "ash":
            base_cost *= 2
        
        return base_cost
    
    def revive_unit(self, unit):
        """ユニットを復活させる"""
        # 復活費用の計算
        cost = self.calculate_revival_cost(unit)
        
        # お金のチェック
        if self.game_manager.player_gold < cost:
            # お金が足りないメッセージ（未実装）
            return
        
        # 復活の成功判定
        success = True
        
        # 灰状態の場合は成功率低下
        if unit.death_status == "ash":
            success = random.random() < 0.7  # 70%の確率で成功
        
        if success:
            # 復活処理
            self.game_manager.player_gold -= cost
            self.game_manager.revive_unit(unit)
            
            # 所持金表示の更新
            self.gold_label.set_text(f"所持金: {self.game_manager.player_gold}G")
            
            # 死亡ユニットリストの更新
            self.update_dead_units_list()
            
            # 復活成功メッセージ（未実装）
        else:
            # 失敗した場合：お金は消費するが、ユニットの状態が悪化
            self.game_manager.player_gold -= cost
            
            # 状態の悪化（通常→灰、灰→ロスト）
            if unit.death_status == "ash":
                unit.death_status = "lost"
            else:
                unit.death_status = "ash"
            
            # 所持金表示の更新
            self.gold_label.set_text(f"所持金: {self.game_manager.player_gold}G")
            
            # 死亡ユニットリストの更新
            self.update_dead_units_list()
            
            # 復活失敗メッセージ（未実装）
    
    def close_church(self):
        """教会を閉じる"""
        if self.on_close:
            self.on_close()

================
File: combat_integration.py
================
# combat_integration.py
# 既存の戦闘システムに支援効果とレジェンダリーアイテム効果を統合するモジュール

from typing import Dict, List, Tuple, Optional
from combat import CombatSystem
from support_system import SupportSystem
from legendary_items import LegendaryWeapon

class EnhancedCombatSystem(CombatSystem):
    """支援効果とレジェンダリーアイテム効果を統合した拡張戦闘システム"""
    
    @staticmethod
    def calculate_hit_chance(attacker, defender, game_map, support_system=None) -> int:
        """支援効果を考慮した命中率計算"""
        # 基本命中率を計算
        hit_chance = CombatSystem.calculate_hit_chance(attacker, defender, game_map)
        
        # 支援効果を適用
        if support_system:
            attacker_support_bonus = support_system.get_support_bonus(attacker, game_map)
            defender_support_bonus = support_system.get_support_bonus(defender, game_map)
            
            # 命中率ボーナスと回避率ボーナスを適用
            hit_chance = hit_chance + attacker_support_bonus.hit_bonus - defender_support_bonus.avoid_bonus
        
        # レジェンダリー武器の効果を考慮
        if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
            # 武器の効果を適用
            for effect in attacker.equipped_weapon.effects:
                if effect.effect_type == "hit_boost":
                    hit_chance += effect.effect_value.get("value", 0)
        
        return max(0, min(100, hit_chance))
    
    @staticmethod
    def calculate_damage(attacker, defender, game_map, support_system=None) -> int:
        """支援効果を考慮したダメージ計算"""
        # 基本ダメージを計算
        damage = CombatSystem.calculate_damage(attacker, defender, game_map)
        
        # 支援効果を適用
        if support_system:
            attacker_support_bonus = support_system.get_support_bonus(attacker, game_map)
            defender_support_bonus = support_system.get_support_bonus(defender, game_map)
            
            # ダメージボーナスとダメージ軽減を適用
            damage = damage + attacker_support_bonus.damage_bonus - defender_support_bonus.defense_bonus
        
        # レジェンダリー武器の効果を考慮
        if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
            # 武器の効果を適用
            for effect in attacker.equipped_weapon.effects:
                if effect.effect_type == "damage_boost":
                    damage += effect.effect_value.get("value", 0)
        
        if defender.equipped_weapon and isinstance(defender.equipped_weapon, LegendaryWeapon):
            # 防御側の武器効果を適用
            for effect in defender.equipped_weapon.effects:
                if effect.effect_type == "damage_reduce":
                    damage -= effect.effect_value.get("value", 0)
        
        return max(0, damage)
    
    @staticmethod
    def calculate_crit_chance(attacker, defender, support_system=None) -> int:
        """支援効果を考慮したクリティカル率計算"""
        # 基本クリティカル率を計算
        crit_chance = CombatSystem.calculate_crit_chance(attacker, defender)
        
        # レジェンダリー武器の効果を考慮
        if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
            # 武器の効果を適用
            for effect in attacker.equipped_weapon.effects:
                if effect.effect_type == "critical_boost":
                    crit_chance += effect.effect_value.get("value", 0)
        
        return max(0, min(100, crit_chance))
    
    @staticmethod
    def perform_attack(attacker, defender, game_map, support_system=None) -> Dict:
        """支援効果とレジェンダリーアイテム効果を考慮した攻撃処理"""
        # 戦闘データを準備
        combat_data = {
            "attacker": attacker,
            "defender": defender,
            "is_attacker": True,
            "target": defender,
            "game_map": game_map
        }
        
        # 支援効果を適用
        if support_system:
            support_system.apply_support_effects(attacker, defender, combat_data, game_map)
        
        # レジェンダリー武器のスキルを適用
        if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
            # 武器が付与するスキルを取得
            weapon_skills = attacker.equipped_weapon.get_granted_skills()
            
            # 一時的にスキルを追加
            for skill in weapon_skills:
                if skill not in attacker.skills:
                    attacker.add_skill(skill)
        
        # 通常の攻撃処理
        attacker.activate_skills(SkillTriggerType.ON_ATTACK, combat_data)
        defender.activate_skills(SkillTriggerType.ON_DEFEND, combat_data)
        
        # 支援効果とレジェンダリー効果を考慮した戦闘値計算
        hit_chance = EnhancedCombatSystem.calculate_hit_chance(attacker, defender, game_map, support_system)
        damage = EnhancedCombatSystem.calculate_damage(attacker, defender, game_map, support_system)
        crit_chance = EnhancedCombatSystem.calculate_crit_chance(attacker, defender, support_system)
        
        # 命中判定
        hit_roll = random.randint(1, 100)
        hit = hit_roll <= hit_chance
        
        # クリティカル判定
        crit_roll = random.randint(1, 100)
        crit = hit and crit_roll <= crit_chance
        
        # 連続攻撃スキル・効果の処理
        multi_attack = False
        attack_count = 1
        damage_multiplier = 1.0
        
        # スキルによる連続攻撃
        for skill in attacker.active_skills:
            if skill.effect_type == SkillEffectType.SPECIAL_ATTACK:
                if isinstance(skill.effect_value, dict) and "attacks" in skill.effect_value:
                    multi_attack = True
                    attack_count = skill.effect_value.get("attacks", 1)
                    damage_multiplier = skill.effect_value.get("damage_multiplier", 1.0)
        
        # レジェンダリー武器による連続攻撃
        if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
            for effect in attacker.equipped_weapon.effects:
                if effect.effect_type == "special_attack" and isinstance(effect.effect_value, dict) and "attacks" in effect.effect_value:
                    if not multi_attack or effect.effect_value.get("attacks", 1) > attack_count:
                        multi_attack = True
                        attack_count = effect.effect_value.get("attacks", 1)
                        damage_multiplier = effect.effect_value.get("damage_multiplier", 1.0)
        
        # ダメージ計算と適用
        total_damage = 0
        if hit:
            if multi_attack:
                # 連続攻撃の処理
                for i in range(attack_count):
                    attack_damage = int(damage * damage_multiplier)
                    if i == 0 and crit:
                        attack_damage *= 3
                    defender.current_hp = max(0, defender.current_hp - attack_damage)
                    total_damage += attack_damage
                    if defender.is_dead():
                        break
            else:
                # 通常攻撃
                attack_damage = damage * 3 if crit else damage
                defender.current_hp = max(0, defender.current_hp - attack_damage)
                total_damage = attack_damage
            
            # 攻撃後の回復スキル処理
            for skill in attacker.active_skills:
                if skill.effect_type == SkillEffectType.HEAL:
                    if isinstance(skill.effect_value, dict) and "heal_ratio" in skill.effect_value:
                        heal_amount = int(total_damage * skill.effect_value["heal_ratio"])
                        attacker.current_hp = min(attacker.max_hp, attacker.current_hp + heal_amount)
            
            # レジェンダリー武器による回復効果
            if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
                for effect in attacker.equipped_weapon.effects:
                    if effect.effect_type == "heal" and isinstance(effect.effect_value, dict) and "heal_ratio" in effect.effect_value:
                        heal_amount = int(total_damage * effect.effect_value["heal_ratio"])
                        attacker.current_hp = min(attacker.max_hp, attacker.current_hp + heal_amount)
            
            # 武器の耐久度を減らす
            if attacker.equipped_weapon:
                attacker.equipped_weapon.durability -= 1
        
        # 戦闘結果の作成
        result = {
            "hit": hit,
            "damage": total_damage if hit else 0,
            "critical": crit,
            "killed": defender.is_dead(),
            "hit_chance": hit_chance,
            "crit_chance": crit_chance,
            "multi_attack": multi_attack,
            "attack_count": attack_count if multi_attack and hit else 1,
        }
        
        # 戦闘結果に基づいたスキルの発動
        if hit and total_damage > 0:
            combat_data["damage_dealt"] = total_damage
            attacker.activate_skills(SkillTriggerType.ON_DAMAGE, combat_data)
        
        if defender.is_dead():
            combat_data["target_killed"] = True
            attacker.activate_skills(SkillTriggerType.ON_KILL, combat_data)
        
        return result
    
    @staticmethod
    def perform_combat(attacker, defender, game_map, support_system=None) -> Dict:
        """支援効果とレジェンダリーアイテム効果を考慮した戦闘処理"""
        # 戦闘前のスキル処理
        pre_combat_data = {
            "attacker": attacker,
            "defender": defender,
            "is_attacker": True,
            "target": defender,
            "game_map": game_map
        }
        
        defender_pre_combat_data = {
            "attacker": defender,
            "defender": attacker,
            "is_attacker": False,
            "target": attacker, 
            "game_map": game_map
        }
        
        # 先制攻撃のスキルをチェック
        attacker_has_vantage = False
        defender_has_vantage = False
        
        for skill in attacker.skills:
            if (skill.trigger_type == SkillTriggerType.HP_THRESHOLD and 
                skill.effect_type == SkillEffectType.SPECIAL_ATTACK):
                if skill.check_trigger(attacker, pre_combat_data):
                    effect_value = skill.effect_value
                    if isinstance(effect_value, dict) and effect_value.get("vantage", False):
                        attacker_has_vantage = True
        
        for skill in defender.skills:
            if (skill.trigger_type == SkillTriggerType.HP_THRESHOLD and 
                skill.effect_type == SkillEffectType.SPECIAL_ATTACK):
                if skill.check_trigger(defender, defender_pre_combat_data):
                    effect_value = skill.effect_value
                    if isinstance(effect_value, dict) and effect_value.get("vantage", False):
                        defender_has_vantage = True
        
        # レジェンダリー武器による先制効果
        if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
            for effect in attacker.equipped_weapon.effects:
                if effect.effect_type == "special_attack" and isinstance(effect.effect_value, dict) and effect.effect_value.get("vantage", False):
                    attacker_has_vantage = True
        
        if defender.equipped_weapon and isinstance(defender.equipped_weapon, LegendaryWeapon):
            for effect in defender.equipped_weapon.effects:
                if effect.effect_type == "special_attack" and isinstance(effect.effect_value, dict) and effect.effect_value.get("vantage", False):
                    defender_has_vantage = True
        
        # 戦闘順序の決定（先制攻撃スキルを考慮）
        if defender_has_vantage and not attacker_has_vantage:
            # 防御側が先制
            temp_attacker = defender
            temp_defender = attacker
            swap_roles = True
        else:
            # 通常の攻撃順序
            temp_attacker = attacker
            temp_defender = defender
            swap_roles = False
            
        # 戦闘開始前のスキル発動
        attacker.activate_skills(SkillTriggerType.PRE_COMBAT, pre_combat_data)
        defender.activate_skills(SkillTriggerType.PRE_COMBAT, defender_pre_combat_data)
        
        # レジェンダリー武器の効果を適用
        if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
            attacker.equipped_weapon.apply_effects(attacker)
        
        if defender.equipped_weapon and isinstance(defender.equipped_weapon, LegendaryWeapon):
            defender.equipped_weapon.apply_effects(defender)
        
        results = {
            "attacker_results": [],
            "defender_results": [],
            "attacker_unit": attacker,
            "defender_unit": defender
        }
        
        # 攻撃側の攻撃
        attacker_result = EnhancedCombatSystem.perform_attack(temp_attacker, temp_defender, game_map, support_system)
        if swap_roles:
            results["defender_results"].append(attacker_result)
        else:
            results["attacker_results"].append(attacker_result)
        
        # 防御側が死亡した場合、戦闘終了
        if temp_defender.is_dead():
            if swap_roles:
                # 役割が逆転している場合、結果も入れ替える
                temp_results = results["attacker_results"]
                results["attacker_results"] = results["defender_results"]
                results["defender_results"] = temp_results
            
            # 戦闘後のスキル処理
            post_combat_data = {
                "attacker": attacker,
                "defender": defender,
                "results": results,
                "damage_dealt": sum(r.get("damage", 0) for r in results["attacker_results"]),
                "damage_received": 0,
                "target_killed": defender.is_dead(),
                "is_attacker": True,
            }
            
            defender_post_combat_data = {
                "attacker": defender,
                "defender": attacker,
                "results": results,
                "damage_dealt": 0,
                "damage_received": sum(r.get("damage", 0) for r in results["attacker_results"]),
                "target_killed": False,
                "is_attacker": False,
            }
            
            attacker.activate_skills(SkillTriggerType.POST_COMBAT, post_combat_data)
            defender.activate_skills(SkillTriggerType.POST_COMBAT, defender_post_combat_data)
            
            # レジェンダリー武器の効果を除去
            if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
                attacker.equipped_weapon.remove_effects(attacker)
            
            if defender.equipped_weapon and isinstance(defender.equipped_weapon, LegendaryWeapon):
                defender.equipped_weapon.remove_effects(defender)
            
            # 戦闘中に発動したスキルを結果に追加
            results["activated_skills"] = {
                "attacker": [skill.name for skill in attacker.active_skills],
                "defender": [skill.name for skill in defender.active_skills]
            }
            
            # 支援システムの更新 - 一緒に戦闘した記録
            if support_system:
                for unit1 in game_map.units:
                    for unit2 in game_map.units:
                        if unit1.team == unit2.team and unit1 != unit2:
                            # 同じチームの異なるユニット同士で
                            distance = abs(unit1.x - unit2.x) + abs(unit1.y - unit2.y)
                            if distance <= 3:  # 3マス以内のユニット
                                support_system.record_battle_together(unit1.name, unit2.name)
            
            # スキルをリセット
            attacker.deactivate_skills()
            defender.deactivate_skills()
            
            return results
        
        # 防御側の反撃（射程内の場合）
        counter_range_check = temp_defender.equipped_weapon and temp_defender.equipped_weapon.range_min <= abs(temp_attacker.x - temp_defender.x) + abs(temp_attacker.y - temp_defender.y) <= temp_defender.equipped_weapon.range_max
        guaranteed_counter = False
        
        # 特殊なスキル効果（反撃保証）
        for skill in temp_defender.active_skills:
            if skill.effect_type == SkillEffectType.COUNTER_ATTACK:
                guaranteed_counter = True
                break
        
        # レジェンダリー武器による反撃保証
        if temp_defender.equipped_weapon and isinstance(temp_defender.equipped_weapon, LegendaryWeapon):
            for effect in temp_defender.equipped_weapon.effects:
                if effect.effect_type == "counter_attack" and effect.effect_value:
                    guaranteed_counter = True
                    break
        
        can_counter = counter_range_check or guaranteed_counter
        
        if can_counter:
            defender_result = EnhancedCombatSystem.perform_attack(temp_defender, temp_attacker, game_map, support_system)
            if swap_roles:
                results["attacker_results"].append(defender_result)
            else:
                results["defender_results"].append(defender_result)
            
            # 攻撃側が死亡した場合、戦闘終了
            if temp_attacker.is_dead():
                if swap_roles:
                    # 役割が逆転している場合、結果も入れ替える
                    temp_results = results["attacker_results"]
                    results["attacker_results"] = results["defender_results"]
                    results["defender_results"] = temp_results
                
                # 戦闘後のスキル処理
                post_combat_data = {
                    "attacker": attacker,
                    "defender": defender,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "target_killed": defender.is_dead(),
                    "is_attacker": True,
                }
                
                defender_post_combat_data = {
                    "attacker": defender,
                    "defender": attacker,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "target_killed": attacker.is_dead(),
                    "is_attacker": False,
                }
                
                attacker.activate_skills(SkillTriggerType.POST_COMBAT, post_combat_data)
                defender.activate_skills(SkillTriggerType.POST_COMBAT, defender_post_combat_data)
                
                # レジェンダリー武器の効果を除去
                if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
                    attacker.equipped_weapon.remove_effects(attacker)
                
                if defender.equipped_weapon and isinstance(defender.equipped_weapon, LegendaryWeapon):
                    defender.equipped_weapon.remove_effects(defender)
                
                # 戦闘中に発動したスキルを結果に追加
                results["activated_skills"] = {
                    "attacker": [skill.name for skill in attacker.active_skills],
                    "defender": [skill.name for skill in defender.active_skills]
                }
                
                # 支援システムの更新 - 一緒に戦闘した記録
                if support_system:
                    for unit1 in game_map.units:
                        for unit2 in game_map.units:
                            if unit1.team == unit2.team and unit1 != unit2:
                                # 同じチームの異なるユニット同士で
                                distance = abs(unit1.x - unit2.x) + abs(unit1.y - unit2.y)
                                if distance <= 3:  # 3マス以内のユニット
                                    support_system.record_battle_together(unit1.name, unit2.name)
                
                # スキルをリセット
                attacker.deactivate_skills()
                defender.deactivate_skills()
                
                return results
        
        # 追撃（速度差が4以上ある場合）
        guaranteed_follow_up_attacker = False
        guaranteed_follow_up_defender = False
        
        # 特殊なスキル効果（追撃保証）
        for skill in temp_attacker.active_skills:
            if skill.effect_type == SkillEffectType.FOLLOW_UP:
                guaranteed_follow_up_attacker = True
                break
                
        for skill in temp_defender.active_skills:
            if skill.effect_type == SkillEffectType.FOLLOW_UP:
                guaranteed_follow_up_defender = True
                break
        
        # レジェンダリー武器による追撃保証
        if temp_attacker.equipped_weapon and isinstance(temp_attacker.equipped_weapon, LegendaryWeapon):
            for effect in temp_attacker.equipped_weapon.effects:
                if effect.effect_type == "follow_up" and effect.effect_value:
                    guaranteed_follow_up_attacker = True
                    break
        
        if temp_defender.equipped_weapon and isinstance(temp_defender.equipped_weapon, LegendaryWeapon):
            for effect in temp_defender.equipped_weapon.effects:
                if effect.effect_type == "follow_up" and effect.effect_value:
                    guaranteed_follow_up_defender = True
                    break
        
        if temp_attacker.can_double_attack(temp_defender) or guaranteed_follow_up_attacker:
            attacker_result2 = EnhancedCombatSystem.perform_attack(temp_attacker, temp_defender, game_map, support_system)
            if swap_roles:
                results["defender_results"].append(attacker_result2)
            else:
                results["attacker_results"].append(attacker_result2)
                
            # 防御側が死亡した場合、戦闘終了
            if temp_defender.is_dead():
                if swap_roles:
                    # 役割が逆転している場合、結果も入れ替える
                    temp_results = results["attacker_results"]
                    results["attacker_results"] = results["defender_results"]
                    results["defender_results"] = temp_results
                
                # 戦闘後のスキル処理
                post_combat_data = {
                    "attacker": attacker,
                    "defender": defender,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "target_killed": defender.is_dead(),
                    "is_attacker": True,
                }
                
                defender_post_combat_data = {
                    "attacker": defender,
                    "defender": attacker,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "target_killed": False,
                    "is_attacker": False,
                }
                
                attacker.activate_skills(SkillTriggerType.POST_COMBAT, post_combat_data)
                defender.activate_skills(SkillTriggerType.POST_COMBAT, defender_post_combat_data)
                
                # レジェンダリー武器の効果を除去
                if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
                    attacker.equipped_weapon.remove_effects(attacker)
                
                if defender.equipped_weapon and isinstance(defender.equipped_weapon, LegendaryWeapon):
                    defender.equipped_weapon.remove_effects(defender)
                
                # 戦闘中に発動したスキルを結果に追加
                results["activated_skills"] = {
                    "attacker": [skill.name for skill in attacker.active_skills],
                    "defender": [skill.name for skill in defender.active_skills]
                }
                
                # 支援システムの更新 - 一緒に戦闘した記録
                if support_system:
                    for unit1 in game_map.units:
                        for unit2 in game_map.units:
                            if unit1.team == unit2.team and unit1 != unit2:
                                # 同じチームの異なるユニット同士で
                                distance = abs(unit1.x - unit2.x) + abs(unit1.y - unit2.y)
                                if distance <= 3:  # 3マス以内のユニット
                                    support_system.record_battle_together(unit1.name, unit2.name)
                
                # スキルをリセット
                attacker.deactivate_skills()
                defender.deactivate_skills()
                
                return results
        
        elif can_counter and (temp_defender.can_double_attack(temp_attacker) or guaranteed_follow_up_defender):
            defender_result2 = EnhancedCombatSystem.perform_attack(temp_defender, temp_attacker, game_map, support_system)
            if swap_roles:
                results["attacker_results"].append(defender_result2)
            else:
                results["defender_results"].append(defender_result2)
                
            # 攻撃側が死亡した場合、戦闘終了
            if temp_attacker.is_dead():
                if swap_roles:
                    # 役割が逆転している場合、結果も入れ替える
                    temp_results = results["attacker_results"]
                    results["attacker_results"] = results["defender_results"]
                    results["defender_results"] = temp_results
                
                # 戦闘後のスキル処理
                post_combat_data = {
                    "attacker": attacker,
                    "defender": defender,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "target_killed": defender.is_dead(),
                    "is_attacker": True,
                }
                
                defender_post_combat_data = {
                    "attacker": defender,
                    "defender": attacker,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "target_killed": attacker.is_dead(),
                    "is_attacker": False,
                }
                
                attacker.activate_skills(SkillTriggerType.POST_COMBAT, post_combat_data)
                defender.activate_skills(SkillTriggerType.POST_COMBAT, defender_post_combat_data)
                
                # レジェンダリー武器の効果を除去
                if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
                    attacker.equipped_weapon.remove_effects(attacker)
                
                if defender.equipped_weapon and isinstance(defender.equipped_weapon, LegendaryWeapon):
                    defender.equipped_weapon.remove_effects(defender)
                
                # 戦闘中に発動したスキルを結果に追加
                results["activated_skills"] = {
                    "attacker": [skill.name for skill in attacker.active_skills],
                    "defender": [skill.name for skill in defender.active_skills]
                }
                
                # 支援システムの更新 - 一緒に戦闘した記録
                if support_system:
                    for unit1 in game_map.units:
                        for unit2 in game_map.units:
                            if unit1.team == unit2.team and unit1 != unit2:
                                # 同じチームの異なるユニット同士で
                                distance = abs(unit1.x - unit2.x) + abs(unit1.y - unit2.y)
                                if distance <= 3:  # 3マス以内のユニット
                                    support_system.record_battle_together(unit1.name, unit2.name)
                
                # スキルをリセット
                attacker.deactivate_skills()
                defender.deactivate_skills()
                
                return results
        
        # 役割が逆転している場合、結果も入れ替える
        if swap_roles:
            temp_results = results["attacker_results"]
            results["attacker_results"] = results["defender_results"]
            results["defender_results"] = temp_results
        
        # 戦闘後のスキル処理
        post_combat_data = {
            "attacker": attacker,
            "defender": defender,
            "results": results,
            "damage_dealt": sum(r.get("damage", 0) for r in results["attacker_results"]),
            "damage_received": sum(r.get("damage", 0) for r in results["defender_results"]),
            "target_killed": defender.is_dead(),
            "is_attacker": True,
        }
        
        defender_post_combat_data = {
            "attacker": defender,
            "defender": attacker,
            "results": results,
            "damage_dealt": sum(r.get("damage", 0) for r in results["defender_results"]),
            "damage_received": sum(r.get("damage", 0) for r in results["attacker_results"]),
            "target_killed": attacker.is_dead(),
            "is_attacker": False,
        }
        
        attacker.activate_skills(SkillTriggerType.POST_COMBAT, post_combat_data)
        defender.activate_skills(SkillTriggerType.POST_COMBAT, defender_post_combat_data)
        
        # レジェンダリー武器の効果を除去
        if attacker.equipped_weapon and isinstance(attacker.equipped_weapon, LegendaryWeapon):
            attacker.equipped_weapon.remove_effects(attacker)
        
        if defender.equipped_weapon and isinstance(defender.equipped_weapon, LegendaryWeapon):
            defender.equipped_weapon.remove_effects(defender)
        
        # 戦闘中に発動したスキルを結果に追加
        results["activated_skills"] = {
            "attacker": [skill.name for skill in attacker.active_skills],
            "defender": [skill.name for skill in defender.active_skills]
        }
        
        # 支援システムの更新 - 一緒に戦闘した記録
        if support_system:
            for unit1 in game_map.units:
                for unit2 in game_map.units:
                    if unit1.team == unit2.team and unit1 != unit2:
                        # 同じチームの異なるユニット同士で
                        distance = abs(unit1.x - unit2.x) + abs(unit1.y - unit2.y)
                        if distance <= 3:  # 3マス以内のユニット
                            support_system.record_battle_together(unit1.name, unit2.name)
        
        # スキルをリセット
        attacker.deactivate_skills()
        defender.deactivate_skills()
        
        return results
    
    @staticmethod
    def generate_reward_weapon(defeated_unit, combat_results) -> Optional[LegendaryWeapon]:
        """戦闘結果に基づいたレジェンダリー武器の生成"""
        from legendary_items import LegendaryItemGenerator, ItemRarity
        
        # 強いユニットを倒すほど良い武器が出やすい
        level_factor = defeated_unit.level / 20.0  # レベル20が最大値として正規化
        
        # クリティカルや連続攻撃などでの派手な勝利
        spectacular_victory = any(r.get("critical", False) for r in combat_results["attacker_results"])
        spectacular_victory = spectacular_victory or any(r.get("multi_attack", False) for r in combat_results["attacker_results"])
        
        # レア度の確率決定
        rarity_weights = {
            ItemRarity.UNCOMMON: 100 * (1.0 - level_factor),
            ItemRarity.RARE: 50 * level_factor,
            ItemRarity.EPIC: 20 * level_factor,
            ItemRarity.LEGENDARY: 5 * level_factor
        }
        
        # 派手な勝利ならレア度の高い武器が出やすくする
        if spectacular_victory:
            for rarity in [ItemRarity.RARE, ItemRarity.EPIC, ItemRarity.LEGENDARY]:
                rarity_weights[rarity] *= 1.5
        
        # ドロップするかの判定（倒したユニットが強いほど確率上昇）
        drop_chance = 5 + 25 * level_factor  # 5-30%
        if spectacular_victory:
            drop_chance *= 1.5  # 派手な勝利なら1.5倍
        
        if random.random() * 100 > drop_chance:
            return None  # ドロップなし
        
        # レア度の選択
        rarity_choice = random.choices(
            list(rarity_weights.keys()),
            weights=list(rarity_weights.values()),
            k=1
        )[0]
        
        # 倒したユニットの武器タイプを高確率で引き継ぐ
        weapon_type = None
        if defeated_unit.equipped_weapon and random.random() < 0.7:
            weapon_type = defeated_unit.equipped_weapon.weapon_type
        
        # レジェンダリー武器の生成
        generator = LegendaryItemGenerator()
        return generator.generate_legendary_weapon(rarity_choice, weapon_type)

================
File: combat.py
================
# combat.py
import random
from typing import Dict
from constants import WeaponType, WEAPON_TRIANGLE
from skills import SkillTriggerType, SkillEffectType

class CombatSystem:
    @staticmethod
    def calculate_hit_chance(attacker, defender, game_map) -> int:
        hit_rate = attacker.get_hit_rate()
        avoid = defender.get_avoid()
        terrain_dodge = game_map.get_terrain_dodge(defender.x, defender.y)
        
        # 武器相性ボーナス
        weapon_bonus = 0
        if attacker.equipped_weapon and defender.equipped_weapon:
            attacker_type = attacker.equipped_weapon.weapon_type
            defender_type = defender.equipped_weapon.weapon_type
            
            if attacker_type in WEAPON_TRIANGLE and defender_type in WEAPON_TRIANGLE[attacker_type]:
                weapon_bonus = WEAPON_TRIANGLE[attacker_type][defender_type] * 15
        
        # スキルによる命中修正
        hit_modifier = 0
        for skill in attacker.active_skills:
            if skill.effect_type == SkillEffectType.HIT_BOOST:
                hit_modifier += skill.effect_value
        
        # 特殊なスキル効果（例: 斧殺し）
        for skill in attacker.active_skills:
            if skill.effect_type == SkillEffectType.SPECIAL_ATTACK:
                if isinstance(skill.effect_value, dict):
                    condition = skill.effect_value.get("condition", "")
                    if "opponent_weapon_type" in condition and defender.equipped_weapon:
                        # 条件を評価
                        weapon_condition = f"WeaponType.{defender.equipped_weapon.weapon_type.name}"
                        if weapon_condition in condition:
                            hit_modifier += skill.effect_value.get("hit_bonus", 0)
        
        # 防御側のスキルによる回避修正
        avoid_modifier = 0
        for skill in defender.active_skills:
            if skill.effect_type == SkillEffectType.AVOID_BOOST:
                avoid_modifier += skill.effect_value
        
        hit_chance = hit_rate + weapon_bonus + hit_modifier - avoid - terrain_dodge - avoid_modifier
        return max(0, min(100, hit_chance))
    
    @staticmethod
    def calculate_damage(attacker, defender, game_map) -> int:
        attack_power = attacker.get_attack_power()
        is_magic = attacker.equipped_weapon and attacker.equipped_weapon.weapon_type == WeaponType.MAGIC
        
        defense_stat = defender.resistance if is_magic else defender.defense
        terrain_defense = game_map.get_terrain_defense(defender.x, defender.y)
        
        # 武器相性ボーナス
        weapon_bonus = 0
        if attacker.equipped_weapon and defender.equipped_weapon:
            attacker_type = attacker.equipped_weapon.weapon_type
            defender_type = defender.equipped_weapon.weapon_type
            
            if attacker_type in WEAPON_TRIANGLE and defender_type in WEAPON_TRIANGLE[attacker_type]:
                weapon_bonus = WEAPON_TRIANGLE[attacker_type][defender_type] * 1
        
        # スキルによるダメージ修正
        damage_modifier = 0
        for skill in attacker.active_skills:
            if skill.effect_type == SkillEffectType.DAMAGE_BOOST:
                damage_modifier += skill.effect_value
        
        # 防御側のスキルによるダメージ減少
        damage_reduction = 0
        for skill in defender.active_skills:
            if skill.effect_type == SkillEffectType.DAMAGE_REDUCE:
                if isinstance(skill.effect_value, float):
                    # 割合によるダメージ減少
                    damage_reduction += int((attack_power - defense_stat) * skill.effect_value)
                else:
                    # 固定値によるダメージ減少
                    damage_reduction += skill.effect_value
        
        # 特殊なスキル効果（例: 月光）
        for skill in attacker.active_skills:
            if skill.effect_type == SkillEffectType.SPECIAL_ATTACK:
                if isinstance(skill.effect_value, dict) and "defense_pierce" in skill.effect_value:
                    pierce_amount = int(defense_stat * skill.effect_value["defense_pierce"])
                    damage_modifier += pierce_amount
        
        damage = attack_power + weapon_bonus + damage_modifier - defense_stat - terrain_defense - damage_reduction
        return max(0, damage)
    
    @staticmethod
    def calculate_crit_chance(attacker, defender) -> int:
        crit_rate = attacker.get_critical_rate()
        crit_avoid = defender.luck
        
        # スキルによるクリティカル修正
        crit_modifier = 0
        for skill in attacker.active_skills:
            if skill.effect_type == SkillEffectType.CRITICAL_BOOST:
                crit_modifier += skill.effect_value
        
        crit_chance = crit_rate + crit_modifier - crit_avoid
        return max(0, min(100, crit_chance))
    
    @staticmethod
    def perform_attack(attacker, defender, game_map) -> Dict:
        # スキルの発動チェック（攻撃時）
        combat_data = {
            "attacker": attacker,
            "defender": defender,
            "is_attacker": True,
            "target": defender,
            "game_map": game_map
        }
        
        attacker.activate_skills(SkillTriggerType.ON_ATTACK, combat_data)
        defender.activate_skills(SkillTriggerType.ON_DEFEND, combat_data)
        
        # スキルを考慮した計算
        hit_chance = CombatSystem.calculate_hit_chance(attacker, defender, game_map)
        damage = CombatSystem.calculate_damage(attacker, defender, game_map)
        crit_chance = CombatSystem.calculate_crit_chance(attacker, defender)
        
        # 命中判定
        hit_roll = random.randint(1, 100)
        hit = hit_roll <= hit_chance
        
        # クリティカル判定
        crit_roll = random.randint(1, 100)
        crit = hit and crit_roll <= crit_chance
        
        # 連続攻撃スキルの処理
        multi_attack = False
        attack_count = 1
        damage_multiplier = 1.0
        
        for skill in attacker.active_skills:
            if skill.effect_type == SkillEffectType.SPECIAL_ATTACK:
                if isinstance(skill.effect_value, dict) and "attacks" in skill.effect_value:
                    multi_attack = True
                    attack_count = skill.effect_value.get("attacks", 1)
                    damage_multiplier = skill.effect_value.get("damage_multiplier", 1.0)
        
        # ダメージ計算と適用
        if hit:
            total_damage = 0
            
            if multi_attack:
                # 連続攻撃の処理
                for i in range(attack_count):
                    attack_damage = int(damage * damage_multiplier)
                    if i == 0 and crit:
                        attack_damage *= 3
                    defender.current_hp = max(0, defender.current_hp - attack_damage)
                    total_damage += attack_damage
                    if defender.is_dead():
                        break
            else:
                # 通常攻撃
                attack_damage = damage * 3 if crit else damage
                defender.current_hp = max(0, defender.current_hp - attack_damage)
                total_damage = attack_damage
                
            # 攻撃後の回復スキル処理
            for skill in attacker.active_skills:
                if skill.effect_type == SkillEffectType.HEAL:
                    if isinstance(skill.effect_value, dict) and "heal_ratio" in skill.effect_value:
                        heal_amount = int(total_damage * skill.effect_value["heal_ratio"])
                        attacker.current_hp = min(attacker.max_hp, attacker.current_hp + heal_amount)
            
            # 武器の耐久度を減らす
            if attacker.equipped_weapon:
                attacker.equipped_weapon.durability -= 1
        
        # 戦闘結果の作成
        result = {
            "hit": hit,
            "damage": total_damage if hit else 0,
            "critical": crit,
            "killed": defender.is_dead(),
            "hit_chance": hit_chance,
            "crit_chance": crit_chance,
            "multi_attack": multi_attack,
            "attack_count": attack_count if multi_attack and hit else 1,
        }
        
        # 戦闘結果に基づいたスキルの発動
        if hit and total_damage > 0:
            combat_data["damage_dealt"] = total_damage
            attacker.activate_skills(SkillTriggerType.ON_DAMAGE, combat_data)
        
        if defender.is_dead():
            combat_data["target_killed"] = True
            attacker.activate_skills(SkillTriggerType.ON_KILL, combat_data)
        
        return result
    
    @staticmethod
    def perform_combat(attacker, defender, game_map) -> Dict:
        """スキルを考慮した戦闘処理"""
        # 戦闘前のスキル処理
        pre_combat_data = {
            "attacker": attacker,
            "defender": defender,
            "is_attacker": True,
            "target": defender,
            "game_map": game_map
        }
        
        defender_pre_combat_data = {
            "attacker": defender,
            "defender": attacker,
            "is_attacker": False,
            "target": attacker, 
            "game_map": game_map
        }
        
        # 先制攻撃のスキルをチェック
        attacker_has_vantage = False
        defender_has_vantage = False
        
        for skill in attacker.skills:
            if (skill.trigger_type == SkillTriggerType.HP_THRESHOLD and 
                skill.effect_type == SkillEffectType.SPECIAL_ATTACK):
                if skill.check_trigger(attacker, pre_combat_data):
                    effect_value = skill.effect_value
                    if isinstance(effect_value, dict) and effect_value.get("vantage", False):
                        attacker_has_vantage = True
        
        for skill in defender.skills:
            if (skill.trigger_type == SkillTriggerType.HP_THRESHOLD and 
                skill.effect_type == SkillEffectType.SPECIAL_ATTACK):
                if skill.check_trigger(defender, defender_pre_combat_data):
                    effect_value = skill.effect_value
                    if isinstance(effect_value, dict) and effect_value.get("vantage", False):
                        defender_has_vantage = True
        
        # 戦闘順序の決定（先制攻撃スキルを考慮）
        if defender_has_vantage and not attacker_has_vantage:
            # 防御側が先制
            temp_attacker = defender
            temp_defender = attacker
            swap_roles = True
        else:
            # 通常の攻撃順序
            temp_attacker = attacker
            temp_defender = defender
            swap_roles = False
            
        # 戦闘開始前のスキル発動
        attacker.activate_skills(SkillTriggerType.PRE_COMBAT, pre_combat_data)
        defender.activate_skills(SkillTriggerType.PRE_COMBAT, defender_pre_combat_data)
        
        results = {
            "attacker_results": [],
            "defender_results": [],
            "attacker_unit": attacker,
            "defender_unit": defender
        }
        
        # 攻撃側の攻撃
        attacker_result = CombatSystem.perform_attack(temp_attacker, temp_defender, game_map)
        if swap_roles:
            results["defender_results"].append(attacker_result)
        else:
            results["attacker_results"].append(attacker_result)
        
        # 防御側が死亡した場合、戦闘終了
        if temp_defender.is_dead():
            if swap_roles:
                # 役割が逆転している場合、結果も入れ替える
                temp_results = results["attacker_results"]
                results["attacker_results"] = results["defender_results"]
                results["defender_results"] = temp_results
            
            # 戦闘後のスキル処理
            post_combat_data = {
                "attacker": attacker,
                "defender": defender,
                "results": results,
                "damage_dealt": sum(r.get("damage", 0) for r in results["attacker_results"]),
                "damage_received": 0,
                "target_killed": defender.is_dead(),
                "is_attacker": True,
            }
            
            defender_post_combat_data = {
                "attacker": defender,
                "defender": attacker,
                "results": results,
                "damage_dealt": 0,
                "damage_received": sum(r.get("damage", 0) for r in results["attacker_results"]),
                "target_killed": False,
                "is_attacker": False,
            }
            
            attacker.activate_skills(SkillTriggerType.POST_COMBAT, post_combat_data)
            defender.activate_skills(SkillTriggerType.POST_COMBAT, defender_post_combat_data)
            
            # 戦闘中に発動したスキルを結果に追加
            results["activated_skills"] = {
                "attacker": [skill.name for skill in attacker.active_skills],
                "defender": [skill.name for skill in defender.active_skills]
            }
            
            # スキルをリセット
            attacker.deactivate_skills()
            defender.deactivate_skills()
            
            return results
        
        # 防御側の反撃（射程内の場合）
        counter_range_check = temp_defender.equipped_weapon and temp_defender.equipped_weapon.range_min <= abs(temp_attacker.x - temp_defender.x) + abs(temp_attacker.y - temp_defender.y) <= temp_defender.equipped_weapon.range_max
        guaranteed_counter = False
        
        # 特殊なスキル効果（反撃保証）
        for skill in temp_defender.active_skills:
            if skill.effect_type == SkillEffectType.COUNTER_ATTACK:
                guaranteed_counter = True
                break
        
        can_counter = counter_range_check or guaranteed_counter
        
        if can_counter:
            defender_result = CombatSystem.perform_attack(temp_defender, temp_attacker, game_map)
            if swap_roles:
                results["attacker_results"].append(defender_result)
            else:
                results["defender_results"].append(defender_result)
            
            # 攻撃側が死亡した場合、戦闘終了
            if temp_attacker.is_dead():
                if swap_roles:
                    # 役割が逆転している場合、結果も入れ替える
                    temp_results = results["attacker_results"]
                    results["attacker_results"] = results["defender_results"]
                    results["defender_results"] = temp_results
                
                # 戦闘後のスキル処理
                post_combat_data = {
                    "attacker": attacker,
                    "defender": defender,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "target_killed": defender.is_dead(),
                    "is_attacker": True,
                }
                
                defender_post_combat_data = {
                    "attacker": defender,
                    "defender": attacker,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "target_killed": attacker.is_dead(),
                    "is_attacker": False,
                }
                
                attacker.activate_skills(SkillTriggerType.POST_COMBAT, post_combat_data)
                defender.activate_skills(SkillTriggerType.POST_COMBAT, defender_post_combat_data)
                
                # 戦闘中に発動したスキルを結果に追加
                results["activated_skills"] = {
                    "attacker": [skill.name for skill in attacker.active_skills],
                    "defender": [skill.name for skill in defender.active_skills]
                }
                
                # スキルをリセット
                attacker.deactivate_skills()
                defender.deactivate_skills()
                
                return results
        
        # 追撃（速度差が4以上ある場合）
        guaranteed_follow_up_attacker = False
        guaranteed_follow_up_defender = False
        
        # 特殊なスキル効果（追撃保証）
        for skill in temp_attacker.active_skills:
            if skill.effect_type == SkillEffectType.FOLLOW_UP:
                guaranteed_follow_up_attacker = True
                break
                
        for skill in temp_defender.active_skills:
            if skill.effect_type == SkillEffectType.FOLLOW_UP:
                guaranteed_follow_up_defender = True
                break
        
        if temp_attacker.can_double_attack(temp_defender) or guaranteed_follow_up_attacker:
            attacker_result2 = CombatSystem.perform_attack(temp_attacker, temp_defender, game_map)
            if swap_roles:
                results["defender_results"].append(attacker_result2)
            else:
                results["attacker_results"].append(attacker_result2)
                
            # 防御側が死亡した場合、戦闘終了
            if temp_defender.is_dead():
                if swap_roles:
                    # 役割が逆転している場合、結果も入れ替える
                    temp_results = results["attacker_results"]
                    results["attacker_results"] = results["defender_results"]
                    results["defender_results"] = temp_results
                
                # 戦闘後のスキル処理
                post_combat_data = {
                    "attacker": attacker,
                    "defender": defender,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "target_killed": defender.is_dead(),
                    "is_attacker": True,
                }
                
                defender_post_combat_data = {
                    "attacker": defender,
                    "defender": attacker,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "target_killed": False,
                    "is_attacker": False,
                }
                
                attacker.activate_skills(SkillTriggerType.POST_COMBAT, post_combat_data)
                defender.activate_skills(SkillTriggerType.POST_COMBAT, defender_post_combat_data)
                
                # 戦闘中に発動したスキルを結果に追加
                results["activated_skills"] = {
                    "attacker": [skill.name for skill in attacker.active_skills],
                    "defender": [skill.name for skill in defender.active_skills]
                }
                
                # スキルをリセット
                attacker.deactivate_skills()
                defender.deactivate_skills()
                
                return results
        
        elif can_counter and (temp_defender.can_double_attack(temp_attacker) or guaranteed_follow_up_defender):
            defender_result2 = CombatSystem.perform_attack(temp_defender, temp_attacker, game_map)
            if swap_roles:
                results["attacker_results"].append(defender_result2)
            else:
                results["defender_results"].append(defender_result2)
                
            # 攻撃側が死亡した場合、戦闘終了
            if temp_attacker.is_dead():
                if swap_roles:
                    # 役割が逆転している場合、結果も入れ替える
                    temp_results = results["attacker_results"]
                    results["attacker_results"] = results["defender_results"]
                    results["defender_results"] = temp_results
                
                # 戦闘後のスキル処理
                post_combat_data = {
                    "attacker": attacker,
                    "defender": defender,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "target_killed": defender.is_dead(),
                    "is_attacker": True,
                }
                
                defender_post_combat_data = {
                    "attacker": defender,
                    "defender": attacker,
                    "results": results,
                    "damage_dealt": sum(r.get("damage", 0) for r in results["defender_results"]),
                    "damage_received": sum(r.get("damage", 0) for r in results["attacker_results"]),
                    "target_killed": attacker.is_dead(),
                    "is_attacker": False,
                }
                
                attacker.activate_skills(SkillTriggerType.POST_COMBAT, post_combat_data)
                defender.activate_skills(SkillTriggerType.POST_COMBAT, defender_post_combat_data)
                
                # 戦闘中に発動したスキルを結果に追加
                results["activated_skills"] = {
                    "attacker": [skill.name for skill in attacker.active_skills],
                    "defender": [skill.name for skill in defender.active_skills]
                }
                
                # スキルをリセット
                attacker.deactivate_skills()
                defender.deactivate_skills()
                
                return results
        
        # 役割が逆転している場合、結果も入れ替える
        if swap_roles:
            temp_results = results["attacker_results"]
            results["attacker_results"] = results["defender_results"]
            results["defender_results"] = temp_results
        
        # 戦闘後のスキル処理
        post_combat_data = {
            "attacker": attacker,
            "defender": defender,
            "results": results,
            "damage_dealt": sum(r.get("damage", 0) for r in results["attacker_results"]),
            "damage_received": sum(r.get("damage", 0) for r in results["defender_results"]),
            "target_killed": defender.is_dead(),
            "is_attacker": True,
        }
        
        defender_post_combat_data = {
            "attacker": defender,
            "defender": attacker,
            "results": results,
            "damage_dealt": sum(r.get("damage", 0) for r in results["defender_results"]),
            "damage_received": sum(r.get("damage", 0) for r in results["attacker_results"]),
            "target_killed": attacker.is_dead(),
            "is_attacker": False,
        }
        
        attacker.activate_skills(SkillTriggerType.POST_COMBAT, post_combat_data)
        defender.activate_skills(SkillTriggerType.POST_COMBAT, defender_post_combat_data)
        
        # 戦闘中に発動したスキルを結果に追加
        results["activated_skills"] = {
            "attacker": [skill.name for skill in attacker.active_skills],
            "defender": [skill.name for skill in defender.active_skills]
        }
        
        # スキルをリセット
        attacker.deactivate_skills()
        defender.deactivate_skills()
        
        return results
    
    @staticmethod
    def perform_capture_attack(attacker, defender, game_map) -> Dict:
        """捕獲目的の攻撃を実行"""
        # 捕獲時のステータス補正を適用
        capture_stats = attacker.get_capture_battle_stats()
        original_skill = attacker.skill
        original_speed = attacker.speed
        
        # 一時的にステータスを変更
        attacker.skill = capture_stats["skill"]
        attacker.speed = capture_stats["speed"]
        
        # 通常の攻撃処理を実行
        result = CombatSystem.perform_attack(attacker, defender, game_map)
        
        # ステータスを元に戻す
        attacker.skill = original_skill
        attacker.speed = original_speed
        
        # 捕獲フラグを追加
        result["capture_attempt"] = True
        
        return result

================
File: constants.py
================
# constants.py
import pygame
from enum import Enum

# 定数
SCREEN_WIDTH = 480
SCREEN_HEIGHT = 320
GRID_SIZE = 32
MAP_ROWS = 10
MAP_COLS = 15

# 色の定義
COLOR_BLACK = (0, 0, 0)
COLOR_WHITE = (255, 255, 255)
COLOR_RED = (255, 0, 0)
COLOR_BLUE = (0, 0, 255)
COLOR_GREEN = (0, 255, 0)
COLOR_YELLOW = (255, 255, 0)
COLOR_GRAY = (128, 128, 128)

# 地形タイプ
class TerrainType(Enum):
    PLAIN = 1
    FOREST = 2
    MOUNTAIN = 3
    WATER = 4
    WALL = 5

# 地形効果
TERRAIN_EFFECTS = {
    TerrainType.PLAIN: {"move_cost": 1, "dodge": 0, "defense": 0},
    TerrainType.FOREST: {"move_cost": 2, "dodge": 20, "defense": 1},
    TerrainType.MOUNTAIN: {"move_cost": 3, "dodge": 10, "defense": 2},
    TerrainType.WATER: {"move_cost": 4, "dodge": 0, "defense": 0},
    TerrainType.WALL: {"move_cost": 999, "dodge": 0, "defense": 0},
}

# 武器タイプ
class WeaponType(Enum):
    SWORD = 1
    LANCE = 2
    AXE = 3
    BOW = 4
    MAGIC = 5

# 武器相性
WEAPON_TRIANGLE = {
    WeaponType.SWORD: {WeaponType.AXE: 1, WeaponType.LANCE: -1},
    WeaponType.LANCE: {WeaponType.SWORD: 1, WeaponType.AXE: -1},
    WeaponType.AXE: {WeaponType.LANCE: 1, WeaponType.SWORD: -1},
}

================
File: dialogue_system.py
================
# dialogue_system.py
import pygame
from ui_system import Panel, Label, Button

class DialogueScreen(Panel):
    def __init__(self, x, y, width, height, dialogue_data, on_complete=None):
        super().__init__(x, y, width, height)
        self.dialogue_data = dialogue_data
        self.on_complete = on_complete
        self.current_line = 0
        
        # キャラクター表示領域（左右）
        self.left_char_panel = Panel(20, 70, 120, 150, (40, 40, 80), None, 0, 150)
        self.right_char_panel = Panel(width - 140, 70, 120, 150, (40, 40, 80), None, 0, 150)
        
        self.add_child(self.left_char_panel)
        self.add_child(self.right_char_panel)
        
        # キャラクター名ラベル
        self.left_name = Label(80, 230, "", None, 24, (100, 100, 255), None, "center")
        self.right_name = Label(width - 80, 230, "", None, 24, (255, 100, 100), None, "center")
        
        self.add_child(self.left_name)
        self.add_child(self.right_name)
        
        # 会話テキスト領域
        self.dialogue_panel = Panel(20, height - 120, width - 40, 100, (40, 40, 60), (255, 255, 255), 1, 230)
        self.add_child(self.dialogue_panel)
        
        # 話者名
        self.speaker_label = Label(40, height - 120, "", None, 24, (255, 255, 0))
        self.add_child(self.speaker_label)
        
        # 会話テキスト
        self.text_label = Label(30, height - 90, "", None, 22, (255, 255, 255))
        self.add_child(self.text_label)
        
        # 次へボタン
        self.next_btn = Button(width - 80, height - 40, 60, 30, "次へ", None, 20,
                              (60, 60, 100), (255, 255, 255), (80, 80, 150),
                              (0, 0, 0), 1, self.next_line)
        self.add_child(self.next_btn)
        
        # 最初の会話行を表示
        self.update_dialogue()
    
    def update_dialogue(self):
        """現在の会話行を表示"""
        if not self.dialogue_data or self.current_line >= len(self.dialogue_data):
            # 会話終了
            if self.on_complete:
                self.on_complete()
            return
        
        line = self.dialogue_data[self.current_line]
        speaker = line.get("speaker", "")
        text = line.get("text", "")
        left_char = line.get("left_character", "")
        right_char = line.get("right_character", "")
        
        # 話者と会話テキストを更新
        self.speaker_label.set_text(speaker)
        self.text_label.set_text(text)
        
        # キャラクター名を更新
        self.left_name.set_text(left_char)
        self.right_name.set_text(right_char)
        
        # 話者に応じた色を設定
        if speaker == left_char:
            self.speaker_label.color = (100, 100, 255)  # 左側キャラクターの色
        elif speaker == right_char:
            self.speaker_label.color = (255, 100, 100)  # 右側キャラクターの色
        else:
            self.speaker_label.color = (255, 255, 0)  # デフォルト色
    
    def next_line(self):
        """次の会話行に進む"""
        self.current_line += 1
        
        if self.current_line >= len(self.dialogue_data):
            # 会話終了
            if self.on_complete:
                self.on_complete()
        else:
            self.update_dialogue()

================
File: game_manager.py
================
# game_manager.py
from typing import List, Tuple, Dict, Optional, Callable
import random
import os
from combat_integration import EnhancedCombatSystem
from support_system import SupportSystem, SupportLevel
from legendary_items import LegendaryItemGenerator, LegendaryWeapon, ItemRarity
from skills import SkillTriggerType, SkillEffectType

class GameManager:
    def __init__(self, game_map):
        # 基本システム
        self.game_map = game_map
        self.current_turn = 0
        self.turn_player = 0  # 0: プレイヤー, 1: 敵
        self.selected_unit = None
        self.move_targets = []
        self.attack_targets = []
        self.combat_results = None
        self.combat_animation_active = False
        self.phase = "select_unit"  # select_unit, move_unit, select_action, select_attack_target
        
        # 拡張システム
        self.support_system = SupportSystem("data/supports/")
        self.legendary_generator = LegendaryItemGenerator()
        
        # インベントリシステム
        self.inventory = []  # ユニットに所属しない共有アイテム
        
        # UI関連のコールバック
        self.on_support_level_up = None  # 支援レベルアップ時のコールバック
        self.on_item_drop = None  # アイテムドロップ時のコールバック
        self.on_level_up = None  # レベルアップ時のコールバック
        
        # デバッグ用のアイテム
        if os.path.exists("debug_mode"):
            self._add_debug_items()
        
        # 初期支援関係の設定
        self._setup_default_supports()
    
    def _add_debug_items(self):
        """デバッグ用の初期アイテム追加"""
        # 各レア度のテスト武器
        for rarity in [ItemRarity.UNCOMMON, ItemRarity.RARE, ItemRarity.EPIC, ItemRarity.LEGENDARY]:
            for _ in range(2):  # 各2つずつ
                weapon = self.legendary_generator.generate_legendary_weapon(rarity)
                self.inventory.append(weapon)
    
    def _setup_default_supports(self):
        """初期支援関係の設定"""
        # ユニットのリストを取得
        player_units = [unit for unit in self.game_map.units if unit.team == 0]
        
        # プレイヤーユニット間の支援関係を設定
        for i, unit1 in enumerate(player_units):
            for unit2 in player_units[i+1:]:
                # デフォルトではAランクまでの支援を設定
                self.support_system.register_support_pair(unit1.name, unit2.name, SupportLevel.A)
    
    def select_unit(self, x: int, y: int) -> bool:
        """ユニットを選択"""
        unit = self.game_map.get_unit_at(x, y)
        if unit and unit.team == self.turn_player and not unit.has_moved:
            self.selected_unit = unit
            self.move_targets = self.game_map.calculate_movement_range(unit)
            self.phase = "move_unit"
            return True
        return False
    
    def move_selected_unit(self, x: int, y: int) -> bool:
        """選択中のユニットを移動"""
        if not self.selected_unit or (x, y) not in self.move_targets:
            return False
        
        if self.game_map.move_unit(self.selected_unit, x, y):
            self.attack_targets = self.game_map.calculate_attack_range(self.selected_unit)
            enemies = self.game_map.get_enemies_in_range(self.selected_unit, self.attack_targets)
            
            if enemies and not self.selected_unit.has_attacked:
                self.phase = "select_action"
            else:
                self.end_unit_turn()
            return True
        return False
    
    def select_action(self, action: str) -> bool:
        """ユニットのアクションを選択"""
        if action == "attack":
            enemies = self.game_map.get_enemies_in_range(
                self.selected_unit, 
                self.game_map.calculate_attack_range(self.selected_unit)
            )
            if enemies:
                self.phase = "select_attack_target"
                return True
        elif action == "wait":
            self.end_unit_turn()
            return True
        elif action == "item":
            # アイテム使用機能（未実装）
            return False
        elif action == "support":
            # 支援会話表示（UIコールバックに委譲）
            # 表示可能な支援会話を取得
            available_supports = []
            for char1, char2, level in self.support_system.get_available_conversations():
                # 現在選択中のユニットが関わる支援のみ
                if self.selected_unit.name in [char1, char2]:
                    available_supports.append((char1, char2, level))
            
            # 支援会話が存在する場合
            if available_supports:
                # UIコールバックがあれば実行（支援会話リスト表示）
                if hasattr(self, "on_show_support_list") and self.on_show_support_list:
                    self.on_show_support_list(self.selected_unit.name)
                    return True
            return False
        return False
    
    def select_attack_target(self, x: int, y: int) -> bool:
        """攻撃対象を選択"""
        target = self.game_map.get_unit_at(x, y)
        if not target or target.team == self.selected_unit.team:
            return False
        
        attack_positions = self.game_map.calculate_attack_range(self.selected_unit)
        if (x, y) in attack_positions:
            # 拡張戦闘システムを使用
            self.combat_results = EnhancedCombatSystem.perform_combat(
                self.selected_unit, target, self.game_map, self.support_system
            )
            self.combat_animation_active = True
            self.selected_unit.has_attacked = True
            
            # 敵を倒した場合、アイテムドロップ判定
            if target.is_dead():
                self._check_item_drop(target)
                
                # 支援ポイント加算（キル時のボーナス）
                self._add_kill_support_points(self.selected_unit)
                
                # 経験値獲得
                self._award_experience(self.selected_unit, target)
            else:
                # 敵を倒せなかった場合も経験値獲得（少なめ）
                self._award_experience(self.selected_unit, target, defeated=False)
            
            self.end_unit_turn()
            return True
        return False
    
    def _award_experience(self, attacker, defender, defeated=True):
        """経験値の付与とレベルアップ処理"""
        from growth_system import GrowthSystem
        growth_system = GrowthSystem()
        
        # 戦闘から経験値を計算
        exp_amount = growth_system.calculate_combat_exp(attacker, defender, self.combat_results)
        
        # 経験値を増加（倒せなかった場合は半減）
        if not defeated:
            exp_amount = max(1, exp_amount // 2)
        
        # 経験値を付与し、レベルアップ判定
        level_up, stat_gains = growth_system.award_exp(attacker, exp_amount)
        
        # レベルアップした場合
        if level_up:
            # UIコールバックがあれば実行
            if self.on_level_up:
                self.on_level_up(attacker, stat_gains)
    
    def _check_item_drop(self, defeated_unit):
        """敵を倒した時のアイテムドロップ判定"""
        legendary_weapon = EnhancedCombatSystem.generate_reward_weapon(
            defeated_unit, self.combat_results
        )
        
        if legendary_weapon:
            if self.on_item_drop:
                # UIコールバックを呼び出し
                self.on_item_drop(legendary_weapon)
            else:
                # UI機能がなければ自動的にインベントリに追加
                self.inventory.append(legendary_weapon)
    
    def _add_kill_support_points(self, unit):
        """ユニットが敵を倒した時に支援ポイントを加算"""
        # ユニットと、3マス以内の味方全員で支援ポイント追加
        for other_unit in self.game_map.units:
            if other_unit.team == unit.team and other_unit != unit and not other_unit.is_dead():
                distance = abs(unit.x - other_unit.x) + abs(unit.y - other_unit.y)
                if distance <= 3:
                    # キルボーナスとして支援ポイント追加
                    level_up, new_level = self.support_system.add_support_points(
                        unit.name, other_unit.name, 10  # キルボーナス10ポイント
                    )
                    
                    # 支援レベルアップ通知
                    if level_up and self.on_support_level_up:
                        self.on_support_level_up(unit.name, other_unit.name, new_level)
    
    def end_unit_turn(self):
        """ユニットのターン終了"""
        self.selected_unit = None
        self.move_targets = []
        self.attack_targets = []
        self.phase = "select_unit"
    
    def end_player_turn(self):
        """プレイヤーのターン終了"""
        # 隣接しているユニットの支援ポイント処理
        self._process_adjacent_units_support()
        
        # 通常のターン終了処理
        for unit in self.game_map.units:
            if unit.team == self.turn_player:
                unit.end_turn()
        
        self.turn_player = 1 - self.turn_player
        if self.turn_player == 0:
            self.current_turn += 1
        
        self.phase = "select_unit"
    
    def _process_adjacent_units_support(self):
        """ターン終了時、隣接するユニット間の支援ポイント処理"""
        processed_pairs = set()
        
        # すべてのプレイヤーユニットをチェック
        player_units = [unit for unit in self.game_map.units if unit.team == 0 and not unit.is_dead()]
        
        for unit1 in player_units:
            for unit2 in player_units:
                if unit1 == unit2:
                    continue
                
                # 既に処理したペアはスキップ
                pair_key = tuple(sorted([unit1.name, unit2.name]))
                if pair_key in processed_pairs:
                    continue
                
                # 隣接するユニット間の支援ポイント
                distance = abs(unit1.x - unit2.x) + abs(unit1.y - unit2.y)
                if distance == 1:  # 隣接している場合
                    # 支援ポイント付与
                    level_up, new_level = self.support_system.record_adjacent_turns(unit1.name, unit2.name)
                    
                    # 支援レベルアップ通知
                    if level_up and self.on_support_level_up:
                        self.on_support_level_up(unit1.name, unit2.name, new_level)
                
                processed_pairs.add(pair_key)
    
    def execute_ai_turn(self):
        """AIのターン実行"""
        if self.turn_player != 1:
            return
        
        for unit in self.game_map.units:
            if unit.team != 1 or unit.has_moved or unit.is_dead():
                continue
            
            # 移動範囲の計算
            move_positions = self.game_map.calculate_movement_range(unit)
            
            # 各移動位置から攻撃可能な敵をチェック
            best_target = None
            best_damage = -1
            best_position = None
            
            for pos_x, pos_y in move_positions:
                attack_positions = self.game_map.calculate_attack_range(unit, (pos_x, pos_y))
                for attack_x, attack_y in attack_positions:
                    target = self.game_map.get_unit_at(attack_x, attack_y)
                    if target and target.team != unit.team:
                        damage = EnhancedCombatSystem.calculate_damage(unit, target, self.game_map, self.support_system)
                        hit_chance = EnhancedCombatSystem.calculate_hit_chance(unit, target, self.game_map, self.support_system)
                        expected_damage = damage * hit_chance / 100
                        
                        if expected_damage > best_damage:
                            best_damage = expected_damage
                            best_target = target
                            best_position = (pos_x, pos_y)
            
            # 最適な行動を実行
            if best_target and best_position:
                self.game_map.move_unit(unit, best_position[0], best_position[1])
                unit.has_moved = True
                
                # 攻撃実行
                combat_results = EnhancedCombatSystem.perform_combat(unit, best_target, self.game_map, self.support_system)
                unit.has_attacked = True
                
                # プレイヤーユニットが倒された場合の経験値処理（AIにはレベルアップなし）
                if best_target.is_dead() and best_target.team == 0:
                    # プレイヤーユニットは復活するが、経験値やドロップはなし
                    best_target.current_hp = 1  # 仮の処理：戦線離脱ではなく復活
        
        self.end_player_turn()
    
    def equip_weapon(self, unit, weapon):
        """ユニットに武器を装備"""
        if not unit or not weapon:
            return False
        
        # 装備可能か確認
        if isinstance(weapon, LegendaryWeapon) and not weapon.can_equip(unit):
            return False
        
        # 現在装備中の武器をインベントリに戻す（あれば）
        if unit.equipped_weapon:
            self.inventory.append(unit.equipped_weapon)
        
        # 新しい武器を装備
        unit.equipped_weapon = weapon
        
        # インベントリから削除
        if weapon in self.inventory:
            self.inventory.remove(weapon)
        
        return True
    
    def add_item_to_inventory(self, item):
        """アイテムをインベントリに追加"""
        self.inventory.append(item)
    
    def remove_item_from_inventory(self, item):
        """インベントリからアイテムを削除"""
        if item in self.inventory:
            self.inventory.remove(item)
            return True
        return False
    
    def get_available_support_conversations(self, unit_name=None):
        """閲覧可能な支援会話のリストを取得"""
        available = self.support_system.get_available_conversations()
        
        # 特定ユニットに絞り込み
        if unit_name:
            available = [(char1, char2, level) for char1, char2, level in available
                         if char1 == unit_name or char2 == unit_name]
        
        return available
    
    def view_support_conversation(self, char1, char2, level=None):
        """支援会話を表示"""
        conversation = self.support_system.get_conversation(char1, char2, level)
        if conversation:
            # 会話を既読にする
            self.support_system.mark_conversation_viewed(char1, char2, level)
            return conversation
        return None
    
    def save_game_data(self):
        """ゲームデータのセーブ処理"""
        # 支援データの保存
        self.support_system.save_support_data()
        
        # その他のデータ保存（未実装）
    
    def get_unit_stats_with_equipment(self, unit):
        """装備品の効果を含めたユニットの能力値を取得"""
        stats = {
            "strength": unit.strength,
            "magic": unit.magic,
            "skill": unit.skill,
            "speed": unit.speed,
            "luck": unit.luck,
            "defense": unit.defense,
            "resistance": unit.resistance
        }
        
        # 装備武器の効果を適用
        if unit.equipped_weapon and isinstance(unit.equipped_weapon, LegendaryWeapon):
            for effect in unit.equipped_weapon.effects:
                if effect.effect_type == "stat_boost":
                    for stat, value in effect.effect_value.get("stats", {}).items():
                        if stat in stats:
                            stats[stat] += value
        
        return stats
    
    def add_unit_to_party(self, unit):
        """新しいユニットをパーティーに追加"""
        # ユニットをマップに追加（実際のゲーム進行では適切な位置調整が必要）
        self.game_map.units.append(unit)
        
        # 支援関係の初期化（既存ユニットとの支援関係を設定）
        for existing_unit in self.game_map.units:
            if existing_unit != unit and existing_unit.team == unit.team:
                self.support_system.register_support_pair(unit.name, existing_unit.name)

    def remove_unit_from_party(self, unit):
        """ユニットをパーティーから削除"""
        if unit in self.game_map.units:
            self.game_map.units.remove(unit)
            
            # マップタイルからの削除
            if hasattr(unit, 'x') and hasattr(unit, 'y'):
                tile = self.game_map.tiles[unit.y][unit.x]
                if tile.unit == unit:
                    tile.unit = None

    def get_dead_units(self):
        """戦死したユニットのリストを取得"""
        # 実際のゲームでは戦死ユニットの管理方法に応じて実装
        return []  # 仮の実装

    def revive_unit(self, unit):
        """ユニットを復活させる"""
        # 戦死状態をリセット
        unit.current_hp = 1
        unit.death_status = None
        
        # パーティーに再追加
        self.add_unit_to_party(unit)

    def get_shop_weapons(self):
        """販売中の武器リストを取得"""
        # 実際のゲームでは街や進行状況に応じた武器リストを返す
        from weapon import Weapon
        from constants import WeaponType
        
        # 仮の武器リスト
        weapons = [
            Weapon("鉄の剣", WeaponType.SWORD, 5, 90, 0, 5, 1, 1, 45),
            Weapon("鋼の剣", WeaponType.SWORD, 8, 85, 0, 8, 1, 1, 35),
            Weapon("鉄の槍", WeaponType.LANCE, 6, 80, 0, 7, 1, 1, 45),
            Weapon("鋼の槍", WeaponType.LANCE, 9, 75, 0, 9, 1, 1, 35),
            Weapon("鉄の斧", WeaponType.AXE, 8, 70, 0, 10, 1, 1, 45),
            Weapon("鋼の斧", WeaponType.AXE, 11, 65, 0, 12, 1, 1, 35),
            Weapon("鉄の弓", WeaponType.BOW, 6, 85, 0, 5, 2, 2, 45),
            Weapon("鋼の弓", WeaponType.BOW, 9, 80, 0, 7, 2, 2, 35),
            Weapon("ファイアー", WeaponType.MAGIC, 5, 90, 0, 4, 1, 2, 40),
            Weapon("サンダー", WeaponType.MAGIC, 8, 80, 5, 6, 1, 2, 35)
        ]
        
        # 価格情報の追加（実際のWeaponクラスに価格属性がない場合）
        for weapon in weapons:
            weapon.price = weapon.might * 200 + 500
        
        return weapons

    def prepare_save_data(self):
        """セーブ用のゲームデータを準備"""
        # セーブに必要なデータを収集
        save_data = {
            "save_time": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "play_time": 0,  # プレイ時間（実際のゲームでは計測）
            "gold": self.player_gold,
            "party": [],  # ユニットデータ
            "inventory": [],  # アイテムデータ
            "current_scenario": "",  # 現在のシナリオ
            "completed_maps": [],  # クリア済みマップ
            "progress": {}  # その他の進行状況
        }
        
        # ユニットデータの保存
        for unit in self.game_map.units:
            if unit.team == 0:  # プレイヤーユニットのみ
                unit_data = {
                    "name": unit.name,
                    "class": unit.unit_class,
                    "level": unit.level,
                    "exp": unit.exp,
                    "hp": unit.max_hp,
                    "current_hp": unit.current_hp,
                    "strength": unit.strength,
                    "magic": unit.magic,
                    "skill": unit.skill,
                    "speed": unit.speed,
                    "luck": unit.luck,
                    "defense": unit.defense,
                    "resistance": unit.resistance,
                    "movement": unit.movement,
                    "skills": [skill.name for skill in unit.skills],
                    "weapons": []  # 武器データ
                }
                
                # 武器データの保存
                for weapon in unit.weapons:
                    weapon_data = {
                        "name": weapon.name,
                        "type": weapon.weapon_type.name,
                        "durability": weapon.durability
                    }
                    
                    # レジェンダリー武器の場合は追加データ
                    if hasattr(weapon, 'rarity'):
                        weapon_data["legendary"] = True
                        weapon_data["rarity"] = weapon.rarity.name
                    
                    unit_data["weapons"].append(weapon_data)
                
                save_data["party"].append(unit_data)
        
        # インベントリデータの保存
        for item in self.inventory:
            item_data = {
                "name": item.name,
                "type": "weapon" if hasattr(item, "weapon_type") else "item"
            }
            
            if item_data["type"] == "weapon":
                item_data["weapon_type"] = item.weapon_type.name
                item_data["durability"] = item.durability
                
                # レジェンダリー武器の場合は追加データ
                if hasattr(item, 'rarity'):
                    item_data["legendary"] = True
                    item_data["rarity"] = item.rarity.name
            
            save_data["inventory"].append(item_data)
        
        # 支援関係データの保存
        self.support_system.save_support_data()
        
        return save_data

    def load_game_data(self, save_data):
        """セーブデータをロード"""
        # 基本情報の復元
        self.player_gold = save_data.get("gold", 0)
        
        # ユニットの復元
        # インベントリの復元
        # 進行状況の復元
        # （実際のゲームではより複雑な処理が必要）
        
        # 支援データの復元
        self.support_system.load_support_data()

================
File: game_state_manager.py
================
# game_state_manager.py
from enum import Enum

class GameState(Enum):
    TITLE = 0
    TOWN = 1
    SCENARIO_SELECT = 2
    LEVEL_SYNC = 3
    PRE_MAP_DIALOGUE = 4
    MAP = 5
    POST_MAP_DIALOGUE = 6
    LEVEL_UP_PROCESSING = 7
    SAVE = 8
    
class GameStateManager:
    def __init__(self):
        self.current_state = GameState.TITLE
        self.previous_state = None
        self.game_data = {}  # ゲーム進行に関するデータ
        self.town_data = {}  # 街の情報
        self.scenario_data = {}  # シナリオデータ
        self.current_scenario = None
        self.current_map = None
        self.item_storage = []  # 輸送隊のアイテムリスト
        
    def change_state(self, new_state):
        self.previous_state = self.current_state
        self.current_state = new_state
        
    def load_game_data(self, save_file):
        # セーブデータのロード処理
        pass
        
    def save_game_data(self, save_file):
        # セーブ処理
        pass
        
    def initialize_new_game(self):
        # 新規ゲーム開始時の初期化
        pass

    def rescue_unit(self, rescuer, target):
        """ユニットの救出処理"""
        if not rescuer.can_rescue(target):
            return False
        
        # 救出処理
        rescuer.rescue(target)
        
        # マップ上から被救出ユニットを隠す
        self.game_map.hide_unit(target)
        
        return True
    
    def drop_unit(self, rescuer, x, y):
        """救出したユニットを下ろす処理"""
        if not rescuer.rescuing:
            return False
        
        target = rescuer.rescuing
        
        # 敵ユニットを下ろす場合（捕獲後）
        if target.team != rescuer.team:
            # インベントリからアイテムを取得（必要に応じて）
            # 敵ユニットをマップから消去
            rescuer.rescuing = None
            target.rescued_by = None
            # ステータス修正を元に戻す
            rescuer.remove_rescue_penalty()
            return True
        
        # 味方ユニットを下ろす場合
        return rescuer.drop(x, y, self.game_map)
    
    def capture_unit_in_battle(self, attacker, defender):
        """戦闘による捕獲処理"""
        # 戦闘後に敵のHPが0になった場合
        if defender.current_hp <= 0 and attacker.can_capture(defender):
            # 捕獲処理
            defender.current_hp = 1  # 捕獲したユニットのHPを1に回復
            attacker.rescuing = defender
            defender.rescued_by = attacker
            
            # マップ上から被捕獲ユニットを隠す
            self.game_map.hide_unit(defender)
            
            # ステータス修正を適用
            attacker.apply_rescue_penalty()
            
            return True
        
        return False
    
    def capture_unit_without_battle(self, captor, target):
        """戦闘なしでの捕獲（投降）処理"""
        if not captor.can_capture_without_battle(target):
            return False
        
        # 捕獲処理
        captor.rescuing = target
        target.rescued_by = captor
        
        # マップ上から被捕獲ユニットを隠す
        self.game_map.hide_unit(target)
        
        # ステータス修正を適用
        captor.apply_rescue_penalty()
        
        return True
    
    def exchange_items(self, unit1, unit2):
        """ユニット間のアイテム交換処理"""
        # アイテム選択UIの表示などは別途実装
        pass
    
    def send_items_to_storage(self, unit):
        """ユニットのアイテムを全て輸送隊に送る"""
        if not unit.weapons:
            return False
        
        # 装備中の武器を除く全てのアイテムを輸送隊に送る
        equipped_weapon = unit.equipped_weapon
        
        for weapon in unit.weapons[:]:  # コピーをループ
            if weapon != equipped_weapon:
                self.item_storage.append(weapon)
                unit.weapons.remove(weapon)
        
        return True
    
    def access_item_storage(self, unit):
        """輸送隊のアイテムアクセス処理"""
        if not unit.has_item_box_access:
            return False
        
        # アイテムボックスUIの表示などは別途実装
        return True

================
File: growth_system.py
================
# growth_system.py
import random
from typing import Dict, List, Tuple, Optional
import pandas as pd
import os

class GrowthSystem:
    """
    成長システム: 固定値成長とレベルアップの管理を担当するクラス
    """
    def __init__(self, data_path="data/"):
        self.data_path = data_path
        
        # Excelファイルからデータを読み込む
        self.class_data = self._load_class_data()
        self.character_data = self._load_character_data()
        self.level_data = self._load_level_data()
        self.map_data = self._load_map_data()
        
        # 最大レベル
        self.max_level = 20
    
    def _load_class_data(self) -> pd.DataFrame:
        """職業データをExcelから読み込む"""
        file_path = os.path.join(self.data_path, "class_data.xlsx")
        try:
            return pd.read_excel(file_path)
        except Exception as e:
            print(f"職業データの読み込みエラー: {e}")
            # 空のデータフレームを返す
            return pd.DataFrame(columns=[
                "class_id", "class_name", "base_hp", "base_strength", "base_magic", 
                "base_skill", "base_speed", "base_luck", "base_defense", "base_resistance",
                "growth_hp", "growth_strength", "growth_magic", "growth_skill", 
                "growth_speed", "growth_luck", "growth_defense", "growth_resistance",
                "max_hp", "max_strength", "max_magic", "max_skill", 
                "max_speed", "max_luck", "max_defense", "max_resistance"
            ])
    
    def _load_character_data(self) -> pd.DataFrame:
        """キャラクターデータをExcelから読み込む"""
        file_path = os.path.join(self.data_path, "character_data.xlsx")
        try:
            return pd.read_excel(file_path)
        except Exception as e:
            print(f"キャラクターデータの読み込みエラー: {e}")
            # 空のデータフレームを返す
            return pd.DataFrame(columns=[
                "character_id", "character_name", "mod_hp", "mod_strength", "mod_magic", 
                "mod_skill", "mod_speed", "mod_luck", "mod_defense", "mod_resistance"
            ])
    
    def _load_level_data(self) -> pd.DataFrame:
        """レベルデータをExcelから読み込む"""
        file_path = os.path.join(self.data_path, "level_data.xlsx")
        try:
            return pd.read_excel(file_path)
        except Exception as e:
            print(f"レベルデータの読み込みエラー: {e}")
            # 空のデータフレームを返す
            return pd.DataFrame({
                "level": list(range(1, 21)),
                "exp_required": [0, 100, 210, 330, 460, 600, 750, 910, 1080, 1260,
                                1450, 1650, 1860, 2080, 2310, 2550, 2800, 3060, 3330, 3610]
            })
    
    def _load_map_data(self) -> pd.DataFrame:
        """マップデータをExcelから読み込む"""
        file_path = os.path.join(self.data_path, "map_data.xlsx")
        try:
            return pd.read_excel(file_path)
        except Exception as e:
            print(f"マップデータの読み込みエラー: {e}")
            # 空のデータフレームを返す
            return pd.DataFrame(columns=[
                "map_id", "map_name", "recommended_level", "level_cap", "difficulty_modifier"
            ])
    
    def reload_data(self):
        """データを再読み込みする"""
        self.class_data = self._load_class_data()
        self.character_data = self._load_character_data()
        self.level_data = self._load_level_data()
        self.map_data = self._load_map_data()
    
    def get_fixed_growth_values(self, unit) -> Dict[str, int]:
        """
        ユニットの固定成長値を取得する
        
        Args:
            unit: 対象ユニット
            
        Returns:
            Dict[str, int]: 各ステータスの固定成長値
        """
        # 職業の成長データを取得
        class_row = self.class_data[self.class_data['class_name'] == unit.unit_class]
        if class_row.empty:
            # 職業データが見つからない場合はデフォルト値
            return {
                "hp": 1, "strength": 0, "magic": 0, "skill": 0, 
                "speed": 0, "luck": 0, "defense": 0, "resistance": 0
            }
        
        # キャラクター固有の修正値を取得
        char_row = self.character_data[self.character_data['character_name'] == unit.name]
        char_mods = {
            "hp": 0, "strength": 0, "magic": 0, "skill": 0, 
            "speed": 0, "luck": 0, "defense": 0, "resistance": 0
        }
        
        if not char_row.empty:
            char_mods["hp"] = char_row.iloc[0].get('mod_hp', 0)
            char_mods["strength"] = char_row.iloc[0].get('mod_strength', 0)
            char_mods["magic"] = char_row.iloc[0].get('mod_magic', 0)
            char_mods["skill"] = char_row.iloc[0].get('mod_skill', 0)
            char_mods["speed"] = char_row.iloc[0].get('mod_speed', 0)
            char_mods["luck"] = char_row.iloc[0].get('mod_luck', 0)
            char_mods["defense"] = char_row.iloc[0].get('mod_defense', 0)
            char_mods["resistance"] = char_row.iloc[0].get('mod_resistance', 0)
        
        # 職業の基本成長値と修正値を合わせて返す
        growth_values = {
            "hp": max(0, class_row.iloc[0].get('growth_hp', 1) + char_mods["hp"]),
            "strength": max(0, class_row.iloc[0].get('growth_strength', 0) + char_mods["strength"]),
            "magic": max(0, class_row.iloc[0].get('growth_magic', 0) + char_mods["magic"]),
            "skill": max(0, class_row.iloc[0].get('growth_skill', 0) + char_mods["skill"]),
            "speed": max(0, class_row.iloc[0].get('growth_speed', 0) + char_mods["speed"]),
            "luck": max(0, class_row.iloc[0].get('growth_luck', 0) + char_mods["luck"]),
            "defense": max(0, class_row.iloc[0].get('growth_defense', 0) + char_mods["defense"]),
            "resistance": max(0, class_row.iloc[0].get('growth_resistance', 0) + char_mods["resistance"])
        }
        
        return growth_values
    
    def get_stat_caps(self, unit) -> Dict[str, int]:
        """ユニットのステータス上限を取得する"""
        class_row = self.class_data[self.class_data['class_name'] == unit.unit_class]
        if class_row.empty:
            # デフォルト値
            return {
                "hp": 60, "strength": 25, "magic": 25, "skill": 25, 
                "speed": 25, "luck": 30, "defense": 25, "resistance": 25
            }
        
        return {
            "hp": class_row.iloc[0].get('max_hp', 60),
            "strength": class_row.iloc[0].get('max_strength', 25),
            "magic": class_row.iloc[0].get('max_magic', 25),
            "skill": class_row.iloc[0].get('max_skill', 25),
            "speed": class_row.iloc[0].get('max_speed', 25),
            "luck": class_row.iloc[0].get('max_luck', 30),
            "defense": class_row.iloc[0].get('max_defense', 25),
            "resistance": class_row.iloc[0].get('max_resistance', 25)
        }
    
    def get_exp_threshold(self, level: int) -> int:
        """特定のレベルに必要な経験値を取得する"""
        if level <= 1 or level > self.max_level:
            return 0
            
        level_row = self.level_data[self.level_data['level'] == level]
        if level_row.empty:
            # デフォルト値
            default_thresholds = [0, 100, 210, 330, 460, 600, 750, 910, 1080, 1260,
                                 1450, 1650, 1860, 2080, 2310, 2550, 2800, 3060, 3330, 3610]
            return default_thresholds[level-1] if level <= len(default_thresholds) else 9999
        
        return level_row.iloc[0].get('exp_required', 100)
    
    def level_up(self, unit) -> Dict[str, int]:
        """
        固定成長値に基づいたレベルアップ処理
        
        Returns:
            Dict[str, int]: 上昇したステータスとその値
        """
        # 現在のレベルを確認
        if unit.level >= self.max_level:
            return {}  # 最大レベルに達している場合は上昇なし
        
        # 固定成長値を取得
        growth_values = self.get_fixed_growth_values(unit)
        stat_caps = self.get_stat_caps(unit)
        
        # 実際に適用する成長値（ステータス上限を考慮）
        applied_growth = {}
        
        # HPの上昇
        if unit.max_hp + growth_values["hp"] <= stat_caps["hp"]:
            applied_growth["hp"] = growth_values["hp"]
        else:
            applied_growth["hp"] = max(0, stat_caps["hp"] - unit.max_hp)
        
        # 力の上昇
        if unit.strength + growth_values["strength"] <= stat_caps["strength"]:
            applied_growth["strength"] = growth_values["strength"]
        else:
            applied_growth["strength"] = max(0, stat_caps["strength"] - unit.strength)
        
        # 魔力の上昇
        if unit.magic + growth_values["magic"] <= stat_caps["magic"]:
            applied_growth["magic"] = growth_values["magic"]
        else:
            applied_growth["magic"] = max(0, stat_caps["magic"] - unit.magic)
        
        # 技の上昇
        if unit.skill + growth_values["skill"] <= stat_caps["skill"]:
            applied_growth["skill"] = growth_values["skill"]
        else:
            applied_growth["skill"] = max(0, stat_caps["skill"] - unit.skill)
        
        # 速さの上昇
        if unit.speed + growth_values["speed"] <= stat_caps["speed"]:
            applied_growth["speed"] = growth_values["speed"]
        else:
            applied_growth["speed"] = max(0, stat_caps["speed"] - unit.speed)
        
        # 幸運の上昇
        if unit.luck + growth_values["luck"] <= stat_caps["luck"]:
            applied_growth["luck"] = growth_values["luck"]
        else:
            applied_growth["luck"] = max(0, stat_caps["luck"] - unit.luck)
        
        # 守備の上昇
        if unit.defense + growth_values["defense"] <= stat_caps["defense"]:
            applied_growth["defense"] = growth_values["defense"]
        else:
            applied_growth["defense"] = max(0, stat_caps["defense"] - unit.defense)
        
        # 魔防の上昇
        if unit.resistance + growth_values["resistance"] <= stat_caps["resistance"]:
            applied_growth["resistance"] = growth_values["resistance"]
        else:
            applied_growth["resistance"] = max(0, stat_caps["resistance"] - unit.resistance)
        
        # 実際にステータスを上昇させる
        unit.max_hp += applied_growth["hp"]
        unit.current_hp += applied_growth["hp"]  # 現在HPも上昇
        unit.strength += applied_growth["strength"]
        unit.magic += applied_growth["magic"]
        unit.skill += applied_growth["skill"]
        unit.speed += applied_growth["speed"]
        unit.luck += applied_growth["luck"]
        unit.defense += applied_growth["defense"]
        unit.resistance += applied_growth["resistance"]
        
        # レベルアップ
        unit.level += 1
        unit.exp = 0
        
        return applied_growth
    
    def award_exp(self, unit, exp_amount: int) -> Tuple[bool, Optional[Dict[str, int]]]:
        """
        ユニットに経験値を付与し、レベルアップした場合はステータス上昇を返す
        
        Args:
            unit: 経験値を獲得するユニット
            exp_amount: 獲得する経験値量
        
        Returns:
            Tuple[bool, Optional[Dict[str, int]]]: レベルアップしたかどうか、ステータス上昇量
        """
        if unit.level >= self.max_level:
            return False, None  # 最大レベルに達している場合は経験値獲得なし
        
        unit.exp += exp_amount
        
        # 次のレベルに必要な経験値を取得
        next_level_threshold = self.get_exp_threshold(unit.level + 1)
        
        if unit.exp >= next_level_threshold:
            # レベルアップ
            stat_gains = self.level_up(unit)
            return True, stat_gains
        
        return False, None
    
    def calculate_combat_exp(self, attacker, defender, combat_results) -> int:
        """戦闘結果から獲得経験値を計算する"""
        # 基本経験値
        base_exp = 10
        
        # レベル差による補正
        level_diff = defender.level - attacker.level
        level_modifier = max(0, min(20, level_diff * 2 + 10))
        
        # ダメージ量による補正
        damage_dealt = sum(r.get("damage", 0) for r in combat_results["attacker_results"])
        damage_percentage = min(100, int(damage_dealt / defender.max_hp * 100))
        damage_modifier = damage_percentage // 10
        
        # 敵を倒した場合のボーナス
        kill_bonus = 20 if defender.is_dead() else 0
        
        total_exp = base_exp + level_modifier + damage_modifier + kill_bonus
        
        # 最低保証と上限
        total_exp = max(1, min(100, total_exp))
        
        return total_exp
    
    def calculate_expected_stats(self, unit_class: str, character_name: str, target_level: int) -> Dict[str, int]:
        """
        特定のレベルで期待されるステータスを固定成長値に基づいて計算する
        
        Args:
            unit_class: ユニットのクラス
            character_name: キャラクター名
            target_level: 目標レベル
        
        Returns:
            Dict[str, int]: 期待されるステータス
        """
        # 職業の基本データを取得
        class_row = self.class_data[self.class_data['class_name'] == unit_class]
        if class_row.empty:
            # デフォルト値
            base_stats = {
                "hp": 18, "strength": 5, "magic": 1, "skill": 5, 
                "speed": 5, "luck": 5, "defense": 5, "resistance": 5
            }
        else:
            base_stats = {
                "hp": class_row.iloc[0].get('base_hp', 18),
                "strength": class_row.iloc[0].get('base_strength', 5),
                "magic": class_row.iloc[0].get('base_magic', 1),
                "skill": class_row.iloc[0].get('base_skill', 5),
                "speed": class_row.iloc[0].get('base_speed', 5),
                "luck": class_row.iloc[0].get('base_luck', 5),
                "defense": class_row.iloc[0].get('base_defense', 5),
                "resistance": class_row.iloc[0].get('base_resistance', 5)
            }
        
        # 固定成長値を取得
        temp_unit = type('obj', (object,), {
            'unit_class': unit_class,
            'name': character_name
        })
        growth_values = self.get_fixed_growth_values(temp_unit)
        
        # レベル1からtarget_levelまでの成長を計算
        expected_stats = base_stats.copy()
        for _ in range(1, target_level):
            for stat in expected_stats:
                expected_stats[stat] += growth_values[stat]
        
        # ステータス上限を適用
        stat_caps = self.get_stat_caps(temp_unit)
        for stat in expected_stats:
            expected_stats[stat] = min(expected_stats[stat], stat_caps[stat])
        
        return expected_stats

================
File: item_storage_ui.py
================
# item_storage_ui.py
import pygame
from ui_system import Panel, Label, Button, ScrollPanel

class ItemStorageWindow(Panel):
    def __init__(self, x, y, width, height, game_manager, unit=None, on_close=None):
        super().__init__(x, y, width, height)
        self.game_manager = game_manager
        self.unit = unit
        self.on_close = on_close
        
        # タイトル
        title_label = Label(width // 2, 20, "輸送隊", None, 30, (255, 255, 200), None, "center")
        self.add_child(title_label)
        
        # 閉じるボタン
        close_btn = Button(width - 80, 20, 60, 30, "閉じる", None, 20,
                          (100, 60, 60), (255, 255, 255), (150, 80, 80),
                          (0, 0, 0), 1, self.close_storage)
        self.add_child(close_btn)
        
        # 左側：ユニットのアイテム
        unit_item_label = Label(width // 4, 50, "ユニットのアイテム", None, 24, (255, 255, 255), None, "center")
        self.add_child(unit_item_label)
        
        unit_items_panel = ScrollPanel(10, 80, width // 2 - 20, height - 120,
                                      height, (40, 40, 50), (0, 0, 0), 1, 220)
        self.add_child(unit_items_panel)
        self.unit_items_panel = unit_items_panel
        
        # 右側：輸送隊のアイテム
        storage_label = Label(width * 3 // 4, 50, "輸送隊のアイテム", None, 24, (255, 255, 255), None, "center")
        self.add_child(storage_label)
        
        storage_items_panel = ScrollPanel(width // 2 + 10, 80, width // 2 - 20, height - 120,
                                        height, (40, 40, 50), (0, 0, 0), 1, 220)
        self.add_child(storage_items_panel)
        self.storage_items_panel = storage_items_panel
        
        # 転送ボタン
        transfer_to_storage_btn = Button(width // 2 - 15, height // 2 - 40, 30, 30, "→", None, 20,
                                        (60, 60, 100), (255, 255, 255), (80, 80, 150),
                                        (0, 0, 0), 1, self.transfer_to_storage)
        self.add_child(transfer_to_storage_btn)
        
        transfer_to_unit_btn = Button(width // 2 - 15, height // 2 + 10, 30, 30, "←", None, 20,
                                     (60, 60, 100), (255, 255, 255), (80, 80, 150),
                                     (0, 0, 0), 1, self.transfer_to_unit)
        self.add_child(transfer_to_unit_btn)
        
        # 選択状態
        self.selected_unit_item = None
        self.selected_storage_item = None
        
        # アイテムリストの更新
        self.update_item_lists()
    
    def update_item_lists(self):
        """アイテムリストを更新"""
        self.update_unit_items()
        self.update_storage_items()
    
    def update_unit_items(self):
        """ユニットのアイテムリストを更新"""
        self.unit_items_panel.clear_children()
        
        if not self.unit:
            self.unit_items_panel.add_child(Label(
                self.unit_items_panel.width // 2, 30,
                "ユニットが選択されていません",
                None, 18, (200, 200, 200), None, "center"
            ))
            return
        
        if not self.unit.weapons:
            self.unit_items_panel.add_child(Label(
                self.unit_items_panel.width // 2, 30,
                "アイテムがありません",
                None, 18, (200, 200, 200), None, "center"
            ))
            return
        
        for i, item in enumerate(self.unit.weapons):
            item_panel = Panel(10, i * 60 + 10, self.unit_items_panel.width - 20, 50, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # アイテム名
            equipped_text = " (装備中)" if item == self.unit.equipped_weapon else ""
            item_panel.add_child(Label(10, 10, f"{item.name}{equipped_text}", None, 18, (255, 255, 255)))
            
            # アイテム情報
            if hasattr(item, 'durability'):
                item_panel.add_child(Label(10, 30, f"耐久: {item.durability}/{item.max_durability}", None, 14, (200, 200, 200)))
            
            # クリックハンドラ
            item_index = i
            
            def make_handler(idx):
                return lambda: self.select_unit_item(self.unit.weapons[idx])
            
            item_panel.handle_event = make_handler(item_index)
            
            # 選択中のアイテムは色を変える
            if item == self.selected_unit_item:
                item_panel.color = (80, 80, 120)
            
            self.unit_items_panel.add_child(item_panel)
        
        self.unit_items_panel.update_content_height()
    
    def update_storage_items(self):
        """輸送隊のアイテムリストを更新"""
        self.storage_items_panel.clear_children()
        
        if not self.game_manager.item_storage:
            self.storage_items_panel.add_child(Label(
                self.storage_items_panel.width // 2, 30,
                "アイテムがありません",
                None, 18, (200, 200, 200), None, "center"
            ))
            return
        
        for i, item in enumerate(self.game_manager.item_storage):
            item_panel = Panel(10, i * 60 + 10, self.storage_items_panel.width - 20, 50, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # アイテム名
            item_panel.add_child(Label(10, 10, item.name, None, 18, (255, 255, 255)))
            
            # アイテム情報
            if hasattr(item, 'durability'):
                item_panel.add_child(Label(10, 30, f"耐久: {item.durability}/{item.max_durability}", None, 14, (200, 200, 200)))
            
            # クリックハンドラ
            item_index = i
            
            def make_handler(idx):
                return lambda: self.select_storage_item(self.game_manager.item_storage[idx])
            
            item_panel.handle_event = make_handler(item_index)
            
            # 選択中のアイテムは色を変える
            if item == self.selected_storage_item:
                item_panel.color = (80, 80, 120)
            
            self.storage_items_panel.add_child(item_panel)
        
        self.storage_items_panel.update_content_height()
    
    def select_unit_item(self, item):
        """ユニットのアイテムを選択"""
        self.selected_unit_item = item
        self.selected_storage_item = None
        self.update_item_lists()
    
    def select_storage_item(self, item):
        """輸送隊のアイテムを選択"""
        self.selected_storage_item = item
        self.selected_unit_item = None
        self.update_item_lists()
    
    def transfer_to_storage(self):
        """選択中のアイテムをユニットから輸送隊に移動"""
        if not self.selected_unit_item or not self.unit:
            return
        
        # 装備中のアイテムは移動できない
        if self.selected_unit_item == self.unit.equipped_weapon:
            # 警告メッセージ（未実装）
            return
        
        # アイテムの移動
        self.game_manager.item_storage.append(self.selected_unit_item)
        self.unit.weapons.remove(self.selected_unit_item)
        
        # 選択状態をリセット
        self.selected_unit_item = None
        
        # アイテムリストの更新
        self.update_item_lists()
    
    def transfer_to_unit(self):
        """選択中のアイテムを輸送隊からユニットに移動"""
        if not self.selected_storage_item or not self.unit:
            return
        
        # ユニットのアイテム所持数上限チェック（例：5個まで）
        if len(self.unit.weapons) >= 5:
            # 警告メッセージ（未実装）
            return
        
        # アイテムの移動
        self.unit.weapons.append(self.selected_storage_item)
        self.game_manager.item_storage.remove(self.selected_storage_item)
        
        # 選択状態をリセット
        self.selected_storage_item = None
        
        # アイテムリストの更新
        self.update_item_lists()
    
    def close_storage(self):
        """輸送隊画面を閉じる"""
        if self.on_close:
            self.on_close()

================
File: legendary_items_ui.py
================
# legendary_items_ui.py
import pygame
from typing import List, Dict, Tuple, Optional, Callable
from ui_system import Panel, Label, Button, ScrollPanel
from legendary_items import LegendaryWeapon, ItemRarity, ItemEffect
from constants import COLOR_BLACK, COLOR_WHITE, COLOR_BLUE, COLOR_RED, COLOR_GREEN, COLOR_YELLOW, COLOR_GRAY
from constants import SCREEN_WIDTH, SCREEN_HEIGHT

class WeaponInfoWindow(Panel):
    """武器の詳細情報を表示するウィンドウ"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 weapon: LegendaryWeapon,
                 on_close: Optional[Callable] = None,
                 on_equip: Optional[Callable] = None,
                 color=(30, 30, 50), border_color=COLOR_WHITE, border_width=2, alpha=230):
        super().__init__(x, y, width, height, color, border_color, border_width, alpha)
        
        self.weapon = weapon
        self.on_close = on_close
        self.on_equip = on_equip
        
        # フォント
        self.title_font = pygame.font.Font(None, 28)
        self.font = pygame.font.Font(None, 24)
        self.small_font = pygame.font.Font(None, 18)
        
        # スクロールパネル（背景ストーリー用）
        self.lore_panel = None
        
        self.setup_ui()
    
    def setup_ui(self):
        """UIのセットアップ"""
        if not self.weapon:
            return
        
        # レア度に応じた色
        rarity_colors = {
            ItemRarity.COMMON: COLOR_WHITE,
            ItemRarity.UNCOMMON: (100, 255, 100),  # 緑
            ItemRarity.RARE: (100, 100, 255),      # 青
            ItemRarity.EPIC: (200, 100, 255),      # 紫
            ItemRarity.LEGENDARY: (255, 200, 0)    # 金
        }
        
        # タイトル（武器名）
        title_color = rarity_colors.get(self.weapon.rarity, COLOR_WHITE)
        title_label = Label(self.width // 2, 15, self.weapon.name, self.title_font, 28, title_color, None, "center")
        self.add_child(title_label)
        
        # 閉じるボタン
        close_btn = Button(self.width - 30, 10, 20, 20, "×", None, 20,
                          (200, 50, 50), COLOR_WHITE, (255, 100, 100),
                          None, 0, self.close)
        self.add_child(close_btn)
        
        # レア度表示
        rarity_text = f"レア度: {self.weapon.rarity.name}"
        rarity_label = Label(self.width // 2, 45, rarity_text, self.font, 24, title_color, None, "center")
        self.add_child(rarity_label)
        
        # 武器の基本情報
        stat_x = 30
        stat_y = 80
        
        # 威力・命中・必殺
        self.add_child(Label(stat_x, stat_y, f"威力: {self.weapon.might}", self.font, 24, COLOR_WHITE))
        self.add_child(Label(stat_x, stat_y + 30, f"命中: {self.weapon.hit}", self.font, 24, COLOR_WHITE))
        self.add_child(Label(stat_x, stat_y + 60, f"必殺: {self.weapon.crit}", self.font, 24, COLOR_WHITE))
        
        # 重さ・射程・耐久度
        stat_x2 = self.width // 2 + 30
        self.add_child(Label(stat_x2, stat_y, f"重さ: {self.weapon.weight}", self.font, 24, COLOR_WHITE))
        self.add_child(Label(stat_x2, stat_y + 30, f"射程: {self.weapon.range_min}-{self.weapon.range_max}", self.font, 24, COLOR_WHITE))
        self.add_child(Label(stat_x2, stat_y + 60, f"耐久: {self.weapon.durability}/{self.weapon.max_durability}", self.font, 24, COLOR_WHITE))
        
        # 必要レベル
        req_level_text = f"必要レベル: {self.weapon.required_level}"
        req_level_label = Label(self.width // 2, stat_y + 95, req_level_text, self.font, 24, COLOR_WHITE, None, "center")
        self.add_child(req_level_label)
        
        # 専用キャラクター（ある場合）
        if self.weapon.unique_owner:
            unique_text = f"専用: {self.weapon.unique_owner}"
            unique_label = Label(self.width // 2, stat_y + 125, unique_text, self.font, 24, COLOR_YELLOW, None, "center")
            self.add_child(unique_label)
        
        # 効果一覧
        effect_y = stat_y + 155
        self.add_child(Label(self.width // 2, effect_y, "特殊効果", self.font, 24, COLOR_GREEN, None, "center"))
        
        effect_y += 30
        if self.weapon.effects:
            for i, effect in enumerate(self.weapon.effects):
                effect_text = f"• {effect.name}: {effect.description}"
                self.add_child(Label(stat_x, effect_y + i * 25, effect_text, self.small_font, 18, COLOR_WHITE))
        else:
            self.add_child(Label(self.width // 2, effect_y, "なし", self.small_font, 18, COLOR_WHITE, None, "center"))
        
        # スキル一覧
        skill_y = effect_y + (len(self.weapon.effects) if self.weapon.effects else 1) * 25 + 20
        self.add_child(Label(self.width // 2, skill_y, "付与スキル", self.font, 24, COLOR_BLUE, None, "center"))
        
        skill_y += 30
        skills = self.weapon.get_granted_skills()
        if skills:
            for i, skill in enumerate(skills):
                skill_text = f"• {skill.name}: {skill.description}"
                self.add_child(Label(stat_x, skill_y + i * 25, skill_text, self.small_font, 18, COLOR_WHITE))
        else:
            self.add_child(Label(self.width // 2, skill_y, "なし", self.small_font, 18, COLOR_WHITE, None, "center"))
        
        # 背景ストーリー
        lore_y = skill_y + (len(skills) if skills else 1) * 25 + 20
        self.add_child(Label(self.width // 2, lore_y, "背景ストーリー", self.font, 24, COLOR_YELLOW, None, "center"))
        
        # スクロール可能な背景ストーリーパネル
        lore_panel = ScrollPanel(stat_x, lore_y + 30, self.width - 60, 100, 200, (50, 50, 60), None, 0, 200)
        
        # 背景ストーリーテキスト
        if self.weapon.lore:
            lore_lines = self._wrap_text(self.weapon.lore, self.small_font, lore_panel.width - 20)
            for i, line in enumerate(lore_lines):
                lore_panel.add_child(Label(10, i * 20, line, self.small_font, 18, COLOR_WHITE))
        else:
            lore_panel.add_child(Label(lore_panel.width // 2, 10, "不明", self.small_font, 18, COLOR_WHITE, None, "center"))
        
        self.add_child(lore_panel)
        self.lore_panel = lore_panel
        
        # 装備ボタン（装備可能な場合）
        if self.on_equip:
            equip_btn = Button(self.width // 2 - 50, self.height - 40, 100, 30, "装備",
                              self.font, 20, (60, 100, 60), COLOR_WHITE, (80, 150, 80),
                              COLOR_BLACK, 1, self.equip_weapon)
            self.add_child(equip_btn)
    
    def _wrap_text(self, text: str, font, max_width: int) -> List[str]:
        """テキストを指定幅で折り返す"""
        words = text.split(' ')
        lines = []
        current_line = []
        current_width = 0
        
        for word in words:
            word_surface = font.render(word, True, COLOR_WHITE)
            word_width = word_surface.get_width()
            
            # スペースの幅を計算
            space_width = font.render(' ', True, COLOR_WHITE).get_width()
            
            # この単語を追加すると行の幅を超える場合
            if current_width + word_width + (space_width if current_line else 0) > max_width:
                # 現在の行を確定
                if current_line:
                    lines.append(' '.join(current_line))
                    current_line = [word]
                    current_width = word_width
                else:
                    # 1単語だけで幅を超える場合は分割が必要
                    lines.append(word)
                    current_line = []
                    current_width = 0
            else:
                # 単語を追加
                current_line.append(word)
                current_width += word_width + (space_width if current_line else 0)
        
        # 最後の行を追加
        if current_line:
            lines.append(' '.join(current_line))
        
        return lines
    
    def equip_weapon(self):
        """武器を装備する"""
        if self.on_equip:
            self.on_equip(self.weapon)
            self.close()
    
    def close(self):
        """ウィンドウを閉じる"""
        self.visible = False
        if self.on_close:
            self.on_close()


class ItemDropWindow(Panel):
    """アイテムドロップ表示用ウィンドウ"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 weapon: LegendaryWeapon,
                 on_take: Optional[Callable] = None,
                 on_discard: Optional[Callable] = None,
                 color=(40, 40, 60), border_color=COLOR_YELLOW, border_width=2, alpha=230):
        super().__init__(x, y, width, height, color, border_color, border_width, alpha)
        
        self.weapon = weapon
        self.on_take = on_take
        self.on_discard = on_discard
        
        # フォント
        self.title_font = pygame.font.Font(None, 28)
        self.font = pygame.font.Font(None, 24)
        self.small_font = pygame.font.Font(None, 18)
        
        # 武器画像（仮）
        self.weapon_image = None
        
        # アニメーション用変数
        self.animation_timer = 0
        self.animation_active = True  # アニメーション中
        
        self.setup_ui()
    
    def setup_ui(self):
        """UIのセットアップ"""
        if not self.weapon:
            return
        
        # レア度に応じた色
        rarity_colors = {
            ItemRarity.COMMON: COLOR_WHITE,
            ItemRarity.UNCOMMON: (100, 255, 100),  # 緑
            ItemRarity.RARE: (100, 100, 255),      # 青
            ItemRarity.EPIC: (200, 100, 255),      # 紫
            ItemRarity.LEGENDARY: (255, 200, 0)    # 金
        }
        rarity_color = rarity_colors.get(self.weapon.rarity, COLOR_WHITE)
        
        # タイトル
        title_label = Label(self.width // 2, 15, "新しい武器を発見！", self.title_font, 28, COLOR_YELLOW, None, "center")
        self.add_child(title_label)
        
        # 武器名
        weapon_name_label = Label(self.width // 2, 50, self.weapon.name, self.title_font, 28, rarity_color, None, "center")
        self.add_child(weapon_name_label)
        
        # レア度表示
        rarity_text = f"レア度: {self.weapon.rarity.name}"
        rarity_label = Label(self.width // 2, 80, rarity_text, self.font, 24, rarity_color, None, "center")
        self.add_child(rarity_label)
        
        # 武器の基本情報
        stat_x = 30
        stat_y = 120
        
        self.add_child(Label(stat_x, stat_y, f"威力: {self.weapon.might}", self.font, 24, COLOR_WHITE))
        self.add_child(Label(stat_x, stat_y + 30, f"命中: {self.weapon.hit}", self.font, 24, COLOR_WHITE))
        self.add_child(Label(stat_x, stat_y + 60, f"必殺: {self.weapon.crit}", self.font, 24, COLOR_WHITE))
        
        # 効果の簡易表示
        effect_y = stat_y + 100
        if self.weapon.effects:
            self.add_child(Label(stat_x, effect_y, "特殊効果:", self.font, 24, COLOR_GREEN))
            for i, effect in enumerate(self.weapon.effects[:2]):  # 最初の2つだけ表示
                self.add_child(Label(stat_x + 20, effect_y + 30 + i * 25, f"• {effect.description}", self.small_font, 18, COLOR_WHITE))
            
            # 効果が3つ以上ある場合
            if len(self.weapon.effects) > 2:
                self.add_child(Label(stat_x + 20, effect_y + 80, f"他 {len(self.weapon.effects) - 2} 個の効果...", self.small_font, 18, COLOR_WHITE))
        
        # ボタン
        button_y = self.height - 60
        
        # 取得ボタン
        take_btn = Button(self.width // 2 - 110, button_y, 100, 40, "取得",
                         self.font, 20, (60, 100, 60), COLOR_WHITE, (80, 150, 80),
                         COLOR_BLACK, 1, self.take_weapon)
        self.add_child(take_btn)
        
        # 詳細ボタン
        detail_btn = Button(self.width // 2, button_y, 100, 40, "詳細",
                           self.font, 20, (60, 60, 100), COLOR_WHITE, (80, 80, 150),
                           COLOR_BLACK, 1, self.show_details)
        self.add_child(detail_btn)
        
        # 捨てるボタン
        discard_btn = Button(self.width // 2 + 110, button_y, 100, 40, "捨てる",
                            self.font, 20, (100, 60, 60), COLOR_WHITE, (150, 80, 80),
                            COLOR_BLACK, 1, self.discard_weapon)
        self.add_child(discard_btn)
    
    def update(self):
        """アニメーション更新"""
        super().update()
        
        if self.animation_active:
            self.animation_timer += 1
            
            # アニメーション終了
            if self.animation_timer > 60:  # 約1秒
                self.animation_active = False
    
    def render(self, screen):
        """描画処理（オーバーライド）"""
        super().render(screen)
        
        # アニメーション演出
        if self.animation_active:
            # 輝く効果
            glow_alpha = int(128 + 127 * abs(pygame.math.sin(self.animation_timer * 0.1)))
            border_width = max(1, int(3 * abs(pygame.math.sin(self.animation_timer * 0.1))))
            
            # レア度に応じた色
            rarity_colors = {
                ItemRarity.UNCOMMON: (100, 255, 100, glow_alpha),  # 緑
                ItemRarity.RARE: (100, 100, 255, glow_alpha),      # 青
                ItemRarity.EPIC: (200, 100, 255, glow_alpha),      # 紫
                ItemRarity.LEGENDARY: (255, 200, 0, glow_alpha)    # 金
            }
            
            if self.weapon and self.weapon.rarity in rarity_colors:
                glow_color = rarity_colors[self.weapon.rarity]
                
                # 輝く枠
                glow_surface = pygame.Surface((self.width + 10, self.height + 10), pygame.SRCALPHA)
                pygame.draw.rect(glow_surface, glow_color, (0, 0, self.width + 10, self.height + 10), border_width)
                screen.blit(glow_surface, (self.x - 5, self.y - 5))
    
    def take_weapon(self):
        """武器を取得"""
        if self.on_take:
            self.on_take(self.weapon)
            self.visible = False
    
    def show_details(self):
        """武器の詳細を表示"""
        if self.weapon:
            # 詳細ウィンドウの表示を呼び出し側に委譲
            self.visible = False
            
            # UIManagerを通じて詳細ウィンドウを表示させるための呼び出し
            # （ここでは実際の実装は省略、呼び出し側で実装）
    
    def discard_weapon(self):
        """武器を捨てる"""
        if self.on_discard:
            self.on_discard(self.weapon)
            self.visible = False


class InventoryWindow(ScrollPanel):
    """インベントリ表示ウィンドウ"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 items: List,  # 武器やアイテムのリスト
                 unit=None,    # 選択中のユニット（装備変更用）
                 on_select: Optional[Callable] = None,
                 on_close: Optional[Callable] = None,
                 color=(40, 40, 60), border_color=COLOR_WHITE, border_width=2, alpha=230):
        super().__init__(x, y, width, height, height, color, border_color, border_width, alpha)
        
        self.items = items
        self.unit = unit
        self.on_select = on_select
        self.on_close = on_close
        
        # フォント
        self.title_font = pygame.font.Font(None, 28)
        self.font = pygame.font.Font(None, 24)
        self.small_font = pygame.font.Font(None, 18)
        
        # フィルター設定
        self.filter_rarity = None  # 特定のレア度のみ表示
        self.filter_type = None    # 特定の武器タイプのみ表示
        
        # 選択中のアイテム
        self.selected_item = None
        
        self.setup_ui()
    
    def setup_ui(self):
        """UIのセットアップ"""
        # タイトル
        title_text = "インベントリ" if not self.unit else f"{self.unit.name}の装備変更"
        title_label = Label(self.width // 2, 15, title_text, self.title_font, 28, COLOR_WHITE, None, "center")
        self.add_child(title_label)
        
        # 閉じるボタン
        close_btn = Button(self.width - 30, 10, 20, 20, "×", None, 20,
                          (200, 50, 50), COLOR_WHITE, (255, 100, 100),
                          None, 0, self.close)
        self.add_child(close_btn)
        
        # フィルターボタン
        filter_y = 45
        
        # レア度フィルター
        self.add_child(Label(20, filter_y, "レア度:", self.font, 24, COLOR_WHITE))
        
        filter_btns = [
            (None, "全て"),
            (ItemRarity.LEGENDARY, "伝説"),
            (ItemRarity.EPIC, "史詩"),
            (ItemRarity.RARE, "レア"),
            (ItemRarity.UNCOMMON, "珍しい")
        ]
        
        btn_x = 100
        for rarity, label in filter_btns:
            btn = Button(btn_x, filter_y, 60, 25, label, self.small_font, 16,
                        (60, 60, 80), COLOR_WHITE, (100, 100, 150),
                        COLOR_BLACK, 1, lambda r=rarity: self.set_filter_rarity(r))
            
            # 現在のフィルター状態を反映
            if self.filter_rarity == rarity:
                btn.color = (100, 100, 150)
            
            self.add_child(btn)
            btn_x += 70
        
        # アイテムリスト
        self.update_item_list()
    
    def update_item_list(self):
        """アイテムリストを更新"""
        # アイテム表示部分のみクリア
        self.children = [child for child in self.children if child.y < 80]
        
        # フィルタリング
        filtered_items = self.items
        if self.filter_rarity:
            filtered_items = [item for item in filtered_items 
                             if hasattr(item, 'rarity') and item.rarity == self.filter_rarity]
        
        if self.filter_type:
            filtered_items = [item for item in filtered_items 
                             if hasattr(item, 'weapon_type') and item.weapon_type == self.filter_type]
        
        # レア度でソート（降順）
        sorted_items = sorted(filtered_items, 
                             key=lambda item: getattr(item, 'rarity', ItemRarity.COMMON).value, 
                             reverse=True)
        
        # アイテムの表示
        y_offset = 80
        item_height = 70
        
        for i, item in enumerate(sorted_items):
            # アイテムパネル
            item_panel = Panel(10, y_offset, self.width - 30, item_height,
                              (60, 60, 70), COLOR_BLACK, 1, 255)
            
            # レア度に応じた色
            rarity_colors = {
                ItemRarity.COMMON: COLOR_WHITE,
                ItemRarity.UNCOMMON: (100, 255, 100),  # 緑
                ItemRarity.RARE: (100, 100, 255),      # 青
                ItemRarity.EPIC: (200, 100, 255),      # 紫
                ItemRarity.LEGENDARY: (255, 200, 0)    # 金
            }
            
            if hasattr(item, 'rarity'):
                item_color = rarity_colors.get(item.rarity, COLOR_WHITE)
            else:
                item_color = COLOR_WHITE
            
            # アイテム名
            item_name = getattr(item, 'name', '不明なアイテム')
            item_panel.add_child(Label(10, 5, item_name, self.font, 24, item_color))
            
            # アイテム情報
            if hasattr(item, 'weapon_type'):
                weapon_type_text = f"タイプ: {item.weapon_type.name}"
                item_panel.add_child(Label(10, 30, weapon_type_text, self.small_font, 18, COLOR_WHITE))
            
            if hasattr(item, 'might'):
                might_text = f"威力: {item.might}"
                item_panel.add_child(Label(150, 30, might_text, self.small_font, 18, COLOR_WHITE))
            
            # 効果の有無
            if hasattr(item, 'effects') and item.effects:
                effects_text = f"効果: {len(item.effects)}"
                item_panel.add_child(Label(250, 30, effects_text, self.small_font, 18, COLOR_GREEN))
            
            # 装備中の表示
            if self.unit and hasattr(self.unit, 'equipped_weapon') and self.unit.equipped_weapon == item:
                equipped_label = Label(self.width - 100, 10, "装備中", self.font, 20, COLOR_YELLOW)
                item_panel.add_child(equipped_label)
            
            # クリックハンドラ
            item_index = i  # クロージャのためにインデックスを保存
            
            def make_handler(idx):
                return lambda: self.select_item(sorted_items[idx])
            
            item_panel.handle_event = make_handler(item_index)
            
            self.add_child(item_panel)
            y_offset += item_height + 5
        
        # コンテンツ高さの更新
        self.update_content_height()
    
    def set_filter_rarity(self, rarity):
        """レア度フィルターを設定"""
        self.filter_rarity = rarity
        self.update_item_list()
    
    def set_filter_type(self, type_):
        """武器タイプフィルターを設定"""
        self.filter_type = type_
        self.update_item_list()
    
    def select_item(self, item):
        """アイテムを選択"""
        self.selected_item = item
        
        if self.on_select:
            self.on_select(item)
    
    def close(self):
        """ウィンドウを閉じる"""
        self.visible = False
        if self.on_close:
            self.on_close()


# UIManagerに追加するメソッド
def show_weapon_info(self, weapon, on_equip=None):
    """武器情報ウィンドウを表示"""
    weapon_info = WeaponInfoWindow(
        SCREEN_WIDTH // 2 - 250, SCREEN_HEIGHT // 2 - 200, 500, 400,
        weapon, None, on_equip
    )
    self.ui_elements.append(weapon_info)
    return weapon_info

def show_item_drop(self, weapon, on_take=None, on_discard=None):
    """アイテムドロップウィンドウを表示"""
    drop_window = ItemDropWindow(
        SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 150, 400, 300,
        weapon, on_take, on_discard
    )
    self.ui_elements.append(drop_window)
    return drop_window

def show_inventory(self, items, unit=None, on_select=None):
    """インベントリウィンドウを表示"""
    inventory = InventoryWindow(
        SCREEN_WIDTH // 2 - 300, SCREEN_HEIGHT // 2 - 200, 600, 400,
        items, unit, on_select
    )
    self.ui_elements.append(inventory)
    return inventory

================
File: legendary_items.py
================
# legendary_items.py
from typing import List, Dict, Tuple, Optional
import random
from enum import Enum
from skills import Skill, SkillTriggerType, SkillEffectType
from weapon import Weapon
from constants import WeaponType

class ItemRarity(Enum):
    """アイテムのレア度を定義するクラス"""
    COMMON = 0     # 通常
    UNCOMMON = 1   # やや珍しい
    RARE = 2       # レア
    EPIC = 3       # エピック
    LEGENDARY = 4  # レジェンダリー

class ItemEffect:
    """アイテムの特殊効果を定義するクラス"""
    def __init__(self, 
                 name: str,
                 description: str,
                 effect_type: str,          # "stat_boost", "skill_grant", "special"のいずれか
                 effect_value: dict):       # 効果の詳細を格納した辞書
        self.name = name
        self.description = description
        self.effect_type = effect_type
        self.effect_value = effect_value
    
    def to_dict(self) -> Dict:
        """辞書形式に変換（シリアライズ用）"""
        return {
            "name": self.name,
            "description": self.description,
            "effect_type": self.effect_type,
            "effect_value": self.effect_value
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'ItemEffect':
        """辞書からインスタンスを生成（デシリアライズ用）"""
        try:
            return cls(
                name=data["name"],
                description=data["description"],
                effect_type=data["effect_type"],
                effect_value=data["effect_value"]
            )
        except KeyError as e:
            print(f"アイテム効果データの読み込みエラー: {e}")
            return None

class LegendaryWeapon(Weapon):
    """スキルや特殊効果を持つ伝説の武器クラス"""
    def __init__(self, name, weapon_type, might, hit, crit, weight, range_min, range_max, durability,
                 rarity: ItemRarity = ItemRarity.LEGENDARY,
                 effects: List[ItemEffect] = None,
                 skills: List[Skill] = None,
                 lore: str = "",                 # 武器の背景ストーリー
                 required_level: int = 1,        # 必要レベル
                 unique_owner: Optional[str] = None):  # 専用キャラクター（いれば）
        super().__init__(name, weapon_type, might, hit, crit, weight, range_min, range_max, durability)
        
        self.rarity = rarity
        self.effects = effects or []
        self.skills = skills or []
        self.lore = lore
        self.required_level = required_level
        self.unique_owner = unique_owner
    
    def can_equip(self, unit) -> bool:
        """ユニットが装備可能かチェック"""
        # 専用キャラクターがいる場合はチェック
        if self.unique_owner and unit.name != self.unique_owner:
            return False
        
        # レベル要件
        if unit.level < self.required_level:
            return False
        
        # 通常の装備チェック
        return True
    
    def apply_effects(self, unit):
        """武器の効果をユニットに適用"""
        for effect in self.effects:
            if effect.effect_type == "stat_boost":
                # ステータス上昇効果
                stat_boosts = effect.effect_value.get("stats", {})
                for stat_name, value in stat_boosts.items():
                    # 一時的なステータス修正値を設定
                    unit.temp_stat_modifiers[stat_name] = unit.temp_stat_modifiers.get(stat_name, 0) + value
            
            # その他の効果は戦闘システム側で適用
    
    def remove_effects(self, unit):
        """武器の効果をユニットから除去"""
        # 一時的なステータス修正値をリセット
        unit.temp_stat_modifiers = {}
    
    def get_granted_skills(self) -> List[Skill]:
        """武器が付与するスキルのリストを取得"""
        granted_skills = []
        
        for effect in self.effects:
            if effect.effect_type == "skill_grant":
                skill_data = effect.effect_value.get("skill")
                if skill_data:
                    # スキルの生成
                    try:
                        skill = Skill(
                            name=skill_data.get("name", "不明なスキル"),
                            description=skill_data.get("description", ""),
                            trigger_type=SkillTriggerType[skill_data.get("trigger_type", "ALWAYS_ACTIVE")],
                            effect_type=SkillEffectType[skill_data.get("effect_type", "STAT_BOOST")],
                            trigger_value=skill_data.get("trigger_value"),
                            effect_value=skill_data.get("effect_value"),
                            duration=skill_data.get("duration", -1)
                        )
                        granted_skills.append(skill)
                    except (KeyError, ValueError) as e:
                        print(f"スキル生成エラー: {e}")
        
        # 武器に直接設定されたスキルも追加
        granted_skills.extend(self.skills)
        
        return granted_skills
    
    def to_dict(self) -> Dict:
        """辞書形式に変換（シリアライズ用）"""
        base_dict = {
            "name": self.name,
            "weapon_type": self.weapon_type.name,
            "might": self.might,
            "hit": self.hit,
            "crit": self.crit,
            "weight": self.weight,
            "range_min": self.range_min,
            "range_max": self.range_max,
            "durability": self.durability,
            "max_durability": self.max_durability,
            "rarity": self.rarity.name,
            "effects": [effect.to_dict() for effect in self.effects],
            "skills": [skill.__dict__ for skill in self.skills],  # 簡易的な変換
            "lore": self.lore,
            "required_level": self.required_level,
            "unique_owner": self.unique_owner
        }
        return base_dict
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'LegendaryWeapon':
        """辞書からインスタンスを生成（デシリアライズ用）"""
        try:
            # 効果のロード
            effects = []
            for effect_data in data.get("effects", []):
                effect = ItemEffect.from_dict(effect_data)
                if effect:
                    effects.append(effect)
            
            # スキルのロード（簡易的）
            skills = []
            for skill_data in data.get("skills", []):
                try:
                    skill = Skill(
                        name=skill_data.get("name", "不明なスキル"),
                        description=skill_data.get("description", ""),
                        trigger_type=SkillTriggerType[skill_data.get("trigger_type", "ALWAYS_ACTIVE")],
                        effect_type=SkillEffectType[skill_data.get("effect_type", "STAT_BOOST")],
                        trigger_value=skill_data.get("trigger_value"),
                        effect_value=skill_data.get("effect_value"),
                        duration=skill_data.get("duration", -1)
                    )
                    skills.append(skill)
                except (KeyError, ValueError) as e:
                    print(f"スキル読み込みエラー: {e}")
            
            return cls(
                name=data["name"],
                weapon_type=WeaponType[data["weapon_type"]],
                might=data["might"],
                hit=data["hit"],
                crit=data["crit"],
                weight=data["weight"],
                range_min=data["range_min"],
                range_max=data["range_max"],
                durability=data["durability"],
                rarity=ItemRarity[data.get("rarity", "LEGENDARY")],
                effects=effects,
                skills=skills,
                lore=data.get("lore", ""),
                required_level=data.get("required_level", 1),
                unique_owner=data.get("unique_owner")
            )
        except (KeyError, ValueError) as e:
            print(f"伝説の武器データの読み込みエラー: {e}")
            return None


class LegendaryItemGenerator:
    """伝説の武器・アイテムを生成するクラス"""
    def __init__(self):
        # 伝説アイテムのテンプレート
        self.weapon_templates = self._load_weapon_templates()
        
        # 効果のテンプレート
        self.effect_templates = self._load_effect_templates()
        
        # スキルのテンプレート
        self.skill_templates = self._load_skill_templates()
    
    def _load_weapon_templates(self) -> List[Dict]:
        """武器テンプレートをロード"""
        # 実際は外部ファイルから読み込む
        return [
            {
                "name_prefix": ["聖なる", "神々の", "英雄の", "太古の", "運命の"],
                "name_base": ["剣", "槍", "斧", "弓", "魔道書"],
                "name_suffix": ["", "・真実", "・勇気", "・救済", "・破滅"],
                "might_range": (8, 15),
                "hit_range": (80, 100),
                "crit_range": (5, 20),
                "weight_range": (3, 8),
                "effects_count": (1, 3),
                "skills_count": (0, 2)
            }
        ]
    
    def _load_effect_templates(self) -> List[Dict]:
        """効果テンプレートをロード"""
        # 実際は外部ファイルから読み込む
        return [
            # ステータス上昇効果
            {
                "name": "力の祝福",
                "description": "力+{value}",
                "effect_type": "stat_boost",
                "effect_value": {"stats": {"strength": (2, 5)}},
                "rarity_min": ItemRarity.UNCOMMON
            },
            {
                "name": "魔力の祝福",
                "description": "魔力+{value}",
                "effect_type": "stat_boost",
                "effect_value": {"stats": {"magic": (2, 5)}},
                "rarity_min": ItemRarity.UNCOMMON
            },
            {
                "name": "技の祝福",
                "description": "技+{value}",
                "effect_type": "stat_boost",
                "effect_value": {"stats": {"skill": (2, 5)}},
                "rarity_min": ItemRarity.UNCOMMON
            },
            {
                "name": "速さの祝福",
                "description": "速さ+{value}",
                "effect_type": "stat_boost",
                "effect_value": {"stats": {"speed": (2, 5)}},
                "rarity_min": ItemRarity.UNCOMMON
            },
            {
                "name": "幸運の祝福",
                "description": "幸運+{value}",
                "effect_type": "stat_boost",
                "effect_value": {"stats": {"luck": (2, 5)}},
                "rarity_min": ItemRarity.UNCOMMON
            },
            {
                "name": "守備の祝福",
                "description": "守備+{value}",
                "effect_type": "stat_boost",
                "effect_value": {"stats": {"defense": (2, 5)}},
                "rarity_min": ItemRarity.UNCOMMON
            },
            {
                "name": "魔防の祝福",
                "description": "魔防+{value}",
                "effect_type": "stat_boost",
                "effect_value": {"stats": {"resistance": (2, 5)}},
                "rarity_min": ItemRarity.UNCOMMON
            },
            # 複合効果（レア以上）
            {
                "name": "英雄の力",
                "description": "力+{str_value} 速さ+{spd_value}",
                "effect_type": "stat_boost",
                "effect_value": {"stats": {"strength": (3, 6), "speed": (2, 4)}},
                "rarity_min": ItemRarity.RARE
            },
            {
                "name": "魔道の極意",
                "description": "魔力+{mag_value} 魔防+{res_value}",
                "effect_type": "stat_boost",
                "effect_value": {"stats": {"magic": (3, 6), "resistance": (2, 4)}},
                "rarity_min": ItemRarity.RARE
            },
            {
                "name": "守護者の加護",
                "description": "守備+{def_value} 魔防+{res_value}",
                "effect_type": "stat_boost",
                "effect_value": {"stats": {"defense": (3, 6), "resistance": (3, 6)}},
                "rarity_min": ItemRarity.RARE
            },
            # 特殊効果（レジェンダリー）
            {
                "name": "目覚めし英雄",
                "description": "全ステータス+{value}",
                "effect_type": "stat_boost",
                "effect_value": {"stats": {
                    "strength": (2, 3), "magic": (2, 3), "skill": (2, 3),
                    "speed": (2, 3), "luck": (2, 3), "defense": (2, 3), "resistance": (2, 3)
                }},
                "rarity_min": ItemRarity.LEGENDARY
            }
        ]
    
    def _load_skill_templates(self) -> List[Dict]:
        """スキルテンプレートをロード"""
        # 実際は外部ファイルから読み込む
        return [
            # 攻撃系スキル
            {
                "name": "会心",
                "description": "確率でクリティカル率が大幅に上昇",
                "trigger_type": "PERCENTAGE",
                "effect_type": "CRITICAL_BOOST",
                "trigger_value": (20, 35),
                "effect_value": (30, 50),
                "rarity_min": ItemRarity.RARE
            },
            {
                "name": "見切り",
                "description": "命中率が上昇",
                "trigger_type": "ALWAYS_ACTIVE",
                "effect_type": "HIT_BOOST",
                "trigger_value": None,
                "effect_value": (15, 25),
                "rarity_min": ItemRarity.RARE
            },
            {
                "name": "切り裂き",
                "description": "確率で敵の守備または魔防の一部を無視",
                "trigger_type": "PERCENTAGE",
                "effect_type": "SPECIAL_ATTACK",
                "trigger_value": (25, 40),
                "effect_value": {"defense_pierce": (0.3, 0.5)},
                "rarity_min": ItemRarity.EPIC
            },
            # 防御系スキル
            {
                "name": "守護の心得",
                "description": "受けるダメージを減少",
                "trigger_type": "ALWAYS_ACTIVE",
                "effect_type": "DAMAGE_REDUCE",
                "trigger_value": None,
                "effect_value": (2, 4),
                "rarity_min": ItemRarity.UNCOMMON
            },
            {
                "name": "不死鳥",
                "description": "HPが低い時、確率で被ダメージを大幅に軽減",
                "trigger_type": "HP_THRESHOLD",
                "effect_type": "DAMAGE_REDUCE",
                "trigger_value": ("<", 30),
                "effect_value": (0.3, 0.5),
                "rarity_min": ItemRarity.EPIC
            },
            # 回復系スキル
            {
                "name": "生命吸収",
                "description": "攻撃時、与えたダメージの一部を回復",
                "trigger_type": "ON_DAMAGE",
                "effect_type": "HEAL",
                "trigger_value": None,
                "effect_value": {"heal_ratio": (0.15, 0.3)},
                "rarity_min": ItemRarity.RARE
            },
            # レジェンダリースキル
            {
                "name": "神速",
                "description": "速さが相手より大幅に高い場合、確実に追撃を行う",
                "trigger_type": "ALWAYS_ACTIVE",
                "effect_type": "FOLLOW_UP",
                "trigger_value": None,
                "effect_value": True,
                "rarity_min": ItemRarity.LEGENDARY
            },
            {
                "name": "天帝の一撃",
                "description": "確率で敵に3回連続攻撃を行う",
                "trigger_type": "PERCENTAGE",
                "effect_type": "SPECIAL_ATTACK",
                "trigger_value": (20, 30),
                "effect_value": {"attacks": 3, "damage_multiplier": 0.6},
                "rarity_min": ItemRarity.LEGENDARY
            }
        ]
    
    def generate_legendary_weapon(self, rarity: ItemRarity = None, weapon_type: WeaponType = None) -> LegendaryWeapon:
        """
        ランダムな伝説の武器を生成
        
        Args:
            rarity: 希望するレア度（Noneの場合はランダム）
            weapon_type: 希望する武器タイプ（Noneの場合はランダム）
            
        Returns:
            LegendaryWeapon: 生成された伝説の武器
        """
        # レア度の決定
        if rarity is None:
            rarity_weights = {
                ItemRarity.UNCOMMON: 50,
                ItemRarity.RARE: 30,
                ItemRarity.EPIC: 15,
                ItemRarity.LEGENDARY: 5
            }
            rarity_choice = random.choices(
                list(rarity_weights.keys()),
                weights=list(rarity_weights.values()),
                k=1
            )[0]
            rarity = rarity_choice
        
        # 武器タイプの決定
        if weapon_type is None:
            weapon_type = random.choice(list(WeaponType))
        
        # テンプレートをランダムに選択
        template = random.choice(self.weapon_templates)
        
        # 名前の生成
        name_prefix = random.choice(template["name_prefix"])
        
        # 武器タイプに応じた名前の基本部分
        type_name_map = {
            WeaponType.SWORD: "剣",
            WeaponType.LANCE: "槍",
            WeaponType.AXE: "斧",
            WeaponType.BOW: "弓",
            WeaponType.MAGIC: "魔道書"
        }
        name_base = type_name_map.get(weapon_type, random.choice(template["name_base"]))
        
        name_suffix = ""
        if random.random() < 0.7:  # 70%の確率でサフィックスを追加
            name_suffix = random.choice(template["name_suffix"])
        
        weapon_name = f"{name_prefix}{name_base}{name_suffix}"
        
        # 武器性能の決定（レア度が高いほど強い）
        rarity_bonus = rarity.value * 2
        
        might_range = template["might_range"]
        might = random.randint(might_range[0], might_range[1]) + rarity_bonus
        
        hit_range = template["hit_range"]
        hit = min(100, random.randint(hit_range[0], hit_range[1]) + rarity_bonus)
        
        crit_range = template["crit_range"]
        crit = random.randint(crit_range[0], crit_range[1]) + rarity_bonus
        
        weight_range = template["weight_range"]
        weight = max(1, random.randint(weight_range[0], weight_range[1]) - rarity.value)
        
        # 武器タイプに応じた射程
        if weapon_type == WeaponType.BOW:
            range_min, range_max = 2, 2
        elif weapon_type == WeaponType.MAGIC:
            range_min, range_max = 1, 2
        else:
            range_min, range_max = 1, 1
        
        # 耐久度（レア度が高いほど高い）
        durability = 30 + rarity.value * 10
        
        # 効果の数を決定
        effects_count_range = template["effects_count"]
        effects_count = random.randint(effects_count_range[0], min(effects_count_range[1], rarity.value + 1))
        
        # 効果の生成
        effects = []
        for _ in range(effects_count):
            effect = self._generate_random_effect(rarity)
            if effect:
                effects.append(effect)
        
        # スキルの数を決定
        skills_count_range = template["skills_count"]
        skills_count = random.randint(skills_count_range[0], min(skills_count_range[1], rarity.value))
        
        # スキルの生成
        skills = []
        for _ in range(skills_count):
            skill = self._generate_random_skill(rarity)
            if skill:
                skills.append(skill)
        
        # 必要レベル（レア度に応じて）
        required_level = max(1, rarity.value * 5)
        
        # 伝説の武器を作成
        legendary_weapon = LegendaryWeapon(
            name=weapon_name,
            weapon_type=weapon_type,
            might=might,
            hit=hit,
            crit=crit,
            weight=weight,
            range_min=range_min,
            range_max=range_max,
            durability=durability,
            rarity=rarity,
            effects=effects,
            skills=skills,
            lore=self._generate_lore(weapon_name, rarity),
            required_level=required_level
        )
        
        return legendary_weapon
    
    def _generate_random_effect(self, rarity: ItemRarity) -> Optional[ItemEffect]:
        """
        ランダムな効果を生成
        
        Args:
            rarity: アイテムのレア度
            
        Returns:
            ItemEffect: 生成された効果、または None
        """
        # レア度に合った効果テンプレートをフィルタリング
        valid_templates = [
            t for t in self.effect_templates 
            if ItemRarity[t.get("rarity_min", "COMMON").name].value <= rarity.value
        ]
        
        if not valid_templates:
            return None
        
        # ランダムにテンプレートを選択
        template = random.choice(valid_templates)
        
        name = template["name"]
        description = template["description"]
        effect_type = template["effect_type"]
        effect_value_template = template["effect_value"].copy()
        
        # 効果値の生成
        effect_value = {}
        if effect_type == "stat_boost":
            stats = {}
            for stat_name, value_range in effect_value_template.get("stats", {}).items():
                value = random.randint(value_range[0], value_range[1])
                stats[stat_name] = value
                
                # 説明文のプレースホルダーを置換
                if stat_name == "strength":
                    description = description.replace("{str_value}", str(value))
                elif stat_name == "magic":
                    description = description.replace("{mag_value}", str(value))
                elif stat_name == "skill":
                    description = description.replace("{skl_value}", str(value))
                elif stat_name == "speed":
                    description = description.replace("{spd_value}", str(value))
                elif stat_name == "luck":
                    description = description.replace("{lck_value}", str(value))
                elif stat_name == "defense":
                    description = description.replace("{def_value}", str(value))
                elif stat_name == "resistance":
                    description = description.replace("{res_value}", str(value))
                
                # 汎用的な置換
                description = description.replace("{value}", str(value))
            
            effect_value["stats"] = stats
        else:
            # その他の効果タイプの処理
            effect_value = effect_value_template
        
        return ItemEffect(name, description, effect_type, effect_value)
    
    def _generate_random_skill(self, rarity: ItemRarity) -> Optional[Skill]:
        """
        ランダムなスキルを生成
        
        Args:
            rarity: アイテムのレア度
            
        Returns:
            Skill: 生成されたスキル、または None
        """
        # レア度に合ったスキルテンプレートをフィルタリング
        valid_templates = [
            t for t in self.skill_templates 
            if ItemRarity[t.get("rarity_min", "COMMON").name].value <= rarity.value
        ]
        
        if not valid_templates:
            return None
        
        # ランダムにテンプレートを選択
        template = random.choice(valid_templates)
        
        name = template["name"]
        description = template["description"]
        
        # トリガータイプの処理
        trigger_type = SkillTriggerType[template["trigger_type"]]
        
        # トリガー値の処理
        trigger_value_template = template["trigger_value"]
        trigger_value = None
        
        if isinstance(trigger_value_template, tuple) and len(trigger_value_template) == 2:
            # 範囲から値を選択
            trigger_value = random.randint(trigger_value_template[0], trigger_value_template[1])
            # 説明文のプレースホルダーを置換
            description = description.replace("{trigger_value}", str(trigger_value))
        elif isinstance(trigger_value_template, tuple) and len(trigger_value_template) >= 3:
            # 特殊な形式（例: HP条件）
            trigger_value = trigger_value_template
        else:
            trigger_value = trigger_value_template
        
        # 効果タイプの処理
        effect_type = SkillEffectType[template["effect_type"]]
        
        # 効果値の処理
        effect_value_template = template["effect_value"]
        effect_value = None
        
        if isinstance(effect_value_template, tuple) and len(effect_value_template) == 2:
            # 範囲から値を選択
            effect_value = random.randint(effect_value_template[0], effect_value_template[1])
            # 説明文のプレースホルダーを置換
            description = description.replace("{value}", str(effect_value))
        elif isinstance(effect_value_template, dict):
            # 辞書形式の効果値
            effect_value = {}
            for key, value in effect_value_template.items():
                if isinstance(value, tuple) and len(value) == 2:
                    # 範囲から値を選択
                    if isinstance(value[0], float) or isinstance(value[1], float):
                        # 小数の場合
                        effect_value[key] = round(random.uniform(value[0], value[1]), 2)
                    else:
                        # 整数の場合
                        effect_value[key] = random.randint(value[0], value[1])
                    
                    # 説明文のプレースホルダーを置換
                    description = description.replace(f"{{{key}}}", str(effect_value[key]))
                else:
                    effect_value[key] = value
        else:
            effect_value = effect_value_template
        
        return Skill(
            name=name,
            description=description,
            trigger_type=trigger_type,
            effect_type=effect_type,
            trigger_value=trigger_value,
            effect_value=effect_value
        )
    
    def _generate_lore(self, weapon_name: str, rarity: ItemRarity) -> str:
        """
        武器の背景ストーリーを生成
        
        Args:
            weapon_name: 武器の名前
            rarity: レア度
            
        Returns:
            str: 生成された背景ストーリー
        """
        lore_templates = [
            "{name}は、古代の{era}時代に{maker}によって作られたと言われている。{feature}を持ち、{hero}がこの武器を使って{feat}したという伝説が残っている。",
            "伝説によれば、{name}は{god}の力を宿した武器であり、{feature}を持つという。この武器を持つものは{blessing}を授かると言われている。",
            "{war}の際、{hero}がこの{name}を手にして戦場を駆け抜けた。{feature}を持つこの武器は、{effect}すると言われている。",
            "{name}には{curse}という呪いがかけられているという噂がある。しかし、その代わりに{blessing}という祝福も与えるとされる。"
        ]
        
        eras = ["黄金", "神話", "闇", "混沌", "創世", "終末"]
        makers = ["偉大な鍛冶師", "古代の賢者", "失われた文明", "神々", "妖精"]
        features = ["鋭い刃", "魔力を宿した刃", "不思議な輝き", "予知能力", "敵の弱点を見抜く力"]
        heroes = ["伝説の英雄", "古の王", "神に選ばれし者", "闇を打ち破る者", "予言の勇者"]
        feats = ["暗黒の魔王を打ち倒", "世界を救", "平和をもたら", "真の力を解放", "運命を変え"]
        gods = ["創造神", "戦神", "知恵の神", "太陽神", "月の女神"]
        blessings = ["無限の力", "不思議な知恵", "敵を倒す力", "傷を癒す力", "運命を変える力"]
        wars = ["大戦", "聖戦", "魔神戦争", "神々の戦い", "百年戦争"]
        effects = ["敵の心を恐怖で満た", "使い手の力を何倍にも高め", "周囲の魔力を吸収", "使い手を不死身にさせる", "時間を操る力を与え"]
        curses = ["使い手の寿命を削る", "魂を少しずつ奪う", "制御不能な力", "狂気をもたらす", "敵の呪い"]
        
        # レア度が高いほど複雑な背景ストーリー
        template = random.choice(lore_templates)
        
        # プレースホルダーの置換
        lore = template.format(
            name=weapon_name,
            era=random.choice(eras),
            maker=random.choice(makers),
            feature=random.choice(features),
            hero=random.choice(heroes),
            feat=random.choice(feats),
            god=random.choice(gods),
            blessing=random.choice(blessings),
            war=random.choice(wars),
            effect=random.choice(effects),
            curse=random.choice(curses)
        )
        
        # レア度に応じて追加の文章
        if rarity.value >= ItemRarity.EPIC.value:
            additional_lore = [
                f"多くの戦いを経て、{weapon_name}は今も失われていない。",
                f"{weapon_name}は使い手に選ばれるという。相応しくない者が手にすれば災いをもたらすだろう。",
                f"真の力を解放するには、特別な儀式が必要だという噂もある。"
            ]
            lore += " " + random.choice(additional_lore)
        
        return lore

================
File: level_sync_manager.py
================
# level_sync_manager.py
from level_sync import LevelSyncSystem

class LevelSyncManager:
    def __init__(self, growth_system):
        self.level_sync_system = LevelSyncSystem(growth_system)
        self.pending_exp = {}  # レベルシンク中に獲得した経験値を保存
        
    def apply_level_sync(self, units, map_id):
        """マップ開始前のレベルシンク適用"""
        synced_units = self.level_sync_system.initialize_map(units, map_id)
        return synced_units
    
    def remove_level_sync(self, units):
        """マップ終了後のレベルシンク解除"""
        for unit in units:
            if unit.team == 0:  # プレイヤーユニットのみ
                self.level_sync_system.restore_original_stats(unit)
    
    def record_gained_exp(self, unit_name, exp):
        """レベルシンク中に獲得した経験値を記録"""
        if unit_name in self.pending_exp:
            self.pending_exp[unit_name] += exp
        else:
            self.pending_exp[unit_name] = exp
    
    def apply_pending_exp(self, units, growth_system):
        """記録された経験値を反映してレベルアップ処理"""
        level_up_results = {}
        
        for unit in units:
            if unit.name in self.pending_exp:
                exp_amount = self.pending_exp[unit.name]
                level_up, stat_gains = growth_system.award_exp(unit, exp_amount)
                
                if level_up:
                    level_up_results[unit.name] = stat_gains
                
                # 処理済みの経験値をクリア
                del self.pending_exp[unit.name]
        
        return level_up_results

================
File: level_sync.py
================
# level_sync.py
from typing import Dict, List, Optional, Tuple
import pandas as pd
import os
import copy

class LevelSyncSystem:
    """
    レベルシンクシステム: マップ難易度に合わせてユニットの強さを調整するシステム
    固定値成長に対応
    """
    def __init__(self, growth_system, data_path="data/"):
        self.growth_system = growth_system
        self.data_path = data_path
        
        # マップデータはgrowth_systemから取得
        self.map_data = growth_system.map_data
        
        # 難易度設定
        self.difficulty_settings = self._load_difficulty_settings()
        
        # デフォルト難易度
        self.current_difficulty = "normal"
        
        # 各ユニットの元のステータスを保存
        self.original_unit_stats = {}
    
    def _load_difficulty_settings(self) -> pd.DataFrame:
        """難易度設定をExcelから読み込む"""
        file_path = os.path.join(self.data_path, "difficulty_settings.xlsx")
        try:
            return pd.read_excel(file_path)
        except Exception as e:
            print(f"難易度設定の読み込みエラー: {e}")
            # デフォルトの難易度設定
            return pd.DataFrame({
                "difficulty_name": ["easy", "normal", "hard", "lunatic"],
                "stat_multiplier": [0.9, 1.0, 1.1, 1.2],
                "exp_multiplier": [1.2, 1.0, 0.8, 0.6],
                "enemy_level_bonus": [0, 0, 1, 2]
            })
    
    def reload_data(self):
        """データを再読み込みする"""
        self.difficulty_settings = self._load_difficulty_settings()
        self.map_data = self.growth_system.map_data
    
    def set_difficulty(self, difficulty: str):
        """難易度を設定する"""
        difficulty_names = self.difficulty_settings['difficulty_name'].tolist()
        if difficulty in difficulty_names:
            self.current_difficulty = difficulty
    
    def get_map_info(self, map_id: str) -> Tuple[int, int]:
        """マップの推奨レベルとレベル上限を取得する"""
        map_row = self.map_data[self.map_data['map_id'] == map_id]
        if map_row.empty:
            # デフォルト値
            return 1, 20
        
        return (
            map_row.iloc[0].get('recommended_level', 1),
            map_row.iloc[0].get('level_cap', 20)
        )
    
    def get_difficulty_multiplier(self) -> float:
        """現在の難易度に対応するステータス倍率を取得する"""
        difficulty_row = self.difficulty_settings[self.difficulty_settings['difficulty_name'] == self.current_difficulty]
        if difficulty_row.empty:
            return 1.0
        
        return difficulty_row.iloc[0].get('stat_multiplier', 1.0)
    
    def store_original_stats(self, unit):
        """ユニットの元のステータスを保存する"""
        if unit.name not in self.original_unit_stats:
            self.original_unit_stats[unit.name] = {
                "level": unit.level,
                "max_hp": unit.max_hp,
                "current_hp": unit.current_hp,
                "hp_ratio": unit.current_hp / unit.max_hp if unit.max_hp > 0 else 1.0,
                "strength": unit.strength,
                "magic": unit.magic,
                "skill": unit.skill,
                "speed": unit.speed,
                "luck": unit.luck,
                "defense": unit.defense,
                "resistance": unit.resistance,
                "exp": unit.exp
            }
    
    def restore_original_stats(self, unit):
        """ユニットの元のステータスを復元する"""
        if unit.name in self.original_unit_stats:
            stats = self.original_unit_stats[unit.name]
            unit.level = stats["level"]
            unit.max_hp = stats["max_hp"]
            
            # HPの回復率を維持するか、保存した現在HPを使用
            if "current_hp" in stats:
                unit.current_hp = stats["current_hp"]
            else:
                unit.current_hp = int(unit.max_hp * stats["hp_ratio"])
            
            unit.strength = stats["strength"]
            unit.magic = stats["magic"]
            unit.skill = stats["skill"]
            unit.speed = stats["speed"]
            unit.luck = stats["luck"]
            unit.defense = stats["defense"]
            unit.resistance = stats["resistance"]
            unit.exp = stats.get("exp", 0)
    
    def apply_level_sync(self, unit, map_id: str) -> bool:
        """
        レベルシンクを適用してユニットのステータスを調整する
        
        Args:
            unit: 調整対象のユニット
            map_id: マップID
        
        Returns:
            bool: レベルシンクが適用されたかどうか
        """
        # 元のステータスを保存
        self.store_original_stats(unit)
        
        # マップの推奨レベルとレベル上限を取得
        recommended_level, level_cap = self.get_map_info(map_id)
        
        # ユニットのレベルがマップのレベル上限より高い場合
        if unit.level > level_cap:
            # 難易度による調整係数
            difficulty_multiplier = self.get_difficulty_multiplier()
            
            # レベル上限に合わせた期待ステータスを計算（固定成長値による）
            expected_stats = self.growth_system.calculate_expected_stats(
                unit.unit_class, unit.name, level_cap
            )
            
            # ステータスを調整（難易度に応じて）
            adjusted_stats = {}
            for stat, value in expected_stats.items():
                adjusted_value = int(value * difficulty_multiplier)
                adjusted_stats[stat] = adjusted_value
            
            # ユニットのステータスを調整
            unit.level = level_cap
            unit.max_hp = adjusted_stats["hp"]
            unit.strength = adjusted_stats["strength"]
            unit.magic = adjusted_stats["magic"]
            unit.skill = adjusted_stats["skill"]
            unit.speed = adjusted_stats["speed"]
            unit.luck = adjusted_stats["luck"]
            unit.defense = adjusted_stats["defense"]
            unit.resistance = adjusted_stats["resistance"]
            
            # 現在HPの調整（HPの割合を維持）
            hp_ratio = self.original_unit_stats[unit.name]["hp_ratio"]
            unit.current_hp = max(1, int(unit.max_hp * hp_ratio))
            
            # 経験値をリセット（次のレベルアップに備えて）
            unit.exp = 0
            
            return True  # レベルシンク適用
        
        return False  # レベルシンク不要
    
    def initialize_map(self, units, map_id: str) -> List[Tuple[str, Dict]]:
        """
        マップ開始時、全ユニットにレベルシンクを適用する
        
        Args:
            units: マップ上のユニットリスト
            map_id: マップID
        
        Returns:
            List[Tuple[str, Dict]]: レベルシンクが適用されたユニットのリストと変更内容
        """
        synced_units = []
        
        for unit in units:
            # プレイヤーユニットのみ調整
            if unit.team == 0:  # 0: プレイヤーチーム
                # 元のステータスを記録
                original_stats = {
                    "level": unit.level,
                    "max_hp": unit.max_hp,
                    "strength": unit.strength,
                    "magic": unit.magic,
                    "skill": unit.skill,
                    "speed": unit.speed,
                    "luck": unit.luck,
                    "defense": unit.defense,
                    "resistance": unit.resistance
                }
                
                # レベルシンク適用
                if self.apply_level_sync(unit, map_id):
                    # 変更後のステータス
                    new_stats = {
                        "level": unit.level,
                        "max_hp": unit.max_hp,
                        "strength": unit.strength,
                        "magic": unit.magic,
                        "skill": unit.skill,
                        "speed": unit.speed,
                        "luck": unit.luck,
                        "defense": unit.defense,
                        "resistance": unit.resistance
                    }
                    
                    # 変更があった場合のみ記録
                    changes = {}
                    for stat, value in new_stats.items():
                        if value != original_stats[stat]:
                            changes[stat] = (original_stats[stat], value)
                    
                    if changes:
                        synced_units.append((unit.name, changes))
        
        return synced_units
    
    def finalize_map(self, units):
        """
        マップ終了時、全ユニットの元のステータスを復元する
        
        Args:
            units: マップ上のユニットリスト
        """
        for unit in units:
            if unit.team == 0:  # プレイヤーチーム
                self.restore_original_stats(unit)

================
File: level_up_window.py
================
# level_up_window.py
import pygame
import random
from typing import Dict, List, Tuple
from ui_system import Panel, Label, Button
from constants import COLOR_BLACK, COLOR_WHITE, COLOR_BLUE, COLOR_GREEN, COLOR_YELLOW

class LevelUpWindow(Panel):
    """レベルアップウィンドウ"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 unit=None, stat_gains: Dict[str, int] = None,
                 on_close=None,
                 color: Tuple[int, int, int] = (40, 40, 40),
                 border_color: Tuple[int, int, int] = COLOR_YELLOW,
                 border_width: int = 2,
                 alpha: int = 230):
        super().__init__(x, y, width, height, color, border_color, border_width, alpha)
        
        self.unit = unit
        self.stat_gains = stat_gains or {}
        self.on_close = on_close
        
        # フォント
        self.title_font = pygame.font.Font(None, 32)
        self.font = pygame.font.Font(None, 24)
        self.small_font = pygame.font.Font(None, 20)
        
        # アニメーション用変数
        self.animation_active = True
        self.animation_timer = 0
        self.animation_speed = 5  # フレーム数
        self.current_stat_index = -1
        self.stats_to_show = []
        
        # 表示する順番でステータスを配置
        self.stat_order = [
            ("hp", "HP"),
            ("strength", "力"),
            ("magic", "魔力"),
            ("skill", "技"),
            ("speed", "速さ"),
            ("luck", "幸運"),
            ("defense", "守備"),
            ("resistance", "魔防")
        ]
        
        # アニメーションするステータスの順番を設定
        self.stats_to_show = []
        for stat_key, _ in self.stat_order:
            if stat_key in self.stat_gains and self.stat_gains[stat_key] > 0:
                self.stats_to_show.append(stat_key)
        
        self.setup_ui()
    
    def setup_ui(self):
        """UIのセットアップ"""
        if not self.unit:
            return
        
        # タイトル
        title_label = Label(self.width // 2, 20, "レベルアップ!", self.title_font, 32, COLOR_YELLOW, None, "center")
        self.add_child(title_label)
        
        # ユニット名と新しいレベル
        name_label = Label(self.width // 2, 55, f"{self.unit.name} Lv {self.unit.level}", self.font, 24, COLOR_WHITE, None, "center")
        self.add_child(name_label)
        
        # ステータス表示用のラベルを準備
        self.stat_labels = {}
        self.value_labels = {}
        self.gain_labels = {}
        
        y_offset = 90
        for i, (stat_key, stat_name) in enumerate(self.stat_order):
            # ステータス名
            stat_label = Label(30, y_offset + i * 30, stat_name, self.font, 24, COLOR_WHITE)
            self.add_child(stat_label)
            self.stat_labels[stat_key] = stat_label
            
            # 現在の値 (初期表示は全部？に)
            original_value = getattr(self.unit, stat_key) - self.stat_gains.get(stat_key, 0)
            value_label = Label(120, y_offset + i * 30, str(original_value), self.font, 24, COLOR_WHITE)
            self.add_child(value_label)
            self.value_labels[stat_key] = value_label
            
            # 上昇値（+X）（初期表示は空白）
            gain = self.stat_gains.get(stat_key, 0)
            gain_text = f"+{gain}" if gain > 0 else ""
            gain_color = COLOR_GREEN if gain > 0 else COLOR_WHITE
            gain_label = Label(170, y_offset + i * 30, gain_text, self.font, 24, gain_color)
            gain_label.visible = False  # アニメーション用に初期非表示
            self.add_child(gain_label)
            self.gain_labels[stat_key] = gain_label
        
        # 閉じるボタン（アニメーション終了後に表示）
        close_button = Button(self.width // 2 - 50, self.height - 45, 100, 30, "閉じる",
                             self.font, 24, (80, 80, 80), COLOR_WHITE, (150, 150, 150),
                             COLOR_BLACK, 1, self.close)
        close_button.visible = False
        self.add_child(close_button)
        self.close_button = close_button
    
    def update(self):
        """アニメーション更新"""
        super().update()
        
        if not self.animation_active:
            return
        
        self.animation_timer += 1
        
        # 次のステータスを表示するタイミング
        if self.animation_timer >= self.animation_speed:
            self.animation_timer = 0
            self.current_stat_index += 1
            
            # すべてのステータスを表示し終わったらアニメーション終了
            if self.current_stat_index >= len(self.stats_to_show):
                self.animation_active = False
                self.close_button.visible = True
                return
            
            # 現在のステータスを表示
            current_stat = self.stats_to_show[self.current_stat_index]
            self.gain_labels[current_stat].visible = True
            
            # SE再生など
            self._play_level_up_sound()
    
    def render(self, screen):
        """描画処理（オーバーライド）"""
        super().render(screen)
        
        # アニメーション用の追加演出
        if self.animation_active and self.current_stat_index >= 0 and self.current_stat_index < len(self.stats_to_show):
            current_stat = self.stats_to_show[self.current_stat_index]
            label = self.gain_labels[current_stat]
            
            # 点滅エフェクトなど
            if self.animation_timer % 2 == 0:
                pygame.draw.rect(screen, (255, 255, 150), 
                                (label.x - 5, label.y - 2, label.width + 10, label.height + 4), 2)
    
    def _play_level_up_sound(self):
        """レベルアップ用SE再生（未実装）"""
        # pygame.mixer.Sound("level_up.wav").play()
        pass
    
    def close(self):
        """ウィンドウを閉じる"""
        self.visible = False
        if self.on_close:
            self.on_close()

================
File: main.py
================
# main.py (修正版)
import pygame
import sys
from constants import SCREEN_WIDTH, SCREEN_HEIGHT
from game_state_manager import GameStateManager, GameState
from title_screen import TitleScreen
from town_screen import TownScreen
from scenario_select_screen import ScenarioSelectScreen
from game_manager import GameManager
from renderer import GameRenderer
from ui_system import UIManager
from level_sync_manager import LevelSyncManager
from save_system import SaveSystem
from dialogue_system import DialogueScreen

def main():
    pygame.init()
    
    # 日本語対応パッチ適用 - 最初に実行する
    from ui_encoding_fix import patch_all
    font_info = patch_all()
    print(f"Japanese font support initialized: {font_info}")
    
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption("ファイアーエムブレム風SRPG")
    clock = pygame.time.Clock()
    
    # ゲームステートマネージャーの初期化
    state_manager = GameStateManager()
    
    # ゲームマネージャーの初期化（マップ戦闘用）
    game_manager = None
    
    # レベルシンクマネージャーの初期化
    from growth_system import GrowthSystem
    growth_system = GrowthSystem()
    level_sync_manager = LevelSyncManager(growth_system)
    
    # セーブシステムの初期化
    save_system = SaveSystem()
    
    # 現在表示している画面のUIエレメント
    current_screen = None
    
    # タイトル画面の作成
    def show_title_screen():
        nonlocal current_screen
        title_screen = TitleScreen(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 
                                  on_new_game=start_new_game,
                                  on_continue=continue_game,
                                  on_options=show_options)
        current_screen = title_screen
    
    # 新規ゲームの開始
    def start_new_game():
        nonlocal game_manager, current_screen
        # ゲームの初期化
        state_manager.initialize_new_game()
        
        # 最初の街画面を表示
        show_town_screen()
    
    # ゲームのロード
    def continue_game():
        # セーブデータ選択画面を表示（未実装）
        pass
    
    # オプション画面の表示
    # main.py (修正版の続き)
    def show_options():
        # オプション画面の表示（未実装）
        pass
    
    # 街画面の表示
    def show_town_screen():
        nonlocal current_screen
        state_manager.change_state(GameState.TOWN)
        town_screen = TownScreen(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, state_manager, on_leave_town=show_scenario_select)
        current_screen = town_screen
    
    # シナリオ選択画面の表示
    def show_scenario_select():
        nonlocal current_screen
        state_manager.change_state(GameState.SCENARIO_SELECT)
        
        # シナリオデータの取得（実際のゲームではデータベースなどから）
        scenarios = [
            {
                "id": "scenario1",
                "name": "始まりの章 - 平和な村",
                "description": "冒険の始まり。平和だった村が魔物に襲われ...",
                "recommended_level": 1,
                "maps": ["map1", "map2", "map3"],
                "pre_dialogue": "dialogue1_pre",
                "post_dialogue": "dialogue1_post"
            },
            {
                "id": "scenario2",
                "name": "第2章 - 古代遺跡の謎",
                "description": "村の長老から古代遺跡についての話を聞き...",
                "recommended_level": 5,
                "maps": ["map4", "map5"],
                "pre_dialogue": "dialogue2_pre",
                "post_dialogue": "dialogue2_post"
            },
            {
                "id": "scenario3",
                "name": "第3章 - 王都の陰謀",
                "description": "遺跡で見つけた古文書を解読するため王都へ...",
                "recommended_level": 10,
                "maps": ["map6", "map7", "map8"],
                "pre_dialogue": "dialogue3_pre",
                "post_dialogue": "dialogue3_post"
            }
        ]
        
        scenario_select = ScenarioSelectScreen(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, scenarios, 
                                              on_select=start_scenario,
                                              on_back=show_town_screen)
        current_screen = scenario_select
    
    # シナリオの開始
    def start_scenario(scenario):
        nonlocal game_manager
        state_manager.current_scenario = scenario
        state_manager.current_map_index = 0
        
        # マップ前の会話があれば表示
        if "pre_dialogue" in scenario and scenario["pre_dialogue"]:
            show_pre_map_dialogue(scenario)
        else:
            apply_level_sync(scenario)
    
    # マップ前の会話表示
    def show_pre_map_dialogue(scenario):
        nonlocal current_screen
        state_manager.change_state(GameState.PRE_MAP_DIALOGUE)
        
        # 会話データの取得（実際のゲームではデータベースなどから）
        dialogue_id = scenario["pre_dialogue"]
        dialogue_data = get_dialogue_data(dialogue_id)
        
        dialogue_screen = DialogueScreen(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, dialogue_data, 
                                        on_complete=lambda: apply_level_sync(scenario))
        current_screen = dialogue_screen
    
    # レベルシンクの適用
    def apply_level_sync(scenario):
        nonlocal game_manager
        state_manager.change_state(GameState.LEVEL_SYNC)
        
        # パーティーのユニットにレベルシンクを適用
        units = state_manager.game_data.get("party", [])
        map_id = scenario["maps"][state_manager.current_map_index]
        synced_units = level_sync_manager.apply_level_sync(units, map_id)
        
        # レベルシンク情報の表示（任意）
        
        # マップの開始
        start_map(scenario, map_id)
    
    # マップの開始
    def start_map(scenario, map_id):
        nonlocal game_manager, current_screen
        state_manager.change_state(GameState.MAP)
        
        # マップの初期化
        from map import GameMap
        game_map = GameMap(10, 15)  # 仮のサイズ
        
        # マップのセットアップ（実際のゲームではマップデータに基づく）
        from setup import setup_game
        setup_game(game_map)
        
        # ゲームマネージャーの初期化
        game_manager = GameManager(game_map)
        
        # レンダラーの初期化
        renderer = GameRenderer(screen, game_manager)
        
        # UIマネージャーの初期化
        ui_manager = UIManager(screen, game_manager)
        
        # マップループ（独自のループが必要）
        map_running = True
        while map_running and state_manager.current_state == GameState.MAP:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                
                # UIマネージャーにイベントを渡す
                if ui_manager.handle_event(event):
                    continue
                
                # 戦闘中でない場合の入力処理
                if not game_manager.combat_animation_active:
                    if event.type == pygame.KEYDOWN:
                        # Escキーでマップを中断（オプション表示など）
                        if event.key == pygame.K_ESCAPE:
                            # マップ中断メニューの表示（未実装）
                            pass
                        
                        # ターン終了キー
                        elif event.key == pygame.K_e and game_manager.turn_player == 0:
                            game_manager.end_player_turn()
                            # 敵のターン実行
                            game_manager.execute_ai_turn()
            
            # ゲームの状態更新
            ui_manager.update()
            
            # マップクリア判定
            if check_map_clear():
                map_running = False
                finish_map(scenario)
                break
            
            # ゲームオーバー判定
            if check_game_over():
                map_running = False
                show_game_over()
                break
            
            # 描画処理
            renderer.render_map()
            renderer.render_units()
            ui_manager.render()
            
            pygame.display.flip()
            clock.tick(60)
    
    # マップクリア判定
    def check_map_clear():
        # マップクリア条件をチェック（実際のゲームではより複雑な判定）
        if game_manager:
            # 例：敵がすべて倒されたか判定
            enemies = [unit for unit in game_manager.game_map.units if unit.team == 1 and not unit.is_dead()]
            return len(enemies) == 0
        return False
    
    # ゲームオーバー判定
    def check_game_over():
        """ゲームオーバー判定"""
        # ゲームオーバー条件をチェック
        if game_manager:
            # 例：主人公が倒されたか判定
            # 以前のコード: hero = next((unit for unit in game_manager.game_map.units if unit.team == 0 and unit.is_hero), None)
            
            # 修正1: hasattr でis_hero属性があるか確認
            hero = next((unit for unit in game_manager.game_map.units 
                        if unit.team == 0 and hasattr(unit, 'is_hero') and unit.is_hero), None)
            
            # 修正2: 代替として、名前で主人公を特定
            if hero is None:
                hero = next((unit for unit in game_manager.game_map.units 
                            if unit.team == 0 and unit.name == "Marth"), None)  # または主人公の名前に変更
            
            return hero and hero.is_dead()
        return False
    
    # マップ終了時の処理
    def finish_map(scenario):
        # マップ後の会話があれば表示
        if "post_dialogue" in scenario and scenario["post_dialogue"]:
            show_post_map_dialogue(scenario)
        else:
            process_map_rewards()
    
    # マップ後の会話表示
    def show_post_map_dialogue(scenario):
        nonlocal current_screen
        state_manager.change_state(GameState.POST_MAP_DIALOGUE)
        
        # 会話データの取得
        dialogue_id = scenario["post_dialogue"]
        dialogue_data = get_dialogue_data(dialogue_id)
        
        dialogue_screen = DialogueScreen(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, dialogue_data, 
                                        on_complete=process_map_rewards)
        current_screen = dialogue_screen
    
    # マップクリア後の報酬処理
    def process_map_rewards():
        state_manager.change_state(GameState.LEVEL_UP_PROCESSING)
        
        # レベルシンクの解除
        units = state_manager.game_data.get("party", [])
        level_sync_manager.remove_level_sync(units)
        
        # 経験値の適用とレベルアップ処理
        level_up_results = level_sync_manager.apply_pending_exp(units, growth_system)
        
        # レベルアップ画面の表示（未実装）
        
        # 次のマップがあれば次へ、なければシナリオ終了
        move_to_next_map_or_finish()
    
    # 次のマップへ移動またはシナリオ終了
    def move_to_next_map_or_finish():
        scenario = state_manager.current_scenario
        state_manager.current_map_index += 1
        
        # まだマップが残っている場合
        if state_manager.current_map_index < len(scenario["maps"]):
            # 次のマップへ
            apply_level_sync(scenario)
        else:
            # シナリオ終了、セーブして街へ戻る
            show_save_screen()
    
    # セーブ画面の表示
    def show_save_screen():
        state_manager.change_state(GameState.SAVE)
        
        # セーブ画面の表示（未実装）
        
        # 仮の実装：すぐに街へ戻る
        show_town_screen()
    
    # ゲームオーバー画面の表示
    def show_game_over():
        # ゲームオーバー画面の表示（未実装）
        
        # 仮の実装：タイトルに戻る
        show_title_screen()
    
    # 会話データの取得
    def get_dialogue_data(dialogue_id):
        # 実際のゲームではデータベースやファイルから取得
        dialogue_data = {
            "dialogue1_pre": [
                {"speaker": "村長", "text": "最近、村の周辺で魔物の出現が増えている。調査してほしい。", "left_character": "村長", "right_character": "主人公"},
                {"speaker": "主人公", "text": "了解しました。私たちに任せてください。", "left_character": "村長", "right_character": "主人公"}
            ],
            "dialogue1_post": [
                {"speaker": "主人公", "text": "村周辺の魔物は退治しました。", "left_character": "村長", "right_character": "主人公"},
                {"speaker": "村長", "text": "ありがとう。しかし、これは何かの前触れかもしれない...", "left_character": "村長", "right_character": "主人公"}
            ]
        }
        
        return dialogue_data.get(dialogue_id, [])
    
    # 最初にタイトル画面を表示
    show_title_screen()
    
    # メインゲームループ
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            
            # 現在の画面にイベントを渡す
            if current_screen:
                current_screen.handle_event(event)
        
        # 画面の更新
        if current_screen:
            current_screen.update()
        
        # 画面の描画
        screen.fill((0, 0, 0))  # 背景をクリア
        if current_screen:
            current_screen.render(screen)
        
        pygame.display.flip()
        clock.tick(60)
    
    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()

================
File: map.py
================
# map.py
import random
from typing import List, Tuple, Optional
from constants import TerrainType, TERRAIN_EFFECTS

class MapTile:
    def __init__(self, terrain_type: TerrainType):
        self.terrain_type = terrain_type
        self.unit = None

class GameMap:
    def __init__(self, rows: int, cols: int):
        self.rows = rows
        self.cols = cols
        self.tiles = [[MapTile(TerrainType.PLAIN) for _ in range(cols)] for _ in range(rows)]
        self.units = []
    
    def generate_simple_map(self):
        # 簡単なマップを生成
        for row in range(self.rows):
            for col in range(self.cols):
                # 外周を壁にする
                if row == 0 or row == self.rows - 1 or col == 0 or col == self.cols - 1:
                    self.tiles[row][col].terrain_type = TerrainType.WALL
                # ランダムに森と山を配置
                elif random.random() < 0.1:
                    self.tiles[row][col].terrain_type = TerrainType.FOREST
                elif random.random() < 0.05:
                    self.tiles[row][col].terrain_type = TerrainType.MOUNTAIN
                elif random.random() < 0.02:
                    self.tiles[row][col].terrain_type = TerrainType.WATER

    def place_unit(self, unit, x: int, y: int) -> bool:
        if not self.is_valid_position(x, y) or self.tiles[y][x].unit is not None:
            return False
        
        unit.x = x
        unit.y = y
        self.tiles[y][x].unit = unit
        self.units.append(unit)
        return True

    def move_unit(self, unit, new_x: int, new_y: int) -> bool:
        if not self.is_valid_position(new_x, new_y) or self.tiles[new_y][new_x].unit is not None:
            return False
        
        # 現在の位置から単位を削除
        self.tiles[unit.y][unit.x].unit = None
        
        # 新しい位置に単位を配置
        unit.x = new_x
        unit.y = new_y
        self.tiles[new_y][new_x].unit = unit
        unit.has_moved = True
        return True

    def is_valid_position(self, x: int, y: int) -> bool:
        return 0 <= x < self.cols and 0 <= y < self.rows

    def get_move_cost(self, x: int, y: int) -> int:
        if not self.is_valid_position(x, y):
            return 999
        return TERRAIN_EFFECTS[self.tiles[y][x].terrain_type]["move_cost"]
    
    def get_terrain_dodge(self, x: int, y: int) -> int:
        if not self.is_valid_position(x, y):
            return 0
        return TERRAIN_EFFECTS[self.tiles[y][x].terrain_type]["dodge"]
    
    def get_terrain_defense(self, x: int, y: int) -> int:
        if not self.is_valid_position(x, y):
            return 0
        return TERRAIN_EFFECTS[self.tiles[y][x].terrain_type]["defense"]

    def get_unit_at(self, x: int, y: int) -> Optional:
        if not self.is_valid_position(x, y):
            return None
        return self.tiles[y][x].unit
    
    def calculate_movement_range(self, unit) -> List[Tuple[int, int]]:
        # ブレゼンハムのアルゴリズムを使用した移動範囲計算
        visited = {}
        queue = [(unit.x, unit.y, unit.movement)]
        
        while queue:
            x, y, remaining_move = queue.pop(0)
            
            # 既に訪れた位置で、より多くの移動ポイントを持っていた場合はスキップ
            if (x, y) in visited and visited[(x, y)] >= remaining_move:
                continue
                
            visited[(x, y)] = remaining_move
            
            # 移動ポイントが残っている場合、隣接するマスを探索
            if remaining_move > 0:
                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                    nx, ny = x + dx, y + dy
                    if self.is_valid_position(nx, ny):
                        # ユニットがいる場合はスキップ（自分自身の場合を除く）
                        if self.get_unit_at(nx, ny) and (nx != unit.x or ny != unit.y):
                            continue
                            
                        # 地形の移動コスト
                        move_cost = self.get_move_cost(nx, ny)
                        new_remaining = remaining_move - move_cost
                        
                        if new_remaining >= 0:
                            queue.append((nx, ny, new_remaining))
        
        # 自分自身の位置を除外
        if (unit.x, unit.y) in visited:
            del visited[(unit.x, unit.y)]
            
        return list(visited.keys())
    
    def calculate_attack_range(self, unit, position: Optional[Tuple[int, int]] = None) -> List[Tuple[int, int]]:
        if not unit.equipped_weapon:
            return []
            
        x, y = position if position else (unit.x, unit.y)
        min_range = unit.equipped_weapon.range_min
        max_range = unit.equipped_weapon.range_max
        attack_positions = []
        
        for r in range(min_range, max_range + 1):
            for dx in range(-r, r + 1):
                dy_abs = r - abs(dx)
                for dy in [-dy_abs, dy_abs]:
                    if dy_abs == 0 and dx == 0:
                        continue
                    nx, ny = x + dx, y + dy
                    if self.is_valid_position(nx, ny):
                        attack_positions.append((nx, ny))
        
        return attack_positions
        
    def get_enemies_in_range(self, unit, attack_positions: List[Tuple[int, int]]) -> List:
        enemies = []
        for x, y in attack_positions:
            target = self.get_unit_at(x, y)
            if target and target.team != unit.team:
                enemies.append((target, x, y))
        return enemies
    
    def hide_unit(self, unit):
        """ユニットをマップから隠す（救出時など）"""
        if unit and unit.x >= 0 and unit.y >= 0:
            # タイルからユニットを削除
            self.tiles[unit.y][unit.x].unit = None
    
    def show_unit(self, unit, x, y):
        """ユニットをマップに表示する（降ろす時など）"""
        if unit:
            # 既にマップ上にいる場合は古い位置から削除
            if unit.x >= 0 and unit.y >= 0:
                self.tiles[unit.y][unit.x].unit = None
            
            # 新しい位置に配置
            unit.x = x
            unit.y = y
            self.tiles[y][x].unit = unit

================
File: movement_system.py
================
# movement_system.py
from enum import Enum
import pandas as pd
import os
from constants import TerrainType

class MovementType(Enum):
    INFANTRY = 1      # 歩兵
    ARMORED = 2       # 重騎士
    MAGE = 3          # 魔法使い
    CAVALRY = 4       # 騎馬兵
    FLYING = 5        # 飛行兵
    NINJA = 6         # 忍者
    GHOST = 7         # 壁抜け
    MOUNTAIN = 8      # 山地適応
    AQUATIC = 9       # 水地適応
    FOREST = 10       # 森林適応
    DESERT = 11       # 砂地適応
    DAMAGE_FLOOR = 12 # ダメ床適応

class MovementSystem:
    """ユニットの移動タイプと地形効果を管理するクラス"""
    def __init__(self, data_path="data/"):
        self.data_path = data_path
        
        # 移動タイプデータの読み込み
        self.movement_data = self._load_movement_data()
        
        # カスタム移動コスト（特殊スキルや状態による一時的な修正用）
        self.custom_move_costs = {}
    
    def _load_movement_data(self) -> pd.DataFrame:
        """移動タイプデータをExcelから読み込む"""
        file_path = os.path.join(self.data_path, "movement_types.xlsx")
        try:
            df = pd.read_excel(file_path)
            # 読み込んだデータを加工して使いやすい形に変換
            movement_data = {}
            
            for _, row in df.iterrows():
                move_type_id = row.get('id')
                move_type_name = row.get('name', '')
                
                # 各地形タイプに対するコスト
                terrain_costs = {}
                for terrain in TerrainType:
                    cost_col = f'cost_{terrain.name.lower()}'
                    if cost_col in row:
                        terrain_costs[terrain] = row[cost_col]
                    else:
                        # デフォルトコスト
                        terrain_costs[terrain] = self._get_default_cost(move_type_id, terrain)
                
                # 移動タイプの特徴（地形ダメージ無効など）
                features = {}
                feature_cols = [col for col in row.index if col.startswith('feature_')]
                for col in feature_cols:
                    feature_name = col[8:]  # "feature_" を除去
                    features[feature_name] = bool(row[col])
                
                movement_data[MovementType(move_type_id)] = {
                    'name': move_type_name,
                    'terrain_costs': terrain_costs,
                    'features': features
                }
            
            return movement_data
            
        except Exception as e:
            print(f"移動タイプデータの読み込みエラー: {e}")
            # デフォルトの移動コストを返す
            return self._create_default_movement_data()
    
    def _create_default_movement_data(self) -> dict:
        """デフォルトの移動タイプデータを作成"""
        default_data = {}
        
        # 歩兵（標準）
        infantry_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 2,
            TerrainType.MOUNTAIN: 4,
            TerrainType.WATER: 999,
            TerrainType.WALL: 999,
        }
        default_data[MovementType.INFANTRY] = {
            'name': '歩兵',
            'terrain_costs': infantry_costs,
            'features': {}
        }
        
        # 重騎士
        armored_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 3,
            TerrainType.MOUNTAIN: 999,
            TerrainType.WATER: 999,
            TerrainType.WALL: 999,
        }
        default_data[MovementType.ARMORED] = {
            'name': '重騎士',
            'terrain_costs': armored_costs,
            'features': {'defense_bonus': True}
        }
        
        # 魔法使い
        mage_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 2,
            TerrainType.MOUNTAIN: 4,
            TerrainType.WATER: 999,
            TerrainType.WALL: 999,
        }
        default_data[MovementType.MAGE] = {
            'name': '魔法使い',
            'terrain_costs': mage_costs,
            'features': {}
        }
        
        # 騎馬兵
        cavalry_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 3,
            TerrainType.MOUNTAIN: 999,
            TerrainType.WATER: 999,
            TerrainType.WALL: 999,
        }
        default_data[MovementType.CAVALRY] = {
            'name': '騎馬兵',
            'terrain_costs': cavalry_costs,
            'features': {'move_bonus': True}
        }
        
        # 飛行兵
        flying_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 1,
            TerrainType.MOUNTAIN: 1,
            TerrainType.WATER: 1,
            TerrainType.WALL: 999,
        }
        default_data[MovementType.FLYING] = {
            'name': '飛行兵',
            'terrain_costs': flying_costs,
            'features': {'flying': True}
        }
        
        # 忍者
        ninja_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 1,
            TerrainType.MOUNTAIN: 2,
            TerrainType.WATER: 2,
            TerrainType.WALL: 999,
        }
        default_data[MovementType.NINJA] = {
            'name': '忍者',
            'terrain_costs': ninja_costs,
            'features': {'stealth': True}
        }
        
        # 壁抜け
        ghost_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 1,
            TerrainType.MOUNTAIN: 2,
            TerrainType.WATER: 2,
            TerrainType.WALL: 2,
        }
        default_data[MovementType.GHOST] = {
            'name': '壁抜け',
            'terrain_costs': ghost_costs,
            'features': {'pass_walls': True}
        }
        
        # 山地適応
        mountain_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 1,
            TerrainType.MOUNTAIN: 1,
            TerrainType.WATER: 999,
            TerrainType.WALL: 999,
        }
        default_data[MovementType.MOUNTAIN] = {
            'name': '山地適応',
            'terrain_costs': mountain_costs,
            'features': {'mountain_bonus': True}
        }
        
        # 水地適応
        aquatic_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 2,
            TerrainType.MOUNTAIN: 999,
            TerrainType.WATER: 1,
            TerrainType.WALL: 999,
        }
        default_data[MovementType.AQUATIC] = {
            'name': '水地適応',
            'terrain_costs': aquatic_costs,
            'features': {'water_bonus': True}
        }
        
        # 森林適応
        forest_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 1,
            TerrainType.MOUNTAIN: 3,
            TerrainType.WATER: 999,
            TerrainType.WALL: 999,
        }
        default_data[MovementType.FOREST] = {
            'name': '森林適応',
            'terrain_costs': forest_costs,
            'features': {'forest_bonus': True}
        }
        
        # 砂地適応
        desert_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 2,
            TerrainType.MOUNTAIN: 3,
            TerrainType.WATER: 999,
            TerrainType.WALL: 999,
        }
        default_data[MovementType.DESERT] = {
            'name': '砂地適応',
            'terrain_costs': desert_costs,
            'features': {'desert_bonus': True}
        }
        
        # ダメ床適応
        damage_floor_costs = {
            TerrainType.PLAIN: 1,
            TerrainType.FOREST: 2,
            TerrainType.MOUNTAIN: 4,
            TerrainType.WATER: 999,
            TerrainType.WALL: 999,
        }
        default_data[MovementType.DAMAGE_FLOOR] = {
            'name': 'ダメ床適応',
            'terrain_costs': damage_floor_costs,
            'features': {'damage_floor_immunity': True}
        }
        
        return default_data
    
    def _get_default_cost(self, move_type_id: int, terrain: TerrainType) -> int:
        """デフォルトの移動コストを取得"""
        # 移動タイプごとの基本コスト
        if move_type_id == MovementType.FLYING.value:
            return 1 if terrain != TerrainType.WALL else 999
        elif move_type_id == MovementType.GHOST.value:
            return 2 if terrain == TerrainType.WALL else 1
        elif move_type_id == MovementType.MOUNTAIN.value and terrain == TerrainType.MOUNTAIN:
            return 1
        elif move_type_id == MovementType.AQUATIC.value and terrain == TerrainType.WATER:
            return 1
        elif move_type_id == MovementType.FOREST.value and terrain == TerrainType.FOREST:
            return 1
        elif terrain == TerrainType.PLAIN:
            return 1
        elif terrain == TerrainType.FOREST:
            return 2
        elif terrain == TerrainType.MOUNTAIN:
            return 4 if move_type_id != MovementType.ARMORED.value else 999
        elif terrain == TerrainType.WATER:
            return 999
        elif terrain == TerrainType.WALL:
            return 999
        else:
            return 999
    
    def get_move_cost(self, unit, terrain: TerrainType) -> int:
        """ユニットの移動タイプと地形に基づいた移動コストを取得"""
        # ユニットからMovementTypeを取得
        move_type = unit.movement_type if hasattr(unit, 'movement_type') else MovementType.INFANTRY
        
        # カスタム移動コストがあればそれを優先
        unit_id = id(unit)
        if unit_id in self.custom_move_costs and terrain in self.custom_move_costs[unit_id]:
            return self.custom_move_costs[unit_id][terrain]
        
        # 移動タイプのデータを取得
        type_data = self.movement_data.get(move_type, self.movement_data.get(MovementType.INFANTRY))
        
        # 地形ごとの移動コストを取得
        terrain_costs = type_data.get('terrain_costs', {})
        
        # 特殊な移動特性を適用
        features = type_data.get('features', {})
        
        # 特殊状態の処理
        if terrain == TerrainType.WALL and features.get('pass_walls', False):
            return 2
        
        return terrain_costs.get(terrain, 999)
    
    def set_custom_move_cost(self, unit, terrain: TerrainType, cost: int):
        """ユニット個別の一時的な移動コスト修正を設定"""
        unit_id = id(unit)
        if unit_id not in self.custom_move_costs:
            self.custom_move_costs[unit_id] = {}
        self.custom_move_costs[unit_id][terrain] = cost
    
    def clear_custom_move_costs(self, unit=None):
        """カスタム移動コストをクリア"""
        if unit:
            unit_id = id(unit)
            if unit_id in self.custom_move_costs:
                del self.custom_move_costs[unit_id]
        else:
            self.custom_move_costs.clear()
    
    def get_terrain_features(self, unit, terrain: TerrainType) -> dict:
        """ユニットの移動タイプに基づいた地形の特殊効果を取得"""
        move_type = unit.movement_type if hasattr(unit, 'movement_type') else MovementType.INFANTRY
        type_data = self.movement_data.get(move_type, self.movement_data.get(MovementType.INFANTRY))
        features = type_data.get('features', {})
        
        result = {}
        
        # 地形ごとの特殊効果
        if terrain == TerrainType.FOREST and features.get('forest_bonus', False):
            result['dodge_bonus'] = 20
            result['defense_bonus'] = 2
        elif terrain == TerrainType.MOUNTAIN and features.get('mountain_bonus', False):
            result['dodge_bonus'] = 15
            result['defense_bonus'] = 3
        elif terrain == TerrainType.WATER and features.get('water_bonus', False):
            result['dodge_bonus'] = 10
            
        # その他の特殊効果
        if features.get('stealth', False):
            result['visibility_range'] = -1  # 視認距離の減少
        
        return result

================
File: renderer.py
================
# renderer.py
import pygame
from constants import GRID_SIZE, COLOR_BLACK, COLOR_WHITE, COLOR_BLUE, COLOR_RED
from constants import COLOR_GREEN, COLOR_YELLOW, TerrainType

class GameRenderer:
    def __init__(self, screen, game_manager):
        self.screen = screen
        self.game_manager = game_manager
        self.font = pygame.font.Font(None, 24)
        
        # テクスチャ用のダミーカラー
        self.terrain_colors = {
            TerrainType.PLAIN: (200, 200, 100),
            TerrainType.FOREST: (50, 150, 50),
            TerrainType.MOUNTAIN: (150, 100, 50),
            TerrainType.WATER: (50, 100, 200),
            TerrainType.WALL: (100, 100, 100),
        }
        
        self.team_colors = {
            0: COLOR_BLUE,  # プレイヤー
            1: COLOR_RED,   # 敵
        }
    
    def render(self):
        """従来の完全な描画（UI連携後は主に下位メソッドを使用）"""
        self.screen.fill(COLOR_BLACK)
        
        # マップの描画
        self.render_map()
        
        # 選択中のユニットの移動範囲
        self._render_movement_range()
        
        # 攻撃範囲
        self._render_attack_range()
        
        # ユニットの描画
        self.render_units()
        
        # 選択中のユニットのハイライト
        self._render_selected_unit()
        
        # UIの描画
        self._render_ui()
        
        # 戦闘アニメーション
        if self.game_manager.combat_animation_active:
            self._render_combat_animation()
    
    def render_map(self):
        """マップのみ描画（UIシステムと連携するために分離）"""
        self.screen.fill(COLOR_BLACK)
        
        game_map = self.game_manager.game_map
        
        for y in range(game_map.rows):
            for x in range(game_map.cols):
                terrain = game_map.tiles[y][x].terrain_type
                color = self.terrain_colors[terrain]
                
                rect = pygame.Rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE)
                pygame.draw.rect(self.screen, color, rect)
                pygame.draw.rect(self.screen, COLOR_BLACK, rect, 1)  # グリッド線
    
    def render_units(self):
        """ユニットのみ描画（UIシステムと連携するために分離）"""
        for unit in self.game_manager.game_map.units:
            if unit.is_dead():
                continue
                
            color = self.team_colors[unit.team]
            x, y = unit.x * GRID_SIZE, unit.y * GRID_SIZE
            
            # ユニットの描画（簡易的な円）
            pygame.draw.circle(self.screen, color, (x + GRID_SIZE // 2, y + GRID_SIZE // 2), GRID_SIZE // 2 - 2)
            
            # HPバー
            hp_ratio = unit.current_hp / unit.max_hp
            hp_color = COLOR_GREEN if hp_ratio > 0.5 else COLOR_YELLOW if hp_ratio > 0.25 else COLOR_RED
            hp_width = int(GRID_SIZE * hp_ratio)
            pygame.draw.rect(self.screen, hp_color, (x, y + GRID_SIZE - 5, hp_width, 5))
            
            # 既に行動済みのユニットは暗く表示
            if unit.has_moved:
                s = pygame.Surface((GRID_SIZE, GRID_SIZE), pygame.SRCALPHA)
                s.fill((0, 0, 0, 128))  # 半透明ブラック
                self.screen.blit(s, (x, y))
    
    def _render_movement_range(self):
        if self.game_manager.phase == "move_unit" and self.game_manager.move_targets:
            for x, y in self.game_manager.move_targets:
                rect = pygame.Rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE)
                s = pygame.Surface((GRID_SIZE, GRID_SIZE), pygame.SRCALPHA)
                s.fill((0, 0, 255, 128))  # 半透明ブルー
                self.screen.blit(s, (x * GRID_SIZE, y * GRID_SIZE))
    
    def _render_attack_range(self):
        if self.game_manager.phase == "select_attack_target" and self.game_manager.attack_targets:
            for x, y in self.game_manager.attack_targets:
                rect = pygame.Rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE)
                s = pygame.Surface((GRID_SIZE, GRID_SIZE), pygame.SRCALPHA)
                s.fill((255, 0, 0, 128))  # 半透明レッド
                self.screen.blit(s, (x * GRID_SIZE, y * GRID_SIZE))
    
    def _render_selected_unit(self):
        if self.game_manager.selected_unit:
            unit = self.game_manager.selected_unit
            x, y = unit.x * GRID_SIZE, unit.y * GRID_SIZE
            rect = pygame.Rect(x, y, GRID_SIZE, GRID_SIZE)
            pygame.draw.rect(self.screen, COLOR_YELLOW, rect, 2)
    
    def _render_ui(self):
        # 現在のターンとフェーズの表示
        turn_text = f"Turn: {self.game_manager.current_turn+1} - {'Player' if self.game_manager.turn_player == 0 else 'Enemy'}"
        turn_surface = self.font.render(turn_text, True, COLOR_WHITE)
        self.screen.blit(turn_surface, (10, self.screen.get_height() - 30))
        
        # 選択中のユニット情報
        if self.game_manager.selected_unit:
            unit = self.game_manager.selected_unit
            unit_text = f"{unit.name} - HP: {unit.current_hp}/{unit.max_hp}"
            unit_surface = self.font.render(unit_text, True, COLOR_WHITE)
            self.screen.blit(unit_surface, (self.screen.get_width() - 200, self.screen.get_height() - 30))
            
            # スキルリストの表示
            if unit.skills:
                y_offset = 60
                skill_title_surface = self.font.render("Skills:", True, COLOR_WHITE)
                self.screen.blit(skill_title_surface, (self.screen.get_width() - 200, y_offset))
                
                for i, skill in enumerate(unit.skills):
                    skill_surface = self.font.render(f"- {skill.name}", True, COLOR_WHITE)
                    self.screen.blit(skill_surface, (self.screen.get_width() - 190, y_offset + 20 + i * 20))
            
        # フェーズに応じたメッセージ
        phase_messages = {
            "select_unit": "Select a unit",
            "move_unit": "Move unit",
            "select_action": "Select action: [A]ttack or [W]ait",
            "select_attack_target": "Select attack target"
        }
        
        phase_text = phase_messages.get(self.game_manager.phase, "")
        phase_surface = self.font.render(phase_text, True, COLOR_WHITE)
        self.screen.blit(phase_surface, (10, 10))
    
    def _render_combat_animation(self):
        # 簡易的な戦闘アニメーション
        if self.game_manager.combat_results:
            # 戦闘結果を画面に表示
            results = self.game_manager.combat_results
            attacker = results["attacker_unit"]
            defender = results["defender_unit"]
            
            # 背景を暗くする
            s = pygame.Surface((self.screen.get_width(), self.screen.get_height()), pygame.SRCALPHA)
            s.fill((0, 0, 0, 192))
            self.screen.blit(s, (0, 0))
            
            # 戦闘アニメーションの表示
            pygame.draw.rect(self.screen, COLOR_WHITE, (50, 50, self.screen.get_width() - 100, self.screen.get_height() - 100))
            pygame.draw.rect(self.screen, COLOR_BLACK, (50, 50, self.screen.get_width() - 100, self.screen.get_height() - 100), 2)
            
            # 攻撃者と防御者の情報
            attacker_text = f"{attacker.name}: HP {attacker.current_hp}/{attacker.max_hp}"
            defender_text = f"{defender.name}: HP {defender.current_hp}/{defender.max_hp}"
            
            attacker_surface = self.font.render(attacker_text, True, COLOR_BLACK)
            defender_surface = self.font.render(defender_text, True, COLOR_BLACK)
            
            self.screen.blit(attacker_surface, (70, 70))
            self.screen.blit(defender_surface, (70, 100))
            
            # 戦闘結果の表示
            y_offset = 140
            for i, result in enumerate(results["attacker_results"]):
                hit_text = "HIT" if result["hit"] else "MISS"
                crit_text = "CRITICAL!" if result["critical"] else ""
                damage_text = f"{hit_text} {crit_text} Damage: {result['damage']}"
                
                result_surface = self.font.render(damage_text, True, COLOR_BLUE)
                self.screen.blit(result_surface, (70, y_offset + i * 30))
            
            y_offset += len(results["attacker_results"]) * 30 + 10
            for i, result in enumerate(results["defender_results"]):
                hit_text = "HIT" if result["hit"] else "MISS"
                crit_text = "CRITICAL!" if result["critical"] else ""
                damage_text = f"{hit_text} {crit_text} Damage: {result['damage']}"
                
                result_surface = self.font.render(damage_text, True, COLOR_RED)
                self.screen.blit(result_surface, (70, y_offset + i * 30))
            
            # スキル発動情報の表示
            if "activated_skills" in results:
                activated_skills = results["activated_skills"]
                
                attacker_skills = activated_skills.get("attacker", [])
                defender_skills = activated_skills.get("defender", [])
                
                # スキル発動テキスト表示
                y_offset += len(results["defender_results"]) * 30 + 10
                if attacker_skills:
                    attacker_name = attacker.name
                    skill_text = f"{attacker_name}'s skills: {', '.join(attacker_skills)}"
                    skill_surface = self.font.render(skill_text, True, COLOR_BLUE)
                    self.screen.blit(skill_surface, (70, y_offset))
                    y_offset += 25
                
                if defender_skills:
                    defender_name = defender.name
                    skill_text = f"{defender_name}'s skills: {', '.join(defender_skills)}"
                    skill_surface = self.font.render(skill_text, True, COLOR_RED)
                    self.screen.blit(skill_surface, (70, y_offset))
            
            # 続行ボタン
            continue_text = "Click to continue"
            continue_surface = self.font.render(continue_text, True, COLOR_BLACK)
            self.screen.blit(continue_surface, (self.screen.get_width() // 2 - 60, self.screen.get_height() - 100))
            
            # 戦闘アニメーションを終了
            if pygame.mouse.get_pressed()[0]:
                self.game_manager.combat_animation_active = False
                self.game_manager.combat_results = None

================
File: save_shop.py
================
# save_shop.py
import pygame
import os
import datetime
from ui_system import Panel, Label, Button, ScrollPanel

class SaveShop(Panel):
    def __init__(self, x, y, width, height, game_manager, save_system, on_close=None):
        super().__init__(x, y, width, height)
        self.game_manager = game_manager
        self.save_system = save_system
        self.on_close = on_close
        
        # セーブショップタイトル
        title_label = Label(width // 2, 20, "セーブ屋", None, 30, (255, 255, 200), None, "center")
        self.add_child(title_label)
        
        # 店主のセリフ
        message_label = Label(width // 2, 60, "冒険の記録を残すのかい？どのスロットを使う？", None, 24, (200, 255, 200), None, "center")
        self.add_child(message_label)
        
        # 閉じるボタン
        close_btn = Button(width - 80, 20, 60, 30, "閉じる", None, 20,
                          (100, 60, 60), (255, 255, 255), (150, 80, 80),
                          (0, 0, 0), 1, self.close_shop)
        self.add_child(close_btn)
        
        # セーブスロットパネル
        save_slots_panel = Panel(20, 100, width - 40, height - 150, (40, 40, 50), (0, 0, 0), 1, 220)
        self.add_child(save_slots_panel)
        
        # セーブスロットの表示
        self.create_save_slots(save_slots_panel)
    
    def create_save_slots(self, parent_panel):
        """セーブスロットを作成"""
        # 現在のセーブデータを取得
        saves = self.save_system.get_all_saves()
        
        # セーブスロットのレイアウト
        slot_width = parent_panel.width - 20
        slot_height = 80
        slot_spacing = 10
        
        # 9つのセーブスロットを作成
        for i in range(1, 10):
            y_pos = (i - 1) * (slot_height + slot_spacing) + 10
            
            # スロットパネル
            slot_panel = Panel(10, y_pos, slot_width, slot_height, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # スロット番号
            slot_panel.add_child(Label(20, 10, f"スロット {i}", None, 20, (255, 255, 255)))
            
            # セーブデータがある場合は情報を表示
            if i in saves:
                save_info = saves[i]
                
                # 保存日時
                slot_panel.add_child(Label(20, 35, f"保存日時: {save_info['save_time']}", None, 16, (200, 200, 255)))
                
                # プレイ時間
                play_time = save_info.get('play_time', 0)
                hours = play_time // 3600
                minutes = (play_time % 3600) // 60
                time_text = f"プレイ時間: {hours}時間{minutes}分"
                slot_panel.add_child(Label(20, 55, time_text, None, 16, (200, 200, 255)))
                
                # 進行状況
                progress_text = f"シナリオ: {save_info.get('current_scenario', '不明')}"
                slot_panel.add_child(Label(slot_width - 150, 35, progress_text, None, 16, (200, 255, 200)))
                
                # 上書き保存ボタン
                overwrite_btn = Button(slot_width - 170, 10, 80, 25, "上書き", None, 16,
                                      (60, 100, 60), (255, 255, 255), (80, 150, 80),
                                      (0, 0, 0), 1, lambda slot=i: self.save_game(slot))
                slot_panel.add_child(overwrite_btn)
                
                # ロードボタン
                load_btn = Button(slot_width - 80, 10, 70, 25, "ロード", None, 16,
                                 (60, 60, 100), (255, 255, 255), (80, 80, 150),
                                 (0, 0, 0), 1, lambda slot=i: self.load_game(slot))
                slot_panel.add_child(load_btn)
            else:
                # 空きスロット
                slot_panel.add_child(Label(slot_width // 2, 40, "空きスロット", None, 18, (180, 180, 180), None, "center"))
                
                # 新規保存ボタン
                save_btn = Button(slot_width - 80, 10, 70, 25, "保存", None, 16,
                                 (60, 100, 60), (255, 255, 255), (80, 150, 80),
                                 (0, 0, 0), 1, lambda slot=i: self.save_game(slot))
                slot_panel.add_child(save_btn)
            
            parent_panel.add_child(slot_panel)
    
    def save_game(self, slot):
        """ゲームを保存"""
        # ゲームデータの取得
        game_data = self.game_manager.prepare_save_data()
        
        # 保存処理
        success = self.save_system.save_game(slot, game_data)
        
        if success:
            # 保存成功メッセージ（未実装）
            pass
        else:
            # 保存失敗メッセージ（未実装）
            pass
    
    def load_game(self, slot):
        """ゲームをロード"""
        # セーブデータのロード
        save_data = self.save_system.load_game(slot)
        
        if save_data:
            # ロードの実行
            self.game_manager.load_game_data(save_data)
            
            # ロード成功メッセージ（未実装）
            
            # セーブ屋を閉じる
            self.close_shop()
        else:
            # ロード失敗メッセージ（未実装）
            pass
    
    def close_shop(self):
        """セーブ屋を閉じる"""
        if self.on_close:
            self.on_close()

================
File: save_system.py
================
# save_system.py
import json
import os
import datetime

class SaveSystem:
    def __init__(self, save_directory="saves"):
        self.save_directory = save_directory
        os.makedirs(save_directory, exist_ok=True)
    
    def save_game(self, slot, game_data):
        """ゲームデータをセーブ"""
        save_path = os.path.join(self.save_directory, f"save_{slot}.json")
        
        # セーブデータに日時を追加
        save_data = game_data.copy()
        save_data["save_time"] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        try:
            with open(save_path, 'w', encoding='utf-8') as f:
                json.dump(save_data, f, ensure_ascii=False, indent=2)
            return True
        except Exception as e:
            print(f"セーブエラー: {e}")
            return False
    
    def load_game(self, slot):
        """セーブデータをロード"""
        save_path = os.path.join(self.save_directory, f"save_{slot}.json")
        
        if not os.path.exists(save_path):
            return None
        
        try:
            with open(save_path, 'r', encoding='utf-8') as f:
                save_data = json.load(f)
            return save_data
        except Exception as e:
            print(f"ロードエラー: {e}")
            return None
    
    def get_save_info(self, slot):
        """セーブデータの基本情報を取得"""
        save_path = os.path.join(self.save_directory, f"save_{slot}.json")
        
        if not os.path.exists(save_path):
            return None
        
        try:
            with open(save_path, 'r', encoding='utf-8') as f:
                save_data = json.load(f)
            
            # 基本情報のみ抽出
            info = {
                "save_time": save_data.get("save_time", "不明"),
                "party": save_data.get("party", []),
                "play_time": save_data.get("play_time", 0),
                "gold": save_data.get("gold", 0),
                "current_scenario": save_data.get("current_scenario", "")
            }
            return info
        except Exception as e:
            print(f"セーブ情報取得エラー: {e}")
            return None
    
    def get_all_saves(self):
        """全セーブデータの情報を取得"""
        saves = {}
        
        for i in range(1, 10):  # 9つのセーブスロット
            info = self.get_save_info(i)
            if info:
                saves[i] = info
        
        return saves

================
File: scenario_select_screen.py
================
# scenario_select_screen.py
import pygame
from ui_system import Panel, Label, Button, ScrollPanel

class ScenarioSelectScreen(Panel):
    def __init__(self, x, y, width, height, scenarios, on_select=None, on_back=None):
        super().__init__(x, y, width, height)
        self.scenarios = scenarios
        self.on_select = on_select
        self.on_back = on_back
        
        # タイトル
        title_label = Label(width // 2, 20, "シナリオ選択", None, 30, (255, 255, 200), None, "center")
        self.add_child(title_label)
        
        # シナリオリスト（スクロール可能）
        scenario_list = ScrollPanel(20, 70, width - 40, height - 150, height, (40, 40, 50), (0, 0, 0), 1, 220)
        self.add_child(scenario_list)
        
        # シナリオの表示
        for i, scenario in enumerate(self.scenarios):
            scenario_panel = Panel(10, i * 100 + 10, scenario_list.width - 30, 90, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # シナリオ名
            scenario_panel.add_child(Label(10, 10, scenario["name"], None, 24, (255, 255, 255)))
            
            # シナリオ説明
            scenario_panel.add_child(Label(10, 40, scenario["description"], None, 18, (200, 200, 200)))
            
            # 推奨レベル
            level_text = f"推奨Lv: {scenario['recommended_level']}"
            scenario_panel.add_child(Label(scenario_panel.width - 100, 10, level_text, None, 20, (200, 255, 200)))
            
            # 選択ボタン
            select_btn = Button(scenario_panel.width - 90, 60, 80, 25, "選択", None, 18,
                               (60, 100, 60), (255, 255, 255), (80, 150, 80),
                               (0, 0, 0), 1, lambda s=scenario: self.select_scenario(s))
            scenario_panel.add_child(select_btn)
            
            scenario_list.add_child(scenario_panel)
        
        # コンテンツの高さを更新
        scenario_list.update_content_height()
        
        # 戻るボタン
        back_btn = Button(20, height - 60, 100, 40, "戻る", None, 24,
                         (100, 60, 60), (255, 255, 255), (150, 80, 80),
                         (0, 0, 0), 1, self.go_back)
        self.add_child(back_btn)
    
    def select_scenario(self, scenario):
        if self.on_select:
            self.on_select(scenario)
    
    def go_back(self):
        if self.on_back:
            self.on_back()

================
File: setup.py
================
# setup.py
from unit import Unit
from weapon import Weapon
from constants import WeaponType
from skills import create_sample_skills
from movement_system import MovementType

def create_weapons():
    """サンプルの武器を作成する"""
    iron_sword = Weapon("Iron Sword", WeaponType.SWORD, 5, 90, 0, 5, 1, 1, 45)
    iron_lance = Weapon("Iron Lance", WeaponType.LANCE, 6, 80, 0, 7, 1, 1, 45)
    iron_axe = Weapon("Iron Axe", WeaponType.AXE, 8, 70, 0, 10, 1, 1, 45)
    iron_bow = Weapon("Iron Bow", WeaponType.BOW, 6, 85, 0, 5, 2, 2, 45)
    fire = Weapon("Fire", WeaponType.MAGIC, 5, 90, 0, 4, 1, 2, 40)
    
    return {
        "iron_sword": iron_sword,
        "iron_lance": iron_lance,
        "iron_axe": iron_axe,
        "iron_bow": iron_bow,
        "fire": fire
    }

def create_units(weapons):
    """ユニットを作成する"""
    # プレイヤーユニット
    marth = Unit("Marth", "Lord", 1, 20, 5, 0, 7, 9, 7, 5, 0, 5, 0, [weapons["iron_sword"]])
    roy = Unit("Roy", "Knight", 1, 24, 8, 0, 5, 4, 3, 9, 2, 4, 0, [weapons["iron_lance"]])
    lyn = Unit("Lyn", "Myrmidon", 1, 18, 4, 0, 9, 10, 8, 3, 2, 6, 0, [weapons["iron_sword"]])
    hector = Unit("Hector", "Fighter", 1, 26, 9, 0, 4, 5, 2, 8, 1, 4, 0, [weapons["iron_axe"]])
    robin = Unit("Robin", "Mage", 1, 16, 2, 7, 6, 6, 5, 2, 6, 5, 0, [weapons["fire"]])
    
    # 敵ユニット
    bandit1 = Unit("Bandit", "Fighter", 1, 22, 7, 0, 3, 4, 1, 6, 0, 4, 1, [weapons["iron_axe"]])
    bandit2 = Unit("Archer", "Archer", 1, 18, 5, 0, 7, 5, 2, 4, 0, 5, 1, [weapons["iron_bow"]])
    bandit3 = Unit("Soldier", "Soldier", 1, 20, 6, 0, 5, 5, 2, 5, 1, 4, 1, [weapons["iron_lance"]])
    bandit4 = Unit("Mage", "Mage", 1, 16, 1, 6, 6, 6, 3, 2, 5, 5, 1, [weapons["fire"]])
    
    player_units = [marth, roy, lyn, hector, robin]
    enemy_units = [bandit1, bandit2, bandit3, bandit4]
    
    return player_units, enemy_units

def add_skills_to_units(game_map):
    """ユニットにスキルを割り当てる"""
    skills = create_sample_skills()
    
    # スキルの割り当て例
    for unit in game_map.units:
        # 職業やキャラクターに応じたスキルの割り当て
        if unit.name == "Marth":
            unit.add_skill(skills[0])  # 連続攻撃
            unit.add_skill(skills[7])  # 太陽
        elif unit.name == "Roy":
            unit.add_skill(skills[3])  # 大盾
            unit.add_skill(skills[9])  # 斧殺し
        elif unit.name == "Lyn":
            unit.add_skill(skills[2])  # 連撃
            unit.add_skill(skills[5])  # 先制攻撃
        elif unit.name == "Hector":
            unit.add_skill(skills[6])  # 怒り
            unit.add_skill(skills[8])  # 剣の達人
        elif unit.name == "Robin":
            unit.add_skill(skills[1])  # 月光
            unit.add_skill(skills[4])  # 聖盾
        elif unit.name == "Bandit":
            unit.add_skill(skills[6])  # 怒り
        elif unit.name == "Archer":
            unit.add_skill(skills[2])  # 連撃
        elif unit.name == "Soldier":
            unit.add_skill(skills[3])  # 大盾
        elif unit.name == "Mage":
            unit.add_skill(skills[1])  # 月光

def setup_game(game_map):
    """ゲームの初期設定を行う"""
    # マップ生成
    game_map.generate_simple_map()
    
    # 武器とユニットの作成
    weapons = create_weapons()
    player_units, enemy_units = create_units(weapons)
    
    # プレイヤーユニットの配置と設定
    placement_positions = [
        (2, 2), (1, 3), (3, 3), (2, 4), (4, 2)
    ]
    
    for unit, (x, y) in zip(player_units, placement_positions):
        game_map.place_unit(unit, x, y)
        
        # 主人公の設定 - Marthを主人公に指定
        if unit.name == "Marth":
            unit.is_hero = True
            unit.is_important = True
    
    # 敵ユニットの配置と設定
    enemy_positions = [
        (12, 7), (10, 8), (11, 6), (9, 7)
    ]
    
    for i, (unit, (x, y)) in enumerate(zip(enemy_units, enemy_positions)):
        game_map.place_unit(unit, x, y)
        
        # AI役割の設定 - 敵ユニットに役割を割り当て
        if i == 0:  # bandit1
            unit.ai_role = "attacker"  # 攻撃役
        elif i == 1:  # bandit2
            unit.ai_role = "assassin"  # 暗殺者
        elif i == 2:  # bandit3
            unit.ai_role = "tank"      # タンク役
        elif i == 3:  # bandit4
            unit.ai_role = "healer"    # 回復役
    
    # スキルの割り当て
    add_skills_to_units(game_map)
    
    # 移動タイプの調整（必要に応じて）
    for unit in game_map.units:
        if unit.name == "Marth":
            unit.movement_type = MovementType.INFANTRY
        elif unit.name == "Hector":
            unit.movement_type = MovementType.ARMORED
        elif unit.name == "Roy":
            unit.movement_type = MovementType.CAVALRY
        elif unit.name == "Robin":
            unit.movement_type = MovementType.MAGE

def create_units(weapons):
    """ユニットを作成する"""
    # 既存のコード
    # プレイヤーユニット
    marth = Unit("Marth", "Lord", 1, 20, 5, 0, 7, 9, 7, 5, 0, 5, 0, [weapons["iron_sword"]])
    roy = Unit("Roy", "Knight", 1, 24, 8, 0, 5, 4, 3, 9, 2, 4, 0, [weapons["iron_lance"]])
    lyn = Unit("Lyn", "Myrmidon", 1, 18, 4, 0, 9, 10, 8, 3, 2, 6, 0, [weapons["iron_sword"]])
    hector = Unit("Hector", "Fighter", 1, 26, 9, 0, 4, 5, 2, 8, 1, 4, 0, [weapons["iron_axe"]])
    robin = Unit("Robin", "Mage", 1, 16, 2, 7, 6, 6, 5, 2, 6, 5, 0, [weapons["fire"]])
    
    # 移動タイプを明示的に設定（オプション）
    marth.movement_type = MovementType.INFANTRY
    roy.movement_type = MovementType.CAVALRY  
    lyn.movement_type = MovementType.INFANTRY
    hector.movement_type = MovementType.ARMORED
    robin.movement_type = MovementType.MAGE
    
    # 敵ユニット
    bandit1 = Unit("Bandit", "Fighter", 1, 22, 7, 0, 3, 4, 1, 6, 0, 4, 1, [weapons["iron_axe"]])
    bandit2 = Unit("Archer", "Archer", 1, 18, 5, 0, 7, 5, 2, 4, 0, 5, 1, [weapons["iron_bow"]])
    bandit3 = Unit("Soldier", "Soldier", 1, 20, 6, 0, 5, 5, 2, 5, 1, 4, 1, [weapons["iron_lance"]])
    bandit4 = Unit("Mage", "Mage", 1, 16, 1, 6, 6, 6, 3, 2, 5, 5, 1, [weapons["fire"]])
    
    player_units = [marth, roy, lyn, hector, robin]
    enemy_units = [bandit1, bandit2, bandit3, bandit4]
    
    return player_units, enemy_units

================
File: skills.py
================
# skills.py
from enum import Enum
import random
from typing import Dict, Union, Optional, List

class SkillTriggerType(Enum):
    # 確率系トリガー
    PERCENTAGE = 1        # 確率で発動
    STAT_BASED = 2        # 能力値に基づく確率で発動
    
    # 条件系トリガー
    ON_ATTACK = 3         # 攻撃時
    ON_DEFEND = 4         # 防御時
    ON_KILL = 5           # 敵を倒した時
    ON_DAMAGE = 6         # ダメージを受けた時
    PRE_COMBAT = 7        # 戦闘開始前
    POST_COMBAT = 8       # 戦闘終了後
    ON_TURN_START = 9     # ターン開始時
    ON_TURN_END = 10      # ターン終了時
    ALWAYS_ACTIVE = 11    # 常時発動
    HP_THRESHOLD = 12     # HPが特定の割合以下/以上
    WEAPON_TYPE = 13      # 特定の武器タイプ使用時
    
class SkillEffectType(Enum):
    STAT_BOOST = 1        # 能力値ブースト
    DAMAGE_BOOST = 2      # ダメージ増加
    DAMAGE_REDUCE = 3     # ダメージ減少
    HIT_BOOST = 4         # 命中率ブースト
    AVOID_BOOST = 5       # 回避率ブースト
    CRITICAL_BOOST = 6    # クリティカル率ブースト
    COUNTER_ATTACK = 7    # 反撃
    FOLLOW_UP = 8         # 追撃
    HEAL = 9              # 回復
    SPECIAL_ATTACK = 10   # 特殊攻撃
    SPECIAL_MOVEMENT = 11 # 特殊移動
    TERRAIN_EFFECT = 12   # 地形効果変更
    WEAPON_EFFECT = 13    # 武器効果変更
    RANGE_CHANGE = 14     # 攻撃範囲変更
    STATUS_IMMUNITY = 15  # 状態異常耐性

class Skill:
    def __init__(
        self, 
        name: str,
        description: str,
        trigger_type: SkillTriggerType,
        effect_type: SkillEffectType,
        trigger_value: Union[int, float, str, None] = None,
        effect_value: Union[int, float, str, None] = None,
        duration: int = -1  # -1は永続
    ):
        self.name = name
        self.description = description
        self.trigger_type = trigger_type
        self.effect_type = effect_type
        self.trigger_value = trigger_value
        self.effect_value = effect_value
        self.duration = duration
        self.remaining_duration = duration if duration > 0 else -1
        self.is_active = False
        
    def check_trigger(self, unit, combat_data: Dict = None) -> bool:
        """スキルのトリガー条件をチェックする"""
        if self.trigger_type == SkillTriggerType.PERCENTAGE:
            # 発動率に基づくチェック
            roll = random.randint(1, 100)
            return roll <= self.trigger_value
            
        elif self.trigger_type == SkillTriggerType.STAT_BASED:
            # 能力値に基づく発動率（例: 技×2%）
            if isinstance(self.trigger_value, tuple) and len(self.trigger_value) == 2:
                stat_name, multiplier = self.trigger_value
                if hasattr(unit, stat_name):
                    stat_value = getattr(unit, stat_name)
                    roll = random.randint(1, 100)
                    return roll <= (stat_value * multiplier)
            return False
            
        elif self.trigger_type == SkillTriggerType.HP_THRESHOLD:
            # HP閾値チェック（例: HP < 50%）
            if isinstance(self.trigger_value, tuple) and len(self.trigger_value) == 2:
                operator, threshold = self.trigger_value
                hp_ratio = unit.current_hp / unit.max_hp * 100
                if operator == "<":
                    return hp_ratio < threshold
                elif operator == "<=":
                    return hp_ratio <= threshold
                elif operator == ">":
                    return hp_ratio > threshold
                elif operator == ">=":
                    return hp_ratio >= threshold
            return False
            
        elif self.trigger_type == SkillTriggerType.WEAPON_TYPE:
            # 武器タイプチェック
            if unit.equipped_weapon:
                return unit.equipped_weapon.weapon_type == self.trigger_value
            return False
            
        elif self.trigger_type == SkillTriggerType.ALWAYS_ACTIVE:
            # 常時発動
            return True
            
        # 戦闘関連トリガー (combat_dataが必要)
        elif combat_data:
            if self.trigger_type == SkillTriggerType.ON_ATTACK:
                return combat_data.get("is_attacker", False)
                
            elif self.trigger_type == SkillTriggerType.ON_DEFEND:
                return not combat_data.get("is_attacker", True)
                
            elif self.trigger_type == SkillTriggerType.ON_KILL:
                return combat_data.get("target_killed", False)
                
            elif self.trigger_type == SkillTriggerType.ON_DAMAGE:
                return combat_data.get("damage_received", 0) > 0
                
        # 他のトリガータイプ
        return False
        
    def apply_effect(self, unit, target = None, combat_data: Dict = None) -> Dict:
        """スキル効果を適用し、変更された戦闘データを返す"""
        if not combat_data:
            combat_data = {}
            
        effect_result = {}
        
        # スキル効果の適用
        if self.effect_type == SkillEffectType.STAT_BOOST:
            # 一時的な能力値ブースト
            if isinstance(self.effect_value, tuple) and len(self.effect_value) == 2:
                stat_name, boost_value = self.effect_value
                if hasattr(unit, stat_name):
                    current_value = getattr(unit, stat_name)
                    effect_result["boosted_stat"] = stat_name
                    effect_result["boost_amount"] = boost_value
                    combat_data[f"temp_{stat_name}"] = current_value + boost_value
                    
        elif self.effect_type == SkillEffectType.DAMAGE_BOOST:
            # ダメージ増加
            combat_data["damage_modifier"] = combat_data.get("damage_modifier", 0) + self.effect_value
            effect_result["damage_boost"] = self.effect_value
            
        elif self.effect_type == SkillEffectType.DAMAGE_REDUCE:
            # ダメージ減少
            combat_data["damage_reduction"] = combat_data.get("damage_reduction", 0) + self.effect_value
            effect_result["damage_reduction"] = self.effect_value
            
        elif self.effect_type == SkillEffectType.HIT_BOOST:
            # 命中率ブースト
            combat_data["hit_modifier"] = combat_data.get("hit_modifier", 0) + self.effect_value
            effect_result["hit_boost"] = self.effect_value
            
        elif self.effect_type == SkillEffectType.AVOID_BOOST:
            # 回避率ブースト
            combat_data["avoid_modifier"] = combat_data.get("avoid_modifier", 0) + self.effect_value
            effect_result["avoid_boost"] = self.effect_value
            
        elif self.effect_type == SkillEffectType.CRITICAL_BOOST:
            # クリティカル率ブースト
            combat_data["crit_modifier"] = combat_data.get("crit_modifier", 0) + self.effect_value
            effect_result["crit_boost"] = self.effect_value
            
        elif self.effect_type == SkillEffectType.HEAL:
            # HP回復
            if isinstance(self.effect_value, float) and 0 <= self.effect_value <= 1:
                # 最大HPの割合で回復
                heal_amount = int(unit.max_hp * self.effect_value)
            else:
                # 固定値で回復
                heal_amount = int(self.effect_value)
                
            unit.current_hp = min(unit.max_hp, unit.current_hp + heal_amount)
            effect_result["healed"] = heal_amount
            
        elif self.effect_type == SkillEffectType.FOLLOW_UP:
            # 追撃を保証
            combat_data["guaranteed_follow_up"] = True
            effect_result["follow_up"] = True
            
        elif self.effect_type == SkillEffectType.COUNTER_ATTACK:
            # 反撃を保証（通常反撃できない状況でも）
            combat_data["guaranteed_counter"] = True
            effect_result["counter_attack"] = True
            
        # デュレーション管理
        if self.duration > 0:
            self.remaining_duration -= 1
            if self.remaining_duration <= 0:
                self.is_active = False
                
        return effect_result

def create_sample_skills():
    """サンプルスキルを作成する"""
    from constants import WeaponType
    
    # 攻撃系スキル
    astra = Skill(
        name="連続攻撃",
        description="確率で5回連続攻撃を行う（各攻撃のダメージは通常の30%）",
        trigger_type=SkillTriggerType.STAT_BASED,
        effect_type=SkillEffectType.SPECIAL_ATTACK,
        trigger_value=("skill", 0.5),  # 技×0.5%の確率で発動
        effect_value={"attacks": 5, "damage_multiplier": 0.3}
    )
    
    luna = Skill(
        name="月光",
        description="攻撃時、敵の守備または魔防の50%を無視する",
        trigger_type=SkillTriggerType.PERCENTAGE,
        effect_type=SkillEffectType.SPECIAL_ATTACK,
        trigger_value=35,  # 35%の確率で発動
        effect_value={"defense_pierce": 0.5}
    )
    
    adept = Skill(
        name="連撃",
        description="速さが一定以上高いと追撃が発生する確率が上がる",
        trigger_type=SkillTriggerType.STAT_BASED,
        effect_type=SkillEffectType.FOLLOW_UP,
        trigger_value=("speed", 0.75),  # 速さ×0.75%の確率で発動
        effect_value=True
    )

    # 防御系スキル
    pavise = Skill(
        name="大盾",
        description="物理攻撃のダメージを半減する",
        trigger_type=SkillTriggerType.STAT_BASED,
        effect_type=SkillEffectType.DAMAGE_REDUCE,
        trigger_value=("defense", 0.4),  # 守備×0.4%の確率で発動
        effect_value=0.5  # ダメージ50%減少
    )
    
    aegis = Skill(
        name="聖盾",
        description="魔法攻撃のダメージを半減する",
        trigger_type=SkillTriggerType.STAT_BASED,
        effect_type=SkillEffectType.DAMAGE_REDUCE,
        trigger_value=("resistance", 0.4),  # 魔防×0.4%の確率で発動
        effect_value=0.5  # ダメージ50%減少
    )

    # 能力強化系スキル
    vantage = Skill(
        name="先制攻撃",
        description="HPが50%以下のとき、敵より先に攻撃する",
        trigger_type=SkillTriggerType.HP_THRESHOLD,
        effect_type=SkillEffectType.SPECIAL_ATTACK,
        trigger_value=("<", 50),  # HP < 50%で発動
        effect_value={"vantage": True}
    )
    
    wrath = Skill(
        name="怒り",
        description="HPが50%以下のとき、クリティカル率+20",
        trigger_type=SkillTriggerType.HP_THRESHOLD,
        effect_type=SkillEffectType.CRITICAL_BOOST,
        trigger_value=("<", 50),  # HP < 50%で発動
        effect_value=20  # クリティカル率+20
    )
    
    sol = Skill(
        name="太陽",
        description="攻撃時、与えたダメージの半分を回復する",
        trigger_type=SkillTriggerType.PERCENTAGE,
        effect_type=SkillEffectType.HEAL,
        trigger_value=30,  # 30%の確率で発動
        effect_value={"heal_ratio": 0.5}  # 与ダメージの50%回復
    )

    # 武器タイプに関するスキル
    swordfaire = Skill(
        name="剣の達人",
        description="剣装備時、攻撃+5",
        trigger_type=SkillTriggerType.WEAPON_TYPE,
        effect_type=SkillEffectType.DAMAGE_BOOST,
        trigger_value=WeaponType.SWORD,
        effect_value=5  # 攻撃+5
    )
    
    axebreaker = Skill(
        name="斧殺し",
        description="斧使用ユニットとの戦闘時、命中・回避+30",
        trigger_type=SkillTriggerType.ALWAYS_ACTIVE,
        effect_type=SkillEffectType.SPECIAL_ATTACK,
        effect_value={
            "condition": "opponent_weapon_type == WeaponType.AXE",
            "hit_bonus": 30,
            "avoid_bonus": 30
        }
    )
    
    return [astra, luna, adept, pavise, aegis, vantage, wrath, sol, swordfaire, axebreaker]

================
File: support_conversation_ui.py
================
# support_conversation_ui.py
import pygame
from typing import List, Dict, Tuple, Optional, Callable
from ui_system import Panel, Label, Button, ScrollPanel
from support_system import SupportSystem, SupportLevel, SupportConversation
from constants import COLOR_BLACK, COLOR_WHITE, COLOR_BLUE, COLOR_RED, COLOR_GREEN, COLOR_YELLOW, COLOR_GRAY
from constants import SCREEN_WIDTH, SCREEN_HEIGHT

class SupportListWindow(Panel):
    """支援関係一覧を表示するウィンドウ"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 support_system: SupportSystem,
                 unit_name: Optional[str] = None,  # 特定ユニットのみ表示する場合
                 on_select: Optional[Callable] = None,
                 on_close: Optional[Callable] = None,
                 color=(40, 40, 40), border_color=COLOR_WHITE, border_width=2, alpha=230):
        super().__init__(x, y, width, height, color, border_color, border_width, alpha)
        
        self.support_system = support_system
        self.unit_name = unit_name
        self.on_select = on_select
        self.on_close = on_close
        
        # フォント
        self.title_font = pygame.font.Font(None, 28)
        self.font = pygame.font.Font(None, 24)
        self.small_font = pygame.font.Font(None, 18)
        
        # スクロールパネル
        self.scroll_panel = None
        
        # 選択中の支援ペア
        self.selected_pair = None
        
        self.setup_ui()
    
    def setup_ui(self):
        """UIのセットアップ"""
        # タイトル
        title_text = "支援関係一覧" if not self.unit_name else f"{self.unit_name}の支援関係"
        title_label = Label(self.width // 2, 15, title_text, self.title_font, 28, COLOR_WHITE, None, "center")
        self.add_child(title_label)
        
        # 閉じるボタン
        close_btn = Button(self.width - 30, 10, 20, 20, "×", None, 20,
                          (200, 50, 50), COLOR_WHITE, (255, 100, 100),
                          None, 0, self.close)
        self.add_child(close_btn)
        
        # スクロールパネル
        scroll_panel = ScrollPanel(10, 50, self.width - 20, self.height - 70,
                                  self.height, (50, 50, 50), COLOR_BLACK, 1, 220)
        self.add_child(scroll_panel)
        self.scroll_panel = scroll_panel
        
        # 支援関係の一覧を表示
        self.update_support_list()
    
    def update_support_list(self):
        """支援関係リストを更新"""
        if not self.scroll_panel:
            return
            
        self.scroll_panel.clear_children()
        
        # 表示する支援ペアを収集
        pairs_to_show = []
        for key, pair in self.support_system.supports.items():
            # 特定ユニットの支援のみ表示する場合
            if self.unit_name and self.unit_name not in pair.characters:
                continue
                
            # 支援レベルがNONEの場合は条件次第で除外
            if pair.current_level == SupportLevel.NONE:
                # 特定ユニット表示時のみNONEも表示
                if not self.unit_name:
                    continue
            
            pairs_to_show.append(pair)
        
        # ソート（支援レベル降順、次に名前順）
        pairs_to_show.sort(key=lambda p: (-p.current_level.value, p.characters[0], p.characters[1]))
        
        # 各支援ペアを表示
        y_offset = 10
        for i, pair in enumerate(pairs_to_show):
            # ペアのパネル
            pair_height = 60
            pair_panel = Panel(5, y_offset, self.scroll_panel.width - 20, pair_height,
                              (60, 60, 60), COLOR_BLACK, 1, 255)
            
            # キャラクター名
            char1, char2 = pair.characters
            names_text = f"{char1} ＆ {char2}"
            pair_panel.add_child(Label(10, 8, names_text, self.font, 24, COLOR_WHITE))
            
            # 支援レベル
            level_colors = {
                SupportLevel.NONE: COLOR_GRAY,
                SupportLevel.C: (150, 150, 255),
                SupportLevel.B: (100, 100, 255),
                SupportLevel.A: (50, 50, 255),
                SupportLevel.S: (255, 150, 150)
            }
            level_text = f"支援レベル: {pair.current_level.name}"
            level_color = level_colors.get(pair.current_level, COLOR_WHITE)
            pair_panel.add_child(Label(10, 30, level_text, self.font, 20, level_color))
            
            # 次のレベルへの進捗
            if pair.current_level != pair.max_level:
                next_points = pair.get_next_required_points()
                progress_text = f"次のレベルまで: {next_points}ポイント"
                pair_panel.add_child(Label(200, 30, progress_text, self.small_font, 18, COLOR_WHITE))
            
            # 会話アイコン（未読会話がある場合）
            if pair.has_available_conversation():
                msg_btn = Button(self.scroll_panel.width - 60, 10, 40, 40, "会話",
                               self.font, 16, (80, 150, 80), COLOR_WHITE, (100, 200, 100),
                               COLOR_BLACK, 1, lambda p=pair: self.select_pair(p))
                pair_panel.add_child(msg_btn)
            
            self.scroll_panel.add_child(pair_panel)
            y_offset += pair_height + 5
        
        # コンテンツ高さの更新
        self.scroll_panel.update_content_height()
    
    def select_pair(self, pair):
        """支援ペアを選択して会話ウィンドウを表示"""
        self.selected_pair = pair
        
        if self.on_select:
            self.on_select(pair.characters[0], pair.characters[1], pair.current_level)
    
    def close(self):
        """ウィンドウを閉じる"""
        self.visible = False

class SupportConversationWindow(Panel):
    """支援会話を表示するウィンドウ"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 conversation: SupportConversation,
                 on_close: Optional[Callable] = None,
                 on_complete: Optional[Callable] = None,
                 color=(20, 20, 60), border_color=COLOR_YELLOW, border_width=2, alpha=230):
        super().__init__(x, y, width, height, color, border_color, border_width, alpha)
        
        self.conversation = conversation
        self.on_close = on_close
        self.on_complete = on_complete
        
        # フォント
        self.title_font = pygame.font.Font(None, 28)
        self.name_font = pygame.font.Font(None, 24)
        self.text_font = pygame.font.Font(None, 22)
        
        # 会話の進行状況
        self.current_message_index = 0
        self.current_char_index = 0
        self.message_speed = 2  # 1フレームあたりの文字数
        self.message_delay = 0  # メッセージ間の遅延
        
        # アニメーション用タイマー
        self.animation_timer = 0
        
        # キャラクターの配置（左右）
        if conversation and len(conversation.characters) >= 2:
            self.left_character = conversation.characters[0]
            self.right_character = conversation.characters[1]
        else:
            self.left_character = "???"
            self.right_character = "???"
        
        # 背景画像（仮）
        self.background = None
        
        # 会話メッセージ
        self.messages = []
        if conversation:
            self.messages = conversation.content
        
        self.setup_ui()
    
    def setup_ui(self):
        """UIのセットアップ"""
        # タイトル
        title_text = self.conversation.title if self.conversation else "支援会話"
        title_label = Label(self.width // 2, 15, title_text, self.title_font, 28, COLOR_YELLOW, None, "center")
        self.add_child(title_label)
        
        # 支援レベル表示
        level_text = f"支援レベル: {self.conversation.level.name}" if self.conversation else ""
        level_label = Label(self.width // 2, 45, level_text, self.name_font, 24, COLOR_WHITE, None, "center")
        self.add_child(level_label)
        
        # キャラクター表示領域（左右）
        left_char_panel = Panel(20, 70, 120, 150, (40, 40, 80), None, 0, 150)
        right_char_panel = Panel(self.width - 140, 70, 120, 150, (40, 40, 80), None, 0, 150)
        
        # キャラクター名
        left_char_label = Label(80, 230, self.left_character, self.name_font, 24, COLOR_BLUE, None, "center")
        right_char_label = Label(self.width - 80, 230, self.right_character, self.name_font, 24, COLOR_RED, None, "center")
        
        self.add_child(left_char_panel)
        self.add_child(right_char_panel)
        self.add_child(left_char_label)
        self.add_child(right_char_label)
        
        # メッセージウィンドウ
        message_panel = Panel(20, self.height - 120, self.width - 40, 100, (40, 40, 60), COLOR_WHITE, 1, 230)
        self.add_child(message_panel)
        self.message_panel = message_panel
        
        # 発言者名ラベル
        speaker_label = Label(40, self.height - 120, "", self.name_font, 24, COLOR_YELLOW)
        self.add_child(speaker_label)
        self.speaker_label = speaker_label
        
        # メッセージテキスト
        message_label = Label(30, self.height - 95, "", self.text_font, 22, COLOR_WHITE)
        message_label.set_text("")
        self.add_child(message_label)
        self.message_label = message_label
        
        # 進行ボタン（テキスト送り/会話終了）
        next_btn = Button(self.width - 80, self.height - 40, 60, 30, "次へ",
                         self.name_font, 20, (60, 60, 100), COLOR_WHITE, (80, 80, 150),
                         COLOR_BLACK, 1, self.next_message)
        self.add_child(next_btn)
        self.next_btn = next_btn
        
        # 最初のメッセージを表示
        self.update_current_message()
    
    def update(self):
        """状態更新（テキストアニメーション）"""
        super().update()
        
        if not self.messages or self.current_message_index >= len(self.messages):
            return
        
        current_message = self.messages[self.current_message_index]
        full_text = current_message.get("text", "")
        
        # メッセージ遅延中なら待機
        if self.message_delay > 0:
            self.message_delay -= 1
            return
        
        # アニメーションタイマー更新
        self.animation_timer += 1
        
        # 一定間隔で文字を増やす
        if self.animation_timer >= self.message_speed:
            self.animation_timer = 0
            
            # 表示する文字数を増やす
            if self.current_char_index < len(full_text):
                self.current_char_index += 1
                # 現在のテキストを更新
                current_text = full_text[:self.current_char_index]
                self.message_label.set_text(current_text)
                
                # 文字表示時のSE（未実装）
                # self._play_text_sound()
    
    def update_current_message(self):
        """現在のメッセージを更新"""
        if not self.messages or self.current_message_index >= len(self.messages):
            # 会話終了
            self.next_btn.text = "閉じる"
            self.speaker_label.set_text("")
            self.message_label.set_text("（会話終了）")
            return
        
        # 現在のメッセージ取得
        current_message = self.messages[self.current_message_index]
        speaker = current_message.get("speaker", "")
        full_text = current_message.get("text", "")
        
        # 話者名を更新
        self.speaker_label.set_text(speaker)
        
        # 話者によって色を変更
        if speaker == self.left_character:
            self.speaker_label.color = COLOR_BLUE
        elif speaker == self.right_character:
            self.speaker_label.color = COLOR_RED
        else:
            self.speaker_label.color = COLOR_YELLOW
        
        # テキストのアニメーション開始
        self.current_char_index = 0
        self.animation_timer = 0
        self.message_label.set_text("")
    
    def next_message(self):
        """次のメッセージに進む、または会話を終了"""
        # 現在のメッセージがまだ全部表示されていない場合は全部表示
        if self.messages and self.current_message_index < len(self.messages):
            current_message = self.messages[self.current_message_index]
            full_text = current_message.get("text", "")
            
            if self.current_char_index < len(full_text):
                self.current_char_index = len(full_text)
                self.message_label.set_text(full_text)
                return
        
        # 次のメッセージへ
        self.current_message_index += 1
        
        # まだメッセージがある場合
        if self.messages and self.current_message_index < len(self.messages):
            self.message_delay = 10  # 次のメッセージまでの遅延
            self.update_current_message()
        else:
            # 会話終了
            if self.on_complete:
                self.on_complete(self.conversation)
            
            # 閉じるボタンとして機能
            if self.next_btn.text == "閉じる":
                self.close()
    
    def close(self):
        """ウィンドウを閉じる"""
        self.visible = False
        if self.on_close:
            self.on_close()

class SupportConfirmationWindow(Panel):
    """支援レベルアップの確認ウィンドウ"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 char1: str, char2: str, new_level: SupportLevel,
                 on_view_conversation: Optional[Callable] = None,
                 on_close: Optional[Callable] = None,
                 color=(40, 40, 70), border_color=COLOR_YELLOW, border_width=2, alpha=230):
        super().__init__(x, y, width, height, color, border_color, border_width, alpha)
        
        self.char1 = char1
        self.char2 = char2
        self.new_level = new_level
        self.on_view_conversation = on_view_conversation
        self.on_close = on_close
        
        # フォント
        self.title_font = pygame.font.Font(None, 28)
        self.font = pygame.font.Font(None, 24)
        
        self.setup_ui()
    
    def setup_ui(self):
        """UIのセットアップ"""
        # タイトル
        title_label = Label(self.width // 2, 20, "支援レベルアップ！", 
                           self.title_font, 28, COLOR_YELLOW, None, "center")
        self.add_child(title_label)
        
        # キャラクター名
        names_text = f"{self.char1} と {self.char2}"
        names_label = Label(self.width // 2, 60, names_text, 
                           self.font, 24, COLOR_WHITE, None, "center")
        self.add_child(names_label)
        
        # 新しい支援レベル
        level_text = f"支援レベルが{self.new_level.name}になりました！"
        level_label = Label(self.width // 2, 90, level_text, 
                           self.font, 24, COLOR_BLUE, None, "center")
        self.add_child(level_label)
        
        # 効果説明
        bonus = SupportBonus.calculate_from_level(self.new_level)
        effects_text = [
            f"与えるダメージ: +{bonus.damage_bonus}",
            f"受けるダメージ: -{bonus.defense_bonus}",
            f"命中率: +{bonus.hit_bonus}%",
            f"回避率: +{bonus.avoid_bonus}%"
        ]
        
        y_offset = 130
        for text in effects_text:
            effect_label = Label(self.width // 2, y_offset, text, 
                                self.font, 20, COLOR_WHITE, None, "center")
            self.add_child(effect_label)
            y_offset += 25
        
        # 会話を見るボタン
        view_btn = Button(self.width // 2 - 100, self.height - 60, 200, 40, "支援会話を見る",
                         self.font, 20, (60, 100, 60), COLOR_WHITE, (80, 150, 80),
                         COLOR_BLACK, 1, self.view_conversation)
        self.add_child(view_btn)
    
    def view_conversation(self):
        """支援会話を表示"""
        self.visible = False
        if self.on_view_conversation:
            self.on_view_conversation(self.char1, self.char2, self.new_level)
    
    def close(self):
        """ウィンドウを閉じる"""
        self.visible = False
        if self.on_close:
            self.on_close()


# UIManagerに追加するメソッド
def show_support_list(self, unit_name=None):
    """支援リストウィンドウを表示"""
    support_list = SupportListWindow(
        SCREEN_WIDTH // 2 - 250, SCREEN_HEIGHT // 2 - 200, 500, 400,
        self.game_manager.support_system,
        unit_name,
        lambda char1, char2, level: self.show_support_conversation(char1, char2, level)
    )
    self.ui_elements.append(support_list)
    return support_list

def show_support_conversation(self, char1, char2, level=None):
    """支援会話ウィンドウを表示"""
    conversation = self.game_manager.support_system.get_conversation(char1, char2, level)
    if not conversation:
        return None
        
    # 会話ウィンドウを作成
    conv_window = SupportConversationWindow(
        SCREEN_WIDTH // 2 - 300, SCREEN_HEIGHT // 2 - 200, 600, 400,
        conversation,
        None,
        lambda conv: self.game_manager.support_system.mark_conversation_viewed(char1, char2, level)
    )
    self.ui_elements.append(conv_window)
    return conv_window

def show_support_level_up(self, char1, char2, new_level):
    """支援レベルアップ確認ウィンドウを表示"""
    confirm_window = SupportConfirmationWindow(
        SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 150, 400, 300,
        char1, char2, new_level,
        lambda c1, c2, lvl: self.show_support_conversation(c1, c2, lvl)
    )
    self.ui_elements.append(confirm_window)
    return confirm_window

================
File: support_system.py
================
# support_system.py
from typing import Dict, List, Tuple, Optional
import json
import os
from enum import Enum

class SupportLevel(Enum):
    """支援レベルを定義するクラス"""
    NONE = 0    # 支援なし
    C = 1       # Cランク
    B = 2       # Bランク
    A = 3       # Aランク
    S = 4       # Sランク（最大）

class SupportBonus:
    """支援効果を定義するクラス"""
    def __init__(self, 
                 damage_bonus: int = 0,      # 与ダメージボーナス
                 defense_bonus: int = 0,     # 受けダメージ軽減
                 hit_bonus: int = 0,         # 命中率ボーナス
                 avoid_bonus: int = 0):      # 回避率ボーナス
        self.damage_bonus = damage_bonus
        self.defense_bonus = defense_bonus
        self.hit_bonus = hit_bonus
        self.avoid_bonus = avoid_bonus
    
    def __add__(self, other):
        """複数の支援効果を加算できるようにする"""
        if not isinstance(other, SupportBonus):
            return self
        
        return SupportBonus(
            self.damage_bonus + other.damage_bonus,
            self.defense_bonus + other.defense_bonus,
            self.hit_bonus + other.hit_bonus,
            self.avoid_bonus + other.avoid_bonus
        )
    
    @classmethod
    def calculate_from_level(cls, level: SupportLevel):
        """支援レベルから標準的な支援効果を計算する"""
        level_value = level.value
        return cls(
            damage_bonus=level_value,             # レベル分のダメージ増加
            defense_bonus=level_value,            # レベル分のダメージ減少
            hit_bonus=level_value * 5,            # レベル×5の命中率上昇
            avoid_bonus=level_value * 5           # レベル×5の回避率上昇
        )

class SupportConversation:
    """支援会話を管理するクラス"""
    def __init__(self, 
                 characters: Tuple[str, str],         # 会話する2人のキャラクター
                 level: SupportLevel,                 # 支援レベル
                 title: str = "",                     # 会話タイトル
                 content: List[Dict] = None,          # 会話内容（辞書のリスト）
                 requirements: Dict = None,           # 会話の発生条件
                 viewed: bool = False):               # 既読フラグ
        self.characters = characters
        self.level = level
        self.title = title or f"{characters[0]}と{characters[1]}の{level.name}支援"
        self.content = content or []
        self.requirements = requirements or {"battles": 0}  # デフォルトは戦闘回数
        self.viewed = viewed
    
    def to_dict(self) -> Dict:
        """辞書形式に変換（シリアライズ用）"""
        return {
            "characters": self.characters,
            "level": self.level.name,
            "title": self.title,
            "content": self.content,
            "requirements": self.requirements,
            "viewed": self.viewed
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'SupportConversation':
        """辞書からインスタンスを生成（デシリアライズ用）"""
        try:
            return cls(
                characters=tuple(data["characters"]),
                level=SupportLevel[data["level"]],
                title=data.get("title", ""),
                content=data.get("content", []),
                requirements=data.get("requirements", {"battles": 0}),
                viewed=data.get("viewed", False)
            )
        except (KeyError, ValueError) as e:
            print(f"支援会話データの読み込みエラー: {e}")
            return None

class SupportPair:
    """2人のキャラクター間の支援関係を管理するクラス"""
    def __init__(self, 
                 characters: Tuple[str, str],                 # 支援する2人のキャラクター
                 current_level: SupportLevel = SupportLevel.NONE,  # 現在の支援レベル
                 max_level: SupportLevel = SupportLevel.A,    # 最大支援レベル
                 points: int = 0,                             # 現在の支援ポイント
                 points_needed: Dict[SupportLevel, int] = None,  # 各レベルに必要なポイント
                 conversations: Dict[SupportLevel, SupportConversation] = None):  # 各レベルの会話
        self.characters = sorted(characters)  # 常にアルファベット順に保存
        self.current_level = current_level
        self.max_level = max_level
        self.points = points
        
        # 各レベルに必要なポイントの設定（デフォルト値）
        self.points_needed = points_needed or {
            SupportLevel.C: 20,
            SupportLevel.B: 60,
            SupportLevel.A: 120,
            SupportLevel.S: 200
        }
        
        # 支援会話の初期化
        self.conversations = conversations or {}
    
    def add_points(self, points: int) -> Tuple[bool, Optional[SupportLevel]]:
        """
        支援ポイントを追加し、レベルアップの有無を返す
        
        Args:
            points: 追加するポイント数
            
        Returns:
            Tuple[bool, Optional[SupportLevel]]: レベルアップしたかどうかとレベルアップ後のレベル
        """
        if self.current_level == self.max_level:
            return False, None  # 既に最大レベルに達している
        
        old_level = self.current_level
        self.points += points
        
        # 次のレベルを計算
        next_level = None
        for level in [SupportLevel.C, SupportLevel.B, SupportLevel.A, SupportLevel.S]:
            if level.value > self.current_level.value and level.value <= self.max_level.value:
                if self.points >= self.points_needed[level]:
                    next_level = level
                break
        
        # レベルアップ処理
        if next_level and next_level.value > self.current_level.value:
            self.current_level = next_level
            return True, next_level
        
        return False, None
    
    def get_next_required_points(self) -> int:
        """次のレベルに必要な残りポイント数を取得"""
        if self.current_level == self.max_level:
            return 0
        
        # 次のレベルを特定
        next_level = None
        for level in [SupportLevel.C, SupportLevel.B, SupportLevel.A, SupportLevel.S]:
            if level.value > self.current_level.value and level.value <= self.max_level.value:
                next_level = level
                break
        
        if not next_level:
            return 0
        
        return max(0, self.points_needed[next_level] - self.points)
    
    def has_available_conversation(self) -> bool:
        """未読の支援会話があるかどうか"""
        return (self.current_level in self.conversations and 
                not self.conversations[self.current_level].viewed)
    
    def get_conversation(self, level: SupportLevel = None) -> Optional[SupportConversation]:
        """指定レベルの支援会話を取得（レベル未指定の場合は現在のレベル）"""
        level = level or self.current_level
        return self.conversations.get(level)
    
    def mark_conversation_viewed(self, level: SupportLevel = None):
        """支援会話を既読にする"""
        level = level or self.current_level
        if level in self.conversations:
            self.conversations[level].viewed = True
    
    def get_support_bonus(self) -> SupportBonus:
        """現在のレベルに基づいた支援効果を取得"""
        return SupportBonus.calculate_from_level(self.current_level)
    
    def to_dict(self) -> Dict:
        """辞書形式に変換（シリアライズ用）"""
        return {
            "characters": self.characters,
            "current_level": self.current_level.name,
            "max_level": self.max_level.name,
            "points": self.points,
            "points_needed": {level.name: points for level, points in self.points_needed.items()},
            "conversations": {level.name: conv.to_dict() for level, conv in self.conversations.items()}
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'SupportPair':
        """辞書からインスタンスを生成（デシリアライズ用）"""
        try:
            # ポイント必要数の変換
            points_needed = {}
            for level_name, points in data.get("points_needed", {}).items():
                try:
                    level = SupportLevel[level_name]
                    points_needed[level] = points
                except KeyError:
                    continue
            
            # 会話の変換
            conversations = {}
            for level_name, conv_data in data.get("conversations", {}).items():
                try:
                    level = SupportLevel[level_name]
                    conv = SupportConversation.from_dict(conv_data)
                    if conv:
                        conversations[level] = conv
                except KeyError:
                    continue
            
            return cls(
                characters=tuple(data["characters"]),
                current_level=SupportLevel[data.get("current_level", "NONE")],
                max_level=SupportLevel[data.get("max_level", "A")],
                points=data.get("points", 0),
                points_needed=points_needed,
                conversations=conversations
            )
        except (KeyError, ValueError) as e:
            print(f"支援ペアデータの読み込みエラー: {e}")
            return None

class SupportSystem:
    """全ユニットの支援関係を管理するクラス"""
    def __init__(self, data_path: str = "data/supports/"):
        self.data_path = data_path
        self.supports = {}  # キャラクターペアをキーとした支援ペアの辞書
        self.battle_counts = {}  # キャラクターペアをキーとした戦闘回数の辞書
        
        # データディレクトリの確認
        os.makedirs(data_path, exist_ok=True)
        
        # 支援会話データの読み込み
        self.load_support_data()
    
    def get_support_pair_key(self, char1: str, char2: str) -> str:
        """2人のキャラクターから辞書キーを生成（常にアルファベット順）"""
        return "_".join(sorted([char1, char2]))
    
    def get_support_pair(self, char1: str, char2: str) -> Optional[SupportPair]:
        """2人のキャラクター間の支援ペアを取得"""
        key = self.get_support_pair_key(char1, char2)
        return self.supports.get(key)
    
    def register_support_pair(self, char1: str, char2: str, max_level: SupportLevel = SupportLevel.A) -> SupportPair:
        """新しい支援ペアを登録"""
        key = self.get_support_pair_key(char1, char2)
        if key not in self.supports:
            self.supports[key] = SupportPair(
                characters=(char1, char2),
                max_level=max_level
            )
        return self.supports[key]
    
    def add_support_points(self, char1: str, char2: str, points: int) -> Tuple[bool, Optional[SupportLevel]]:
        """2人のキャラクター間の支援ポイントを追加"""
        pair = self.get_support_pair(char1, char2)
        if not pair:
            return False, None
        
        return pair.add_points(points)
    
    def record_battle_together(self, char1: str, char2: str):
        """2人のキャラクターが同じマップで戦闘したことを記録"""
        key = self.get_support_pair_key(char1, char2)
        
        # 支援ペアがない場合はスキップ
        if key not in self.supports:
            return
        
        # 戦闘回数を増加
        self.battle_counts[key] = self.battle_counts.get(key, 0) + 1
        
        # 一定回数戦闘するとポイント増加
        if self.battle_counts[key] % 5 == 0:  # 5戦闘ごとにポイント獲得
            self.add_support_points(char1, char2, 5)
    
    def record_adjacent_turns(self, char1: str, char2: str):
        """2人のキャラクターが隣接してターンを終了したことを記録"""
        key = self.get_support_pair_key(char1, char2)
        
        # 支援ペアがない場合はスキップ
        if key not in self.supports:
            return
        
        # 隣接してターン終了するとポイント増加
        self.add_support_points(char1, char2, 1)
    
    def get_available_conversations(self) -> List[Tuple[str, str, SupportLevel]]:
        """閲覧可能な支援会話のリストを取得"""
        available = []
        
        for key, pair in self.supports.items():
            if pair.has_available_conversation():
                char1, char2 = pair.characters
                available.append((char1, char2, pair.current_level))
        
        return available
    
    def get_conversation(self, char1: str, char2: str, level: Optional[SupportLevel] = None) -> Optional[SupportConversation]:
        """指定したキャラクターとレベルの支援会話を取得"""
        pair = self.get_support_pair(char1, char2)
        if not pair:
            return None
        
        return pair.get_conversation(level)
    
    def mark_conversation_viewed(self, char1: str, char2: str, level: Optional[SupportLevel] = None):
        """支援会話を既読にする"""
        pair = self.get_support_pair(char1, char2)
        if pair:
            pair.mark_conversation_viewed(level)
    
    def get_support_bonus(self, unit, game_map) -> SupportBonus:
        """
        ユニットが受ける全支援効果を計算
        
        Args:
            unit: 対象ユニット
            game_map: ゲームマップ
            
        Returns:
            SupportBonus: 適用される総合的な支援効果
        """
        total_bonus = SupportBonus()
        
        # 指定ユニットと支援関係があるユニットを探す
        for key, pair in self.supports.items():
            # 支援レベルがNONEの場合はスキップ
            if pair.current_level == SupportLevel.NONE:
                continue
            
            # このペアに指定ユニットが含まれるか確認
            if unit.name not in pair.characters:
                continue
            
            # もう一方のキャラクターを特定
            other_name = pair.characters[0] if pair.characters[1] == unit.name else pair.characters[1]
            
            # マップ上で相手を探す
            other_unit = None
            for u in game_map.units:
                if u.name == other_name and not u.is_dead():
                    other_unit = u
                    break
            
            if not other_unit:
                continue
            
            # 距離を計算
            distance = abs(unit.x - other_unit.x) + abs(unit.y - other_unit.y)
            
            # 3マス以内なら支援効果を適用
            if distance <= 3:
                total_bonus += pair.get_support_bonus()
        
        return total_bonus
    
    def apply_support_effects(self, attacker, defender, combat_data, game_map):
        """
        戦闘時に支援効果を適用する
        
        Args:
            attacker: 攻撃側ユニット
            defender: 防御側ユニット
            combat_data: 戦闘データ（修正用）
            game_map: ゲームマップ
        """
        # 攻撃側の支援効果
        attacker_bonus = self.get_support_bonus(attacker, game_map)
        
        # 防御側の支援効果
        defender_bonus = self.get_support_bonus(defender, game_map)
        
        # 戦闘データに効果を適用
        # 与ダメージボーナス
        combat_data["damage_modifier"] = combat_data.get("damage_modifier", 0) + attacker_bonus.damage_bonus
        
        # 受けダメージ軽減
        combat_data["damage_reduction"] = combat_data.get("damage_reduction", 0) + defender_bonus.defense_bonus
        
        # 命中率ボーナス
        combat_data["hit_modifier"] = combat_data.get("hit_modifier", 0) + attacker_bonus.hit_bonus
        
        # 回避率ボーナス
        combat_data["avoid_modifier"] = combat_data.get("avoid_modifier", 0) + defender_bonus.avoid_bonus
    
    def load_support_data(self):
        """支援データをファイルから読み込む"""
        # 支援ペアファイル
        pairs_file = os.path.join(self.data_path, "support_pairs.json")
        
        # ファイルが存在する場合は読み込み
        if os.path.exists(pairs_file):
            try:
                with open(pairs_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    
                    # 支援ペアの復元
                    for key, pair_data in data.get("supports", {}).items():
                        pair = SupportPair.from_dict(pair_data)
                        if pair:
                            self.supports[key] = pair
                    
                    # 戦闘回数の復元
                    self.battle_counts = data.get("battle_counts", {})
            except Exception as e:
                print(f"支援データの読み込みエラー: {e}")
    
    def save_support_data(self):
        """支援データをファイルに保存"""
        # 支援ペアファイル
        pairs_file = os.path.join(self.data_path, "support_pairs.json")
        
        try:
            # 保存用データの準備
            data = {
                "supports": {key: pair.to_dict() for key, pair in self.supports.items()},
                "battle_counts": self.battle_counts
            }
            
            # ファイルに保存
            with open(pairs_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"支援データの保存エラー: {e}")
    
    def register_default_supports(self, character_data: List[Dict]):
        """
        キャラクターデータから初期支援関係を登録
        
        Args:
            character_data: キャラクター情報の辞書リスト。各辞書には少なくとも
                           'name'キーと'supports'キー（対応キャラクターリスト）が必要
        """
        for char_info in character_data:
            char_name = char_info.get('name')
            supports = char_info.get('supports', [])
            
            for support_info in supports:
                other_name = support_info.get('character')
                max_level_name = support_info.get('max_level', 'A')
                
                try:
                    max_level = SupportLevel[max_level_name]
                except KeyError:
                    max_level = SupportLevel.A
                
                # 支援ペアの登録
                self.register_support_pair(char_name, other_name, max_level)
                
                # 支援会話の登録（各レベル用）
                self._register_conversation(char_name, other_name, SupportLevel.C, 
                                          support_info.get('c_conv'))
                self._register_conversation(char_name, other_name, SupportLevel.B, 
                                          support_info.get('b_conv'))
                self._register_conversation(char_name, other_name, SupportLevel.A, 
                                          support_info.get('a_conv'))
                self._register_conversation(char_name, other_name, SupportLevel.S, 
                                          support_info.get('s_conv'))
    
    def _register_conversation(self, char1: str, char2: str, level: SupportLevel, conv_data: Dict = None):
        """特定レベルの支援会話を登録"""
        if not conv_data:
            return
        
        pair = self.get_support_pair(char1, char2)
        if not pair or level.value > pair.max_level.value:
            return
        
        # 会話の作成
        conversation = SupportConversation(
            characters=(char1, char2),
            level=level,
            title=conv_data.get('title', ''),
            content=conv_data.get('content', []),
            requirements=conv_data.get('requirements', {'battles': 0})
        )
        
        # 会話の登録
        pair.conversations[level] = conversation

================
File: tavern.py
================
# tavern.py
import pygame
from ui_system import Panel, Label, Button, ScrollPanel

class Tavern(Panel):
    def __init__(self, x, y, width, height, game_manager, on_close=None):
        super().__init__(x, y, width, height)
        self.game_manager = game_manager
        self.on_close = on_close
        
        # 酒場タイトル
        title_label = Label(width // 2, 20, "酒場", None, 30, (255, 255, 200), None, "center")
        self.add_child(title_label)
        
        # タブボタン
        tab_y = 60
        tab_width = width // 3 - 20
        
        support_tab = Button(20, tab_y, tab_width, 30, "支援会話", None, 20,
                            (80, 60, 100), (255, 255, 255), (120, 80, 150),
                            (0, 0, 0), 1, lambda: self.change_tab("support"))
        self.add_child(support_tab)
        
        skill_tab = Button(30 + tab_width, tab_y, tab_width, 30, "スキル編集", None, 20,
                          (60, 80, 100), (255, 255, 255), (80, 120, 150),
                          (0, 0, 0), 1, lambda: self.change_tab("skill"))
        self.add_child(skill_tab)
        
        info_tab = Button(40 + tab_width * 2, tab_y, tab_width, 30, "噂を聞く", None, 20,
                         (100, 80, 60), (255, 255, 255), (150, 120, 80),
                         (0, 0, 0), 1, lambda: self.change_tab("info"))
        self.add_child(info_tab)
        
        # 閉じるボタン
        close_btn = Button(width - 80, 20, 60, 30, "閉じる", None, 20,
                          (100, 60, 60), (255, 255, 255), (150, 80, 80),
                          (0, 0, 0), 1, self.close_tavern)
        self.add_child(close_btn)
        
        # コンテンツパネル
        content_panel = Panel(20, tab_y + 40, width - 40, height - tab_y - 60, (40, 40, 50), (0, 0, 0), 1, 220)
        self.add_child(content_panel)
        self.content_panel = content_panel
        
        # 現在のタブ
        self.current_tab = "support"
        
        # タブの内容を更新
        self.update_tab_content()
    
    def change_tab(self, tab_name):
        """タブを切り替える"""
        self.current_tab = tab_name
        self.update_tab_content()
    
    def update_tab_content(self):
        """現在のタブに応じた内容を表示"""
        self.content_panel.clear_children()
        
        if self.current_tab == "support":
            self.show_support_tab()
        elif self.current_tab == "skill":
            self.show_skill_tab()
        elif self.current_tab == "info":
            self.show_info_tab()
    
    def show_support_tab(self):
        """支援会話タブの表示"""
        # 支援会話一覧（支援システムから取得）
        available_supports = self.game_manager.get_available_support_conversations()
        
        if not available_supports:
            # 閲覧可能な支援会話がない場合
            self.content_panel.add_child(Label(
                self.content_panel.width // 2, 30,
                "閲覧可能な支援会話はありません。",
                None, 24, (200, 200, 200), None, "center"
            ))
            return
        
        # 支援会話リスト
        for i, (char1, char2, level) in enumerate(available_supports):
            support_panel = Panel(10, i * 80 + 10, self.content_panel.width - 20, 70, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # キャラクター名と支援レベル
            support_panel.add_child(Label(10, 10, f"{char1} ＆ {char2}", None, 20, (255, 255, 255)))
            
            # 支援レベル
            level_text = f"支援レベル: {level.name}"
            level_colors = {
                "C": (150, 150, 255),
                "B": (100, 100, 255),
                "A": (50, 50, 255),
                "S": (255, 150, 150)
            }
            level_color = level_colors.get(level.name, (200, 200, 200))
            support_panel.add_child(Label(10, 35, level_text, None, 18, level_color))
            
            # 閲覧ボタン
            view_btn = Button(support_panel.width - 90, 20, 80, 30, "閲覧", None, 18,
                             (60, 100, 60), (255, 255, 255), (80, 150, 80),
                             (0, 0, 0), 1, lambda c1=char1, c2=char2, lvl=level: self.view_support_conversation(c1, c2, lvl))
            support_panel.add_child(view_btn)
            
            self.content_panel.add_child(support_panel)
    
    def show_skill_tab(self):
        """スキル編集タブの表示"""
        # ユニット選択部分（左側）
        unit_select = ScrollPanel(0, 0, self.content_panel.width // 2 - 10, self.content_panel.height,
                                 self.content_panel.height, (40, 40, 50), None, 0, 220)
        self.content_panel.add_child(unit_select)
        
        # ユニットリストの取得
        units = [unit for unit in self.game_manager.game_map.units if unit.team == 0]
        
        for i, unit in enumerate(units):
            unit_panel = Panel(10, i * 60 + 10, unit_select.width - 20, 50, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # ユニット名と職業
            unit_panel.add_child(Label(10, 10, f"{unit.name} (Lv.{unit.level})", None, 18, (255, 255, 255)))
            unit_panel.add_child(Label(10, 30, unit.unit_class, None, 16, (200, 200, 200)))
            
            # クリックハンドラを設定
            unit_index = i
            
            def make_handler(idx):
                return lambda: self.select_unit_for_skills(units[idx])
            
            unit_panel.handle_event = make_handler(unit_index)
            
            unit_select.add_child(unit_panel)
        
        # コンテンツ高さを更新
        unit_select.update_content_height()
        
        # スキル編集部分（右側）- 初期状態では非表示
        skill_panel = Panel(self.content_panel.width // 2 + 10, 0, self.content_panel.width // 2 - 10, self.content_panel.height,
                           (40, 40, 50), None, 0, 220)
        self.content_panel.add_child(skill_panel)
        skill_panel.add_child(Label(skill_panel.width // 2, 20, "ユニットを選択してください", None, 18, (200, 200, 200), None, "center"))
        
        # スキルパネルを保存
        self.skill_panel = skill_panel
    
    def show_info_tab(self):
        """噂を聞くタブの表示"""
        # 噂（ヒント）のリスト
        hints = [
            "北の森には珍しい武器が隠されているという噂がある...",
            "この街の南にある湖には、かつて竜が住んでいたという伝説が...",
            "東の山岳地帯では、古代の遺跡が発見されたらしい...",
            "最近、魔物の活動が活発化しているという報告が各地から届いている..."
        ]
        
        # タイトル
        self.content_panel.add_child(Label(self.content_panel.width // 2, 20, "酒場のマスターの話", None, 24, (255, 200, 150), None, "center"))
        
        # 噂のテキスト
        hint_y = 60
        for hint in hints:
            self.content_panel.add_child(Label(20, hint_y, hint, None, 18, (200, 200, 200)))
            hint_y += 40
    
    def select_unit_for_skills(self, unit):
       """スキル編集用のユニット選択"""
       self.skill_panel.clear_children()
       
       # ユニット情報
       self.skill_panel.add_child(Label(10, 10, f"ユニット: {unit.name}", None, 18, (255, 255, 255)))
       self.skill_panel.add_child(Label(10, 35, f"職業: {unit.unit_class}", None, 16, (200, 200, 200)))
       
       # 現在のスキルリスト
       self.skill_panel.add_child(Label(10, 60, "装備中スキル:", None, 18, (255, 255, 200)))
       
       if unit.skills:
           for i, skill in enumerate(unit.skills):
               skill_panel = Panel(10, 90 + i * 70, self.skill_panel.width - 20, 60, (50, 50, 60), (0, 0, 0), 1, 255)
               
               # スキル名
               skill_panel.add_child(Label(10, 10, skill.name, None, 18, (255, 255, 255)))
               
               # スキル説明（短く）
               desc = skill.description
               if len(desc) > 30:
                   desc = desc[:27] + "..."
               skill_panel.add_child(Label(10, 35, desc, None, 14, (200, 200, 200)))
               
               # 外すボタン
               remove_btn = Button(skill_panel.width - 70, 15, 60, 30, "外す", None, 16,
                                  (150, 60, 60), (255, 255, 255), (200, 80, 80),
                                  (0, 0, 0), 1, lambda s=skill: self.remove_skill(unit, s))
               skill_panel.add_child(remove_btn)
               
               self.skill_panel.add_child(skill_panel)
       else:
           self.skill_panel.add_child(Label(self.skill_panel.width // 2, 90, "スキルなし", None, 16, (180, 180, 180), None, "center"))
       
       # 装備可能なスキルリスト（ユニットが習得済みだが装備していないスキル）
       available_skills = self.get_available_skills(unit)
       
       if available_skills:
           self.skill_panel.add_child(Label(10, 210, "習得済みスキル:", None, 18, (255, 255, 200)))
           
           for i, skill in enumerate(available_skills):
               skill_panel = Panel(10, 240 + i * 70, self.skill_panel.width - 20, 60, (50, 50, 60), (0, 0, 0), 1, 255)
               
               # スキル名
               skill_panel.add_child(Label(10, 10, skill.name, None, 18, (255, 255, 255)))
               
               # スキル説明（短く）
               desc = skill.description
               if len(desc) > 30:
                   desc = desc[:27] + "..."
               skill_panel.add_child(Label(10, 35, desc, None, 14, (200, 200, 200)))
               
               # 装備ボタン
               equip_btn = Button(skill_panel.width - 70, 15, 60, 30, "装備", None, 16,
                                 (60, 100, 60), (255, 255, 255), (80, 150, 80),
                                 (0, 0, 0), 1, lambda s=skill: self.equip_skill(unit, s))
               skill_panel.add_child(equip_btn)
               
               self.skill_panel.add_child(skill_panel)
   
   def get_available_skills(self, unit):
       """ユニットが装備可能な（習得済みだが未装備の）スキルを取得"""
       # 実際のゲームでは習得済みスキルのリストからユニットの装備中スキルを除外
       available_skills = []
       
       # 仮のデータ（実際のゲームでは適切なデータソースから取得）
       from skills import create_sample_skills
       all_skills = create_sample_skills()
       
       # 現在装備していないスキルを抽出
       equipped_skill_names = [skill.name for skill in unit.skills]
       for skill in all_skills:
           if skill.name not in equipped_skill_names:
               # このスキルが習得可能か確認（レベルや職業による条件）
               if self.can_learn_skill(unit, skill):
                   available_skills.append(skill)
       
       return available_skills
   
   def can_learn_skill(self, unit, skill):
       """ユニットがスキルを習得可能か確認"""
       # 実際のゲームではより複雑な条件チェック
       # 例：レベル条件、職業条件、前提スキルなど
       
       # 仮の実装：レベルに基づく簡易チェック
       level_req = 1
       if "太陽" in skill.name or "月光" in skill.name:
           level_req = 10
       elif "連撃" in skill.name or "連続攻撃" in skill.name:
           level_req = 5
       
       return unit.level >= level_req
   
   def equip_skill(self, unit, skill):
       """スキルを装備"""
       # スキルスロット制限（仮に3つまで）
       if len(unit.skills) >= 3:
           # スキルスロット上限メッセージ（未実装）
           return
       
       # スキルを追加
       unit.add_skill(skill)
       
       # スキルパネルを更新
       self.select_unit_for_skills(unit)
   
   def remove_skill(self, unit, skill):
       """スキルを外す"""
       # スキルを削除
       unit.remove_skill(skill.name)
       
       # スキルパネルを更新
       self.select_unit_for_skills(unit)
   
   def view_support_conversation(self, char1, char2, level):
       """支援会話の閲覧"""
       # ゲームマネージャーの会話表示メソッドを呼び出す
       self.game_manager.view_support_conversation(char1, char2, level)
       
       # 閲覧後にタブを更新（会話が既読になるため）
       self.update_tab_content()
   
   def close_tavern(self):
       """酒場を閉じる"""
       if self.on_close:
           self.on_close()

================
File: title_screen.py
================
# title_screen.py
import pygame
from ui_system import Panel, Label, Button

class TitleScreen(Panel):
    def __init__(self, x, y, width, height, on_new_game=None, on_continue=None, on_options=None):
        super().__init__(x, y, width, height)
        self.on_new_game = on_new_game
        self.on_continue = on_continue
        self.on_options = on_options
        
        # タイトルロゴ（画像またはテキスト）
        title_label = Label(width // 2, 80, "ファイアーエムブレム風SRPG", None, 36, (255, 255, 0), None, "center")
        self.add_child(title_label)
        
        # ボタン
        start_btn = Button(width // 2 - 100, 200, 200, 40, "はじめから", None, 24, 
                           (60, 100, 60), (255, 255, 255), (80, 150, 80),
                           (0, 0, 0), 1, self.start_new_game)
        self.add_child(start_btn)
        
        continue_btn = Button(width // 2 - 100, 260, 200, 40, "つづきから", None, 24,
                             (60, 60, 100), (255, 255, 255), (80, 80, 150),
                             (0, 0, 0), 1, self.continue_game)
        self.add_child(continue_btn)
        
        options_btn = Button(width // 2 - 100, 320, 200, 40, "オプション", None, 24,
                            (100, 60, 60), (255, 255, 255), (150, 80, 80),
                            (0, 0, 0), 1, self.show_options)
        self.add_child(options_btn)
    
    def start_new_game(self):
        if self.on_new_game:
            self.on_new_game()
    
    def continue_game(self):
        if self.on_continue:
            self.on_continue()
    
    def show_options(self):
        if self.on_options:
            self.on_options()

================
File: town_screen.py
================
# town_screen.py
import pygame
from ui_system import Panel, Label, Button, ScrollPanel

class TownScreen(Panel):
    def __init__(self, x, y, width, height, game_manager, on_leave_town=None):
        super().__init__(x, y, width, height)
        self.game_manager = game_manager
        self.on_leave_town = on_leave_town
        
        # 街の名前
        town_label = Label(width // 2, 20, "冒険者の街", None, 30, (255, 255, 200), None, "center")
        self.add_child(town_label)
        
        # 施設ボタン
        facility_y = 80
        facility_spacing = 60
        
        weapon_shop = Button(width // 2 - 100, facility_y, 200, 40, "武器屋", None, 24,
                            (80, 80, 100), (255, 255, 255), (100, 100, 150),
                            (0, 0, 0), 1, self.open_weapon_shop)
        self.add_child(weapon_shop)
        
        item_shop = Button(width // 2 - 100, facility_y + facility_spacing, 200, 40, "アイテム屋", None, 24,
                          (80, 100, 80), (255, 255, 255), (100, 150, 100),
                          (0, 0, 0), 1, self.open_item_shop)
        self.add_child(item_shop)
        
        tavern = Button(width // 2 - 100, facility_y + facility_spacing * 2, 200, 40, "酒場", None, 24,
                       (100, 80, 60), (255, 255, 255), (150, 100, 80),
                       (0, 0, 0), 1, self.open_tavern)
        self.add_child(tavern)
        
        guild = Button(width // 2 - 100, facility_y + facility_spacing * 3, 200, 40, "冒険者ギルド", None, 24,
                      (60, 80, 100), (255, 255, 255), (80, 100, 150),
                      (0, 0, 0), 1, self.open_guild)
        self.add_child(guild)
        
        church = Button(width // 2 - 100, facility_y + facility_spacing * 4, 200, 40, "教会", None, 24,
                       (100, 60, 100), (255, 255, 255), (150, 80, 150),
                       (0, 0, 0), 1, self.open_church)
        self.add_child(church)
        
        save_shop = Button(width // 2 - 100, facility_y + facility_spacing * 5, 200, 40, "セーブ屋", None, 24,
                          (100, 100, 60), (255, 255, 255), (150, 150, 80),
                          (0, 0, 0), 1, self.open_save_shop)
        self.add_child(save_shop)
        
        leave_town = Button(width // 2 - 100, height - 60, 200, 40, "街を出る", None, 24,
                           (150, 60, 60), (255, 255, 255), (200, 80, 80),
                           (0, 0, 0), 1, self.leave_town)
        self.add_child(leave_town)
    
    def open_weapon_shop(self):
        # 武器屋画面を開く処理
        pass
    
    def open_item_shop(self):
        # アイテム屋画面を開く処理
        pass
    
    def open_tavern(self):
        # 酒場画面を開く処理
        pass
    
    def open_guild(self):
        # ギルド画面を開く処理
        pass
    
    def open_church(self):
        # 教会画面を開く処理
        pass
    
    def open_save_shop(self):
        # セーブ屋画面を開く処理
        pass
    
    def leave_town(self):
        if self.on_leave_town:
            self.on_leave_town()

================
File: ui_encoding_fix.py
================
# ui_encoding_fix.py
import pygame
import os
import sys

def init_font_system():
    """日本語フォントを使用するための初期化を行う"""
    pygame.init()
    
    # OSの判定
    if sys.platform.startswith('win'):
        # Windowsの場合、メイリオなどのフォントを使用
        font_names = ['メイリオ', 'Yu Gothic', 'MS Gothic', 'MS UI Gothic', 'Arial']
    elif sys.platform.startswith('darwin'):
        # macOSの場合、ヒラギノなどのフォントを使用
        font_names = ['Hiragino Sans', 'Hiragino Kaku Gothic ProN', 'Osaka', 'Arial']
    else:
        # Linuxなどの場合、さまざまなフォントを試す
        font_names = ['Noto Sans CJK JP', 'IPAGothic', 'VL Gothic', 'Droid Sans Japanese', 'Arial']
    
    # 使用可能な日本語フォントを探す
    available_fonts = pygame.font.get_fonts()
    system_font = None
    
    # 日本語フォントを探す
    for font_name in font_names:
        try:
            # Font関数はフォント名を小文字に変換して処理するため、
            # 元の名前と小文字バージョンの両方で試す
            font_lower = font_name.lower()
            if font_lower in available_fonts or font_name in available_fonts:
                test_font = pygame.font.Font(font_name, 24)
                # 日本語文字が描画できるかテスト
                test_render = test_font.render("日本語テスト", True, (0, 0, 0))
                if test_render.get_width() > 10:  # 正常に描画されていれば幅がある
                    system_font = font_name
                    break
        except:
            continue
    
    # 日本語フォントが見つからなかった場合、代替手段を試みる
    if system_font is None:
        # フォントファイルを直接指定する方法を試す（ファイルが存在する場合）
        font_paths = [
            "fonts/NotoSansCJKjp-Regular.ttf",  # プロジェクトにフォントファイルを追加した場合
            "fonts/meiryo.ttc",
            "/usr/share/fonts/truetype/noto/NotoSansCJK-Regular.ttc",
            "/System/Library/Fonts/ヒラギノ角ゴシック W3.ttc"
        ]
        
        for path in font_paths:
            if os.path.exists(path):
                try:
                    test_font = pygame.font.Font(path, 24)
                    test_render = test_font.render("日本語テスト", True, (0, 0, 0))
                    if test_render.get_width() > 10:
                        # カスタムフォントを使用
                        return {
                            'font_type': 'file',
                            'font_path': path
                        }
                except:
                    continue
    
    # 見つかった日本語フォントを返す
    return {
        'font_type': 'system',
        'font_name': system_font or 'Arial'  # 何も見つからなかった場合はArialを使用
    }

def create_font(size, font_info=None):
    """
    指定されたサイズと日本語対応フォント情報からフォントオブジェクトを作成
    
    Args:
        size: フォントサイズ
        font_info: フォント情報（init_font_system()の戻り値、Noneの場合は自動検出）
    
    Returns:
        pygame.font.Font: 日本語対応フォント
    """
    if font_info is None:
        font_info = init_font_system()
    
    if font_info['font_type'] == 'file':
        # フォントファイルを直接使用
        return pygame.font.Font(font_info['font_path'], size)
    else:
        # システムフォントを使用
        return pygame.font.Font(font_info['font_name'], size)

def create_ui_fonts(base_size=24):
    """
    UI用の標準フォントセットを作成
    
    Args:
        base_size: 基本フォントサイズ
        
    Returns:
        dict: さまざまなサイズのフォントを含む辞書
    """
    font_info = init_font_system()
    
    return {
        'small': create_font(int(base_size * 0.75), font_info),
        'normal': create_font(base_size, font_info),
        'large': create_font(int(base_size * 1.25), font_info),
        'title': create_font(int(base_size * 1.5), font_info),
        'header': create_font(int(base_size * 2), font_info)
    }

def patch_ui_system():
    """
    UI_systemモジュールの文字化け問題を修正するパッチ
    
    このメソッドを実行することで、既存のUIシステムを日本語対応にします。
    """
    from ui_system import Label, Button, Menu, Dialog
    
    # フォント情報の初期化
    font_info = init_font_system()
    
    # Label.__init__の元のメソッドを保存
    original_label_init = Label.__init__
    
    # Labelクラスを日本語対応に書き換え
    def new_label_init(self, x, y, text, font=None, font_size=24, 
                       color=(255, 255, 255), background_color=None, align="left"):
        # フォントが指定されていない場合は日本語対応フォントを使用
        if font is None:
            font = create_font(font_size, font_info)
        
        # 元のイニシャライザを呼び出し
        original_label_init(self, x, y, text, font, font_size, color, background_color, align)
    
    # Labelクラスのイニシャライザを差し替え
    Label.__init__ = new_label_init
    
    # Button.__init__の元のメソッドを保存
    original_button_init = Button.__init__
    
    # Buttonクラスを日本語対応に書き換え
    def new_button_init(self, x, y, width, height, text, font=None, font_size=24,
                        color=(128, 128, 128), text_color=(0, 0, 0),
                        hover_color=(255, 255, 255), border_color=(0, 0, 0),
                        border_width=1, callback=None):
        # フォントが指定されていない場合は日本語対応フォントを使用
        if font is None:
            font = create_font(font_size, font_info)
        
        # 元のイニシャライザを呼び出し
        original_button_init(self, x, y, width, height, text, font, font_size,
                             color, text_color, hover_color, border_color,
                             border_width, callback)
    
    # Buttonクラスのイニシャライザを差し替え
    Button.__init__ = new_button_init
    
    # Menu.__init__の元のメソッドを保存（あれば）
    if hasattr(Menu, '__init__'):
        original_menu_init = Menu.__init__
        
        # Menuクラスを日本語対応に書き換え
        def new_menu_init(self, x, y, width, item_height, items, callbacks=None,
                          color=(128, 128, 128), border_color=(0, 0, 0),
                          border_width=1, alpha=230, font=None, font_size=24):
            # フォントが指定されていない場合は日本語対応フォントを使用
            if font is None:
                font = create_font(font_size, font_info)
            
            # 元のイニシャライザを呼び出し
            original_menu_init(self, x, y, width, item_height, items, callbacks,
                              color, border_color, border_width, alpha, font, font_size)
        
        # Menuクラスのイニシャライザを差し替え
        Menu.__init__ = new_menu_init
    
    # Dialog.__init__の元のメソッドを保存（あれば）
    if hasattr(Dialog, '__init__'):
        original_dialog_init = Dialog.__init__
        
        # Dialogクラスを日本語対応に書き換え
        def new_dialog_init(self, x, y, width, height, title="", 
                            color=(128, 128, 128), border_color=(0, 0, 0),
                            border_width=2, alpha=230, font=None, font_size=24,
                            close_button=True):
            # フォントが指定されていない場合は日本語対応フォントを使用
            if font is None:
                font = create_font(font_size, font_info)
            
            # 元のイニシャライザを呼び出し
            original_dialog_init(self, x, y, width, height, title, 
                               color, border_color, border_width, alpha, 
                               font, font_size, close_button)
        
        # Dialogクラスのイニシャライザを差し替え
        Dialog.__init__ = new_dialog_init
    
    print("UI System has been patched for Japanese text support.")

def patch_renderer():
    """
    renderer.pyモジュールを日本語対応にするパッチ
    """
    try:
        from renderer import GameRenderer
        
        # フォント情報の初期化
        font_info = init_font_system()
        
        # GameRenderer.__init__の元のメソッドを保存
        original_renderer_init = GameRenderer.__init__
        
        # GameRendererクラスを日本語対応に書き換え
        def new_renderer_init(self, screen, game_manager):
            # 元のイニシャライザを呼び出し
            original_renderer_init(self, screen, game_manager)
            
            # フォントを日本語対応のものに差し替え
            self.font = create_font(24, font_info)
            self.small_font = create_font(18, font_info)
            self.title_font = create_font(28, font_info)
        
        # GameRendererクラスのイニシャライザを差し替え
        GameRenderer.__init__ = new_renderer_init
        
        print("Renderer has been patched for Japanese text support.")
    except ImportError:
        print("Renderer module not found, skipping patch.")

def patch_all():
    """
    すべてのUI関連モジュールを日本語対応にするパッチ
    """
    patch_ui_system()
    patch_renderer()
    
    # フォント情報を返す（他のモジュールでも使えるように）
    return init_font_system()

# エントリーポイントとして実行された場合
if __name__ == "__main__":
    font_info = patch_all()
    print(f"Japanese font support initialized: {font_info}")

================
File: ui_system.py
================
# ui_system.py
import pygame
from typing import List, Dict, Tuple, Callable, Optional
from constants import SCREEN_WIDTH, SCREEN_HEIGHT, GRID_SIZE, COLOR_BLACK, COLOR_WHITE, COLOR_BLUE, COLOR_RED, COLOR_GREEN, COLOR_YELLOW, COLOR_GRAY

class UIElement:
    """UIの基本クラス"""
    def __init__(self, x: int, y: int, width: int, height: int, visible: bool = True):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.visible = visible
        self.active = True
        self.parent = None
    
    def render(self, screen):
        """画面に描画する"""
        pass
    
    def handle_event(self, event) -> bool:
        """イベントを処理する。処理した場合はTrueを返す"""
        return False
    
    def update(self):
        """状態を更新する"""
        pass
    
    def set_position(self, x: int, y: int):
        """位置を設定する"""
        self.x = x
        self.y = y
    
    def set_size(self, width: int, height: int):
        """サイズを設定する"""
        self.width = width
        self.height = height
    
    def set_visible(self, visible: bool):
        """表示/非表示を設定する"""
        self.visible = visible
    
    def set_active(self, active: bool):
        """アクティブ/非アクティブを設定する"""
        self.active = active
    
    def contains_point(self, x: int, y: int) -> bool:
        """指定された座標がこの要素内にあるかどうかを判定"""
        return self.x <= x < self.x + self.width and self.y <= y < self.y + self.height


class Panel(UIElement):
    """パネル（コンテナ）クラス"""
    def __init__(self, x: int, y: int, width: int, height: int, 
                 color: Tuple[int, int, int] = COLOR_GRAY, 
                 border_color: Optional[Tuple[int, int, int]] = COLOR_BLACK,
                 border_width: int = 1,
                 alpha: int = 200):
        super().__init__(x, y, width, height)
        self.color = color
        self.border_color = border_color
        self.border_width = border_width
        self.alpha = alpha
        self.children = []
    
    def render(self, screen):
        if not self.visible:
            return
        
        # 半透明のパネルを描画
        s = pygame.Surface((self.width, self.height), pygame.SRCALPHA)
        s.fill((self.color[0], self.color[1], self.color[2], self.alpha))
        screen.blit(s, (self.x, self.y))
        
        # 枠線を描画
        if self.border_color:
            pygame.draw.rect(screen, self.border_color, 
                             (self.x, self.y, self.width, self.height), 
                             self.border_width)
        
        # 子要素を描画
        for child in self.children:
            if child.visible:
                child.render(screen)
    
    def handle_event(self, event) -> bool:
        if not self.visible or not self.active:
            return False
        
        # 子要素にイベントを伝播
        for child in reversed(self.children):  # 描画順と逆順に処理（前面の要素が優先）
            if child.active and child.handle_event(event):
                return True
        
        return False
    
    def update(self):
        if not self.visible or not self.active:
            return
        
        # 子要素を更新
        for child in self.children:
            child.update()
    
    def add_child(self, child):
        """子要素を追加"""
        self.children.append(child)
        child.parent = self
        return child
    
    def remove_child(self, child):
        """子要素を削除"""
        if child in self.children:
            self.children.remove(child)
            child.parent = None
    
    def clear_children(self):
        """すべての子要素を削除"""
        for child in self.children:
            child.parent = None
        self.children.clear()


class Label(UIElement):
    """テキストラベル"""
    def __init__(self, x: int, y: int, text: str, font=None, font_size: int = 24, 
                 color: Tuple[int, int, int] = COLOR_WHITE, 
                 background_color: Optional[Tuple[int, int, int]] = None,
                 align: str = "left"):  # left, center, right
        super().__init__(x, y, 0, 0)
        self.text = text
        self.font = font or pygame.font.Font(None, font_size)
        self.color = color
        self.background_color = background_color
        self.align = align
        self._update_size()
    
    def _update_size(self):
        """テキストサイズに基づいてサイズを更新"""
        text_surface = self.font.render(self.text, True, self.color)
        self.width = text_surface.get_width()
        self.height = text_surface.get_height()
    
    def render(self, screen):
        if not self.visible or not self.text:
            return
        
        # テキストをレンダリング
        text_surface = self.font.render(self.text, True, self.color)
        
        # 背景を描画（指定されている場合）
        if self.background_color:
            pygame.draw.rect(screen, self.background_color, 
                             (self.x, self.y, self.width, self.height))
        
        # アライメントに応じて位置を調整
        x_pos = self.x
        if self.align == "center":
            x_pos = self.x - self.width // 2
        elif self.align == "right":
            x_pos = self.x - self.width
        
        # テキストを描画
        screen.blit(text_surface, (x_pos, self.y))
    
    def set_text(self, text: str):
        """テキストを設定し、サイズを更新"""
        self.text = text
        self._update_size()


class Button(UIElement):
    """ボタン"""
    def __init__(self, x: int, y: int, width: int, height: int, 
                 text: str, font=None, font_size: int = 24,
                 color: Tuple[int, int, int] = COLOR_GRAY,
                 text_color: Tuple[int, int, int] = COLOR_BLACK,
                 hover_color: Tuple[int, int, int] = COLOR_WHITE,
                 border_color: Optional[Tuple[int, int, int]] = COLOR_BLACK,
                 border_width: int = 1,
                 callback: Optional[Callable] = None):
        super().__init__(x, y, width, height)
        self.text = text
        self.font = font or pygame.font.Font(None, font_size)
        self.color = color
        self.text_color = text_color
        self.hover_color = hover_color
        self.border_color = border_color
        self.border_width = border_width
        self.callback = callback
        self.hovered = False
        self.pressed = False
    
    def render(self, screen):
        if not self.visible:
            return
        
        # ボタンの背景
        current_color = self.hover_color if self.hovered else self.color
        pygame.draw.rect(screen, current_color, (self.x, self.y, self.width, self.height))
        
        # 枠線
        if self.border_color:
            pygame.draw.rect(screen, self.border_color, 
                             (self.x, self.y, self.width, self.height), 
                             self.border_width)
        
        # テキスト
        text_surface = self.font.render(self.text, True, self.text_color)
        text_x = self.x + (self.width - text_surface.get_width()) // 2
        text_y = self.y + (self.height - text_surface.get_height()) // 2
        screen.blit(text_surface, (text_x, text_y))
    
    def handle_event(self, event) -> bool:
        if not self.visible or not self.active:
            return False
        
        if event.type == pygame.MOUSEMOTION:
            self.hovered = self.contains_point(*event.pos)
            return self.hovered
        
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if self.contains_point(*event.pos):
                self.pressed = True
                return True
        
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            was_pressed = self.pressed
            self.pressed = False
            if was_pressed and self.contains_point(*event.pos) and self.callback:
                self.callback()
                return True
        
        return False


class ImageButton(Button):
    """画像ボタン"""
    def __init__(self, x: int, y: int, width: int, height: int, 
                 image, hover_image=None,
                 text: str = "", font=None, font_size: int = 24,
                 text_color: Tuple[int, int, int] = COLOR_BLACK,
                 border_color: Optional[Tuple[int, int, int]] = None,
                 border_width: int = 1,
                 callback: Optional[Callable] = None):
        super().__init__(x, y, width, height, text, font, font_size,
                         COLOR_GRAY, text_color, COLOR_GRAY,
                         border_color, border_width, callback)
        self.image = image
        self.hover_image = hover_image or image
    
    def render(self, screen):
        if not self.visible:
            return
        
        # 画像の描画
        current_image = self.hover_image if self.hovered else self.image
        # 画像をボタンのサイズに合わせる
        scaled_image = pygame.transform.scale(current_image, (self.width, self.height))
        screen.blit(scaled_image, (self.x, self.y))
        
        # 枠線
        if self.border_color:
            pygame.draw.rect(screen, self.border_color, 
                             (self.x, self.y, self.width, self.height), 
                             self.border_width)
        
        # テキスト
        if self.text:
            text_surface = self.font.render(self.text, True, self.text_color)
            text_x = self.x + (self.width - text_surface.get_width()) // 2
            text_y = self.y + (self.height - text_surface.get_height()) // 2
            screen.blit(text_surface, (text_x, text_y))


class ProgressBar(UIElement):
    """プログレスバー（HP表示などに使用）"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 value: float = 1.0, max_value: float = 1.0,
                 color: Tuple[int, int, int] = COLOR_GREEN,
                 background_color: Tuple[int, int, int] = COLOR_GRAY,
                 border_color: Optional[Tuple[int, int, int]] = COLOR_BLACK,
                 border_width: int = 1,
                 show_text: bool = False,
                 font=None, font_size: int = 18):
        super().__init__(x, y, width, height)
        self.value = value
        self.max_value = max_value
        self.color = color
        self.background_color = background_color
        self.border_color = border_color
        self.border_width = border_width
        self.show_text = show_text
        self.font = font or pygame.font.Font(None, font_size)
    
    def render(self, screen):
        if not self.visible:
            return
        
        # 背景
        pygame.draw.rect(screen, self.background_color, 
                         (self.x, self.y, self.width, self.height))
        
        # プログレスバー
        progress_width = int(self.width * (self.value / self.max_value)) if self.max_value > 0 else 0
        if progress_width > 0:
            pygame.draw.rect(screen, self.color, 
                             (self.x, self.y, progress_width, self.height))
        
        # 枠線
        if self.border_color:
            pygame.draw.rect(screen, self.border_color, 
                             (self.x, self.y, self.width, self.height), 
                             self.border_width)
        
        # テキスト
        if self.show_text:
            text = f"{int(self.value)}/{int(self.max_value)}"
            text_surface = self.font.render(text, True, COLOR_BLACK)
            text_x = self.x + (self.width - text_surface.get_width()) // 2
            text_y = self.y + (self.height - text_surface.get_height()) // 2
            screen.blit(text_surface, (text_x, text_y))
    
    def set_value(self, value: float):
        """値を設定"""
        self.value = max(0, min(value, self.max_value))
    
    def set_max_value(self, max_value: float):
        """最大値を設定"""
        self.max_value = max(0.1, max_value)
        self.value = min(self.value, self.max_value)


class ScrollPanel(Panel):
    """スクロール可能なパネル"""
    def __init__(self, x: int, y: int, width: int, height: int, 
                 content_height: int,
                 color: Tuple[int, int, int] = COLOR_GRAY, 
                 border_color: Optional[Tuple[int, int, int]] = COLOR_BLACK,
                 border_width: int = 1,
                 alpha: int = 200):
        super().__init__(x, y, width, height, color, border_color, border_width, alpha)
        self.content_height = max(content_height, height)
        self.scroll_y = 0
        self.max_scroll = max(0, content_height - height)
        self.dragging = False
        self.drag_start_y = 0
        self.drag_start_scroll = 0
    
    def render(self, screen):
        if not self.visible:
            return
        
        # パネル自体を描画
        super().render(screen)
        
        # スクロールバーを描画
        if self.content_height > self.height:
            bar_height = max(20, int(self.height * (self.height / self.content_height)))
            bar_y = self.y + int(self.scroll_y / self.max_scroll * (self.height - bar_height))
            
            pygame.draw.rect(screen, COLOR_BLACK, 
                             (self.x + self.width - 10, self.y, 10, self.height))
            pygame.draw.rect(screen, COLOR_WHITE, 
                             (self.x + self.width - 8, bar_y, 6, bar_height))
    
    def handle_event(self, event) -> bool:
        if not self.visible or not self.active:
            return False
        
        # スクロールイベント
        if event.type == pygame.MOUSEBUTTONDOWN and self.contains_point(*event.pos):
            if event.button == 4:  # マウスホイール上回転
                self.scroll_y = max(0, self.scroll_y - 20)
                return True
            elif event.button == 5:  # マウスホイール下回転
                self.scroll_y = min(self.max_scroll, self.scroll_y + 20)
                return True
            elif event.button == 1:  # 左クリック
                # スクロールバー領域をクリックした場合はドラッグ開始
                if self.contains_point(*event.pos) and event.pos[0] > self.x + self.width - 10:
                    self.dragging = True
                    self.drag_start_y = event.pos[1]
                    self.drag_start_scroll = self.scroll_y
                    return True
        
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            if self.dragging:
                self.dragging = False
                return True
        
        elif event.type == pygame.MOUSEMOTION and self.dragging:
            # スクロールバーのドラッグ
            drag_distance = event.pos[1] - self.drag_start_y
            self.scroll_y = max(0, min(self.max_scroll,
                                     self.drag_start_scroll + drag_distance * self.max_scroll / self.height))
            return True
        
        # 子要素のイベント処理
        for child in reversed(self.children):  # 描画順と逆順に処理
            if child.active and child.handle_event(event):
                return True
        
        return False
    
    def add_child(self, child):
        """子要素を追加し、コンテンツ高さを更新"""
        super().add_child(child)
        child_bottom = child.y + child.height
        if child_bottom > self.content_height:
            self.content_height = child_bottom
            self.max_scroll = max(0, self.content_height - self.height)
        return child
    
    def update_content_height(self):
        """子要素に基づいてコンテンツ高さを更新"""
        max_height = 0
        for child in self.children:
            child_bottom = child.y + child.height
            if child_bottom > max_height:
                max_height = child_bottom
        
        self.content_height = max(max_height, self.height)
        self.max_scroll = max(0, self.content_height - self.height)


class Menu(Panel):
    """メニュー（選択肢リスト）"""
    def __init__(self, x: int, y: int, width: int, item_height: int,
                 items: List[str], 
                 callbacks: List[Callable] = None,
                 color: Tuple[int, int, int] = COLOR_GRAY,
                 border_color: Optional[Tuple[int, int, int]] = COLOR_BLACK,
                 border_width: int = 1,
                 alpha: int = 230,
                 font=None, font_size: int = 24):
        height = item_height * len(items)
        super().__init__(x, y, width, height, color, border_color, border_width, alpha)
        
        self.items = items
        self.callbacks = callbacks or [None] * len(items)
        self.item_height = item_height
        self.selected_index = -1
        self.font = font or pygame.font.Font(None, font_size)
        
        # ボタンの生成
        for i, (item, callback) in enumerate(zip(items, self.callbacks)):
            button = Button(0, i * item_height, width, item_height,
                           item, self.font, font_size,
                           color, COLOR_BLACK, (220, 220, 220),
                           None, 0, callback)
            self.add_child(button)
    
    def render(self, screen):
        if not self.visible:
            return
            
        super().render(screen)
    
    def handle_event(self, event) -> bool:
        if not self.visible or not self.active:
            return False
            
        return super().handle_event(event)


class Dialog(Panel):
    """ダイアログ（メッセージウィンドウなど）"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 title: str = "",
                 color: Tuple[int, int, int] = COLOR_GRAY,
                 border_color: Optional[Tuple[int, int, int]] = COLOR_BLACK,
                 border_width: int = 2,
                 alpha: int = 230,
                 font=None, font_size: int = 24,
                 close_button: bool = True):
        super().__init__(x, y, width, height, color, border_color, border_width, alpha)
        
        self.title = title
        self.font = font or pygame.font.Font(None, font_size)
        
        # タイトルバー
        if title:
            title_height = 30
            self.title_bar = Panel(0, 0, width, title_height, (80, 80, 80), None, 0)
            self.add_child(self.title_bar)
            
            # タイトルテキスト
            title_label = Label(10, 5, title, self.font, font_size, COLOR_WHITE)
            self.title_bar.add_child(title_label)
            
            # 閉じるボタン
            if close_button:
                close_btn = Button(width - 30, 5, 20, 20, "×", None, 20,
                                  (200, 50, 50), COLOR_WHITE, (255, 100, 100),
                                  None, 0, self.close)
                self.title_bar.add_child(close_btn)
        
    def close(self):
        """ダイアログを閉じる"""
        self.visible = False


class BattleForecast(Panel):
    """戦闘予測ウィンドウ"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 attacker=None, defender=None,
                 color: Tuple[int, int, int] = COLOR_GRAY,
                 border_color: Optional[Tuple[int, int, int]] = COLOR_BLACK,
                 border_width: int = 2,
                 alpha: int = 230,
                 font=None, font_size: int = 24):
        super().__init__(x, y, width, height, color, border_color, border_width, alpha)
        
        self.attacker = attacker
        self.defender = defender
        self.font = font or pygame.font.Font(None, font_size)
        self.small_font = pygame.font.Font(None, 20)
        
        # タイトル
        title_label = Label(width//2, 10, "戦闘予測", self.font, font_size, COLOR_WHITE, None, "center")
        self.add_child(title_label)
        
        self.setup_ui()
    
    def setup_ui(self):
        """UIのセットアップ"""
        if not self.attacker or not self.defender:
            return
            
        # 左側（攻撃側）
        left_x = 20
        self.add_child(Label(left_x, 50, self.attacker.name, self.font, 28, COLOR_BLUE))
        self.add_child(Label(left_x, 80, f"HP: {self.attacker.current_hp}/{self.attacker.max_hp}", self.small_font))
        
        if self.attacker.equipped_weapon:
            weapon_name = self.attacker.equipped_weapon.name
            self.add_child(Label(left_x, 100, f"武器: {weapon_name}", self.small_font))
        
        # 攻撃力・命中・必殺
        self.add_child(Label(left_x, 120, f"攻撃力: {self.attacker.get_attack_power()}", self.small_font))
        hit_rate = min(100, max(0, self.attacker.get_hit_rate() - self.defender.get_avoid()))
        self.add_child(Label(left_x, 140, f"命中率: {hit_rate}%", self.small_font))
        crit_rate = max(0, self.attacker.get_critical_rate() - self.defender.luck)
        self.add_child(Label(left_x, 160, f"必殺率: {crit_rate}%", self.small_font))
        
        # 右側（防御側）
        right_x = self.width - 150
        self.add_child(Label(right_x, 50, self.defender.name, self.font, 28, COLOR_RED))
        self.add_child(Label(right_x, 80, f"HP: {self.defender.current_hp}/{self.defender.max_hp}", self.small_font))
        
        if self.defender.equipped_weapon:
            weapon_name = self.defender.equipped_weapon.name
            self.add_child(Label(right_x, 100, f"武器: {weapon_name}", self.small_font))
        
        # 防御側の反撃
        counter_text = "反撃あり" if self.can_counter() else "反撃なし"
        self.add_child(Label(right_x, 120, counter_text, self.small_font))
        
        if self.can_counter():
            # 攻撃力・命中・必殺（防御側）
            self.add_child(Label(right_x, 140, f"攻撃力: {self.defender.get_attack_power()}", self.small_font))
            hit_rate = min(100, max(0, self.defender.get_hit_rate() - self.attacker.get_avoid()))
            self.add_child(Label(right_x, 160, f"命中率: {hit_rate}%", self.small_font))
            crit_rate = max(0, self.defender.get_critical_rate() - self.attacker.luck)
            self.add_child(Label(right_x, 180, f"必殺率: {crit_rate}%", self.small_font))
            
        # 攻撃回数
        attacker_hits = "2回" if self.attacker.can_double_attack(self.defender) else "1回"
        defender_hits = "2回" if self.can_counter() and self.defender.can_double_attack(self.attacker) else "1回" if self.can_counter() else "0回"
        
        center_x = self.width // 2
        self.add_child(Label(center_x, 130, "攻撃回数", self.small_font, COLOR_WHITE, None, "center"))
        self.add_child(Label(center_x - 40, 150, attacker_hits, self.small_font, COLOR_BLUE, None, "center"))
        self.add_child(Label(center_x + 40, 150, defender_hits, self.small_font, COLOR_RED, None, "center"))
        
        # 装飾
        pygame.draw.line(screen, COLOR_WHITE, (center_x, 145), (center_x, 165), 1)
    
    def can_counter(self):
        """防御側が反撃可能か判定"""
        if not self.defender or not self.defender.equipped_weapon:
            return False
            
        range_diff = abs(self.attacker.x - self.defender.x) + abs(self.attacker.y - self.defender.y)
        return self.defender.equipped_weapon.range_min <= range_diff <= self.defender.equipped_weapon.range_max
    
    def update_forecast(self, attacker, defender):
        """戦闘予測を更新"""
        self.attacker = attacker
        self.defender = defender
        self.clear_children()
        self.setup_ui()


class StatusWindow(Panel):
    """ステータスウィンドウ"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 unit=None,
                 color: Tuple[int, int, int] = COLOR_GRAY,
                 border_color: Optional[Tuple[int, int, int]] = COLOR_BLACK,
                 border_width: int = 2,
                 alpha: int = 230,
                 font=None, font_size: int = 24):
        super().__init__(x, y, width, height, color, border_color, border_width, alpha)
        
        self.unit = unit
        self.font = font or pygame.font.Font(None, font_size)
        self.title_font = pygame.font.Font(None, 28)
        self.small_font = pygame.font.Font(None, 20)
        
        self.setup_ui()
    
    def setup_ui(self):
        """UIのセットアップ"""
        if not self.unit:
            self.add_child(Label(self.width//2, 10, "ユニット未選択", self.font, 24, COLOR_WHITE, None, "center"))
            return
            
        # ユニット名と職業
        self.add_child(Label(self.width//2, 10, self.unit.name, self.title_font, 28, COLOR_WHITE, None, "center"))
        self.add_child(Label(self.width//2, 40, f"Lv {self.unit.level} {self.unit.unit_class}", self.font, 24, COLOR_WHITE, None, "center"))
        
        # HP表示
        hp_bar = ProgressBar(20, 70, self.width - 40, 20, 
                            self.unit.current_hp, self.unit.max_hp,
                            COLOR_GREEN, COLOR_GRAY, COLOR_BLACK, 1, True)
        self.add_child(hp_bar)
        
        # 主要ステータス
        stats_x1 = 20
        stats_x2 = self.width // 2 + 10
        stats_y = 100
        
        # 左側のステータス
        self.add_child(Label(stats_x1, stats_y, f"力: {self.unit.strength}", self.small_font))
        self.add_child(Label(stats_x1, stats_y + 20, f"魔力: {self.unit.magic}", self.small_font))
        self.add_child(Label(stats_x1, stats_y + 40, f"技: {self.unit.skill}", self.small_font))
        self.add_child(Label(stats_x1, stats_y + 60, f"速さ: {self.unit.speed}", self.small_font))
        
        # 右側のステータス
        self.add_child(Label(stats_x2, stats_y, f"幸運: {self.unit.luck}", self.small_font))
        self.add_child(Label(stats_x2, stats_y + 20, f"守備: {self.unit.defense}", self.small_font))
        self.add_child(Label(stats_x2, stats_y + 40, f"魔防: {self.unit.resistance}", self.small_font))
        self.add_child(Label(stats_x2, stats_y + 60, f"移動: {self.unit.movement}", self.small_font))
        
        # 戦闘関連ステータス
        battle_y = stats_y + 90
        if self.unit.equipped_weapon:
            self.add_child(Label(stats_x1, battle_y, f"武器: {self.unit.equipped_weapon.name}", self.small_font))
            self.add_child(Label(stats_x1, battle_y + 20, f"攻撃力: {self.unit.get_attack_power()}", self.small_font))
            self.add_child(Label(stats_x1, battle_y + 40, f"命中率: {self.unit.get_hit_rate()}", self.small_font))
            self.add_child(Label(stats_x2, battle_y + 20, f"回避率: {self.unit.get_avoid()}", self.small_font))
            self.add_child(Label(stats_x2, battle_y + 40, f"必殺率: {self.unit.get_critical_rate()}", self.small_font))
        
        # スキル表示
        skill_y = battle_y + 70
        self.add_child(Label(self.width // 2, skill_y, "スキル", self.font, 24, COLOR_WHITE, None, "center"))
        
        if self.unit.skills:
            skill_list_y = skill_y + 30
            for i, skill in enumerate(self.unit.skills):
                self.add_child(Label(stats_x1, skill_list_y + i * 20, f"・{skill.name}", self.small_font))
                # スキル説明文（長い場合は省略）
                desc = skill.description
                if len(desc) > 30:
                    desc = desc[:27] + "..."
                self.add_child(Label(stats_x1 + 100, skill_list_y + i * 20, desc, self.small_font))
        else:
            self.add_child(Label(self.width // 2, skill_y + 30, "なし", self.small_font, 20, COLOR_WHITE, None, "center"))
    
    def update_unit(self, unit):
        """ユニット情報を更新"""
        self.unit = unit
        self.clear_children()
        self.setup_ui()


class ActionMenu(Menu):
    """行動選択メニュー"""
    def __init__(self, x: int, y: int, width: int = 100, item_height: int = 30,
                 game_manager = None):
        # 基本的な行動メニュー項目
        actions = ["攻撃", "待機", "アイテム", "キャンセル"]
        
        # ゲームマネージャー参照を保持
        self.game_manager = game_manager

        # 救出関連の行動を追加
        self.rescue_actions = ["救出", "降ろす", "捕獲", "捕虜", "交換"]

        # コールバック関数の設定
        callbacks = [
            lambda: self.on_action_selected("attack"),
            lambda: self.on_action_selected("wait"),
            lambda: self.on_action_selected("item"),
            lambda: self.on_action_selected("cancel")
        ]
        
        super().__init__(x, y, width, item_height, actions, callbacks)
    
    def on_action_selected(self, action):
        """行動が選択されたときの処理"""
        if not self.game_manager:
            return
            
        if action == "attack":
            self.game_manager.select_action("attack")
        elif action == "wait":
            self.game_manager.select_action("wait")
        elif action == "item":
            # アイテム選択画面の表示（未実装）
            pass
        elif action == "cancel":
            # 移動をキャンセル
            if self.game_manager.selected_unit:
                # 元の位置に戻す処理が必要
                pass
        
        # メニューを閉じる
        self.visible = False

    def update_actions(self, unit):
        """ユニットの状態に応じて行動リストを更新"""
        actions = ["攻撃", "待機", "アイテム"]
        
        # 救出可能なユニットが隣接しているかチェック
        can_rescue = False
        adjacent_units = self.game_manager.get_adjacent_units(unit)
        for adj_unit in adjacent_units:
            if unit.can_rescue(adj_unit):
                can_rescue = True
                break
        
        # 救出中のユニットがいる場合
        if unit.rescuing:
            actions.insert(0, "降ろす")
            actions.insert(1, "交換")
        
        # 救出可能なユニットがいる場合
        elif can_rescue:
            actions.insert(0, "救出")
        
        # 捕獲可能な敵ユニットがいる場合
        can_capture = False
        can_persuade = False
        for adj_unit in adjacent_units:
            if adj_unit.team != unit.team:
                can_capture = True
                if adj_unit.current_hp < 10:
                    can_persuade = True
                break
        
        if can_capture:
            actions.insert(0, "捕獲")
        
        if can_persuade:
            actions.insert(0, "捕虜")
        
        # キャンセルオプションは常に最後
        actions.append("キャンセル")
        
        # アクションをセット
        self.items = actions
        self.setup_buttons()

class UnitMenu(ScrollPanel):
    """ユニット一覧メニュー"""
    def __init__(self, x: int, y: int, width: int, height: int,
                 units=None, on_unit_selected=None):
        super().__init__(x, y, width, height, height)
        
        self.units = units or []
        self.on_unit_selected = on_unit_selected
        self.unit_height = 60  # 各ユニット表示の高さ
        
        self.setup_ui()
    
    def setup_ui(self):
        """UIのセットアップ"""
        # タイトル
        title_label = Label(self.width // 2, 10, "ユニット一覧", None, 28, COLOR_WHITE, None, "center")
        self.add_child(title_label)
        
        # ユニットリスト
        for i, unit in enumerate(self.units):
            unit_panel = Panel(10, 40 + i * self.unit_height, self.width - 20, self.unit_height - 5,
                            (60, 60, 60) if unit.team == 0 else (80, 40, 40))
            
            # ユニット名とHP
            unit_panel.add_child(Label(10, 5, unit.name, None, 20, COLOR_WHITE))
            unit_panel.add_child(Label(10, 25, f"Lv {unit.level} {unit.unit_class}", None, 16, COLOR_WHITE))
            
            # HPバー
            hp_bar = ProgressBar(100, 7, self.width - 150, 15, 
                                unit.current_hp, unit.max_hp, 
                                COLOR_GREEN, COLOR_GRAY, COLOR_BLACK, 1, True)
            unit_panel.add_child(hp_bar)
            
            # クリックハンドラ設定（修正部分）
            unit_index = i  # クロージャのためにインデックスを保存
            
            def make_handler(idx):
                # イベント引数を受け取るように修正
                return lambda event=None: self.handle_unit_selection(idx)
                    
            unit_panel.handle_event = make_handler(unit_index)
            
            self.add_child(unit_panel)
        
        # コンテンツ高さの更新
        self.update_content_height()
    
    def handle_unit_selection(self, index):
        """ユニットが選択されたときの処理"""
        if self.on_unit_selected and 0 <= index < len(self.units):
            self.on_unit_selected(self.units[index])
            return True
        return False
    
    def update_units(self, units):
        """ユニットリストを更新"""
        self.units = units
        self.clear_children()
        self.setup_ui()


class MapController:
    """マップコントロール（移動・攻撃などのマップ操作を担当）"""
    def __init__(self, game_manager, ui_manager):
        self.game_manager = game_manager
        self.ui_manager = ui_manager
        
        # 移動と攻撃の範囲を視覚的に表示するためのサーフェス
        self.move_surface = None
        self.attack_surface = None
        
        # ユニット選択・移動など状態関連
        self.hover_x = -1
        self.hover_y = -1
    
    def update(self):
        """状態の更新"""
        # マウス位置の更新
        mouse_x, mouse_y = pygame.mouse.get_pos()
        self.hover_x = mouse_x // GRID_SIZE
        self.hover_y = mouse_y // GRID_SIZE
    
    def render(self, screen):
        """マップコントロールの描画"""
        # 移動範囲の描画
        if self.game_manager.phase == "move_unit" and self.game_manager.move_targets:
            if not self.move_surface:
                self._create_move_surface()
            screen.blit(self.move_surface, (0, 0))
        else:
            self.move_surface = None
        
        # 攻撃範囲の描画
        if self.game_manager.phase == "select_attack_target" and self.game_manager.attack_targets:
            if not self.attack_surface:
                self._create_attack_surface()
            screen.blit(self.attack_surface, (0, 0))
        else:
            self.attack_surface = None
        
        # ホバー位置のハイライト
        if self._is_valid_hover_position():
            hover_rect = pygame.Rect(self.hover_x * GRID_SIZE, self.hover_y * GRID_SIZE, GRID_SIZE, GRID_SIZE)
            pygame.draw.rect(screen, COLOR_YELLOW, hover_rect, 2)
    
    def _create_move_surface(self):
        """移動範囲表示用のサーフェスを作成"""
        self.move_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        for x, y in self.game_manager.move_targets:
            rect = pygame.Rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE)
            pygame.draw.rect(self.move_surface, (0, 0, 255, 128), rect)
    
    def _create_attack_surface(self):
        """攻撃範囲表示用のサーフェスを作成"""
        self.attack_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        for x, y in self.game_manager.attack_targets:
            rect = pygame.Rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE)
            pygame.draw.rect(self.attack_surface, (255, 0, 0, 128), rect)
    
    def _is_valid_hover_position(self):
        """現在のホバー位置が有効かどうかをチェック"""
        return (0 <= self.hover_x < self.game_manager.game_map.cols and 
                0 <= self.hover_y < self.game_manager.game_map.rows)
    
    def handle_click(self, x, y):
        """マップ上のクリックを処理"""
        # 現在のフェーズに応じた処理
        if self.game_manager.phase == "select_unit":
            self.game_manager.select_unit(x, y)
        elif self.game_manager.phase == "move_unit":
            if self.game_manager.move_selected_unit(x, y):
                # 移動が成功した場合
                # 攻撃対象がいるかチェック
                enemies = self.game_manager.game_map.get_enemies_in_range(
                    self.game_manager.selected_unit,
                    self.game_manager.attack_targets
                )
                
                if enemies:
                    # 行動メニューを表示
                    self.ui_manager.show_action_menu(x * GRID_SIZE, y * GRID_SIZE)
                else:
                    # 敵がいない場合は自動的に待機
                    self.game_manager.select_action("wait")
            else:
                # 移動先に別のユニットがいるか、移動範囲外の場合
                target_unit = self.game_manager.game_map.get_unit_at(x, y)
                if target_unit:
                    if target_unit.team == self.game_manager.turn_player:
                        # 味方ユニットの場合は選択し直し
                        self.game_manager.select_unit(x, y)
                    else:
                        # 敵ユニットの場合は情報表示
                        self.ui_manager.show_unit_info(target_unit)
        
        elif self.game_manager.phase == "select_attack_target":
            self.game_manager.select_attack_target(x, y)


class UIManager:
    """UI管理クラス（ゲーム全体のUI要素を管理）"""
    def __init__(self, screen, game_manager):
        self.screen = screen
        self.game_manager = game_manager
        
        # フォント初期化
        self.font = pygame.font.Font(None, 24)
        self.small_font = pygame.font.Font(None, 20)
        self.large_font = pygame.font.Font(None, 28)
        
        # UI要素
        self.ui_elements = []
        
        # マップコントローラー
        self.map_controller = MapController(game_manager, self)
        
        # UI要素の初期化
        self._init_ui()
    
    def _init_ui(self):
        """UI要素の初期化"""
        # ステータスバー（画面上部）
        status_bar = Panel(0, 0, SCREEN_WIDTH, 30, (30, 30, 30), None, 0)
        
        # ターン表示
        turn_label = Label(10, 5, "", self.font, 24, COLOR_WHITE)
        status_bar.add_child(turn_label)
        self.turn_label = turn_label
        
        # フェーズ表示
        phase_label = Label(SCREEN_WIDTH - 10, 5, "", self.font, 24, COLOR_WHITE, None, "right")
        status_bar.add_child(phase_label)
        self.phase_label = phase_label
        
        self.ui_elements.append(status_bar)
        
        # 行動メニュー（初期状態は非表示）
        action_menu = ActionMenu(0, 0, 120, 30, self.game_manager)
        action_menu.visible = False
        self.ui_elements.append(action_menu)
        self.action_menu = action_menu
        
        # 戦闘予測ウィンドウ（初期状態は非表示）
        battle_forecast = BattleForecast(SCREEN_WIDTH // 2 - 175, SCREEN_HEIGHT // 2 - 100, 350, 200)
        battle_forecast.visible = False
        self.ui_elements.append(battle_forecast)
        self.battle_forecast = battle_forecast
        
        # ユニット情報ウィンドウ（初期状態は非表示）
        unit_info = StatusWindow(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2 - 150, 300, 300)
        unit_info.visible = False
        self.ui_elements.append(unit_info)
        self.unit_info = unit_info
        
        # ユニット一覧ボタン
        unit_list_btn = Button(SCREEN_WIDTH - 110, 40, 100, 30, "ユニット一覧", self.font, 20,
                              COLOR_GRAY, COLOR_BLACK, COLOR_WHITE, COLOR_BLACK, 1,
                              self.toggle_unit_list)
        self.ui_elements.append(unit_list_btn)
        
        # ユニット一覧（初期状態は非表示）
        unit_list = UnitMenu(SCREEN_WIDTH - 220, 80, 210, 180, [], self.on_unit_list_selection)
        unit_list.visible = False
        self.ui_elements.append(unit_list)
        self.unit_list = unit_list
        
        # エンドターンボタン
        end_turn_btn = Button(SCREEN_WIDTH - 110, SCREEN_HEIGHT - 40, 100, 30, "ターン終了", self.font, 20,
                             COLOR_GRAY, COLOR_BLACK, COLOR_WHITE, COLOR_BLACK, 1,
                             self.end_turn)
        self.ui_elements.append(end_turn_btn)
        
        # バトルログウィンドウ（初期状態は非表示）
        battle_log = ScrollPanel(10, SCREEN_HEIGHT - 100, 300, 90, 200, (30, 30, 30), COLOR_BLACK, 1, 200)
        battle_log.visible = False
        self.ui_elements.append(battle_log)
        self.battle_log = battle_log
    
    def update(self):
        """状態の更新"""
        # ターン表示の更新
        self.turn_label.set_text(f"ターン {self.game_manager.current_turn+1} - {'プレイヤー' if self.game_manager.turn_player == 0 else '敵'}")
        
        # フェーズ表示の更新
        phase_texts = {
            "select_unit": "ユニット選択",
            "move_unit": "移動先選択",
            "select_action": "行動選択",
            "select_attack_target": "攻撃対象選択"
        }
        self.phase_label.set_text(phase_texts.get(self.game_manager.phase, ""))
        
        # ユニット一覧の更新（表示中の場合）
        if self.unit_list.visible:
            self.unit_list.update_units(self.game_manager.game_map.units)
        
        # マップコントローラーの更新
        self.map_controller.update()
        
        # 各UI要素の更新
        for element in self.ui_elements:
            element.update()
    
    def render(self):
        """UI要素の描画"""
        # マップコントローラーの描画
        self.map_controller.render(self.screen)
        
        # 選択中のユニットを強調表示
        if self.game_manager.selected_unit:
            unit = self.game_manager.selected_unit
            rect = pygame.Rect(unit.x * GRID_SIZE, unit.y * GRID_SIZE, GRID_SIZE, GRID_SIZE)
            pygame.draw.rect(self.screen, COLOR_YELLOW, rect, 3)
        
        # UI要素の描画
        for element in self.ui_elements:
            if element.visible:
                element.render(self.screen)
        
        # 戦闘アニメーション
        if self.game_manager.combat_animation_active:
            self._render_combat_animation()
    
    def _render_combat_animation(self):
        """戦闘アニメーションの描画"""
        # 既存のrenderer.pyのコードを参照
        if self.game_manager.combat_results:
            # 実装はrenderer.pyに既存のものを活用
            pass
    
    def handle_event(self, event):
        """イベント処理"""
        # UI要素のイベント処理
        for element in reversed(self.ui_elements):  # 前面の要素から処理
            if element.visible and element.active and element.handle_event(event):
                return True
        
        # UIで処理されなかった場合、マップ上のクリックとして処理
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            mouse_x, mouse_y = event.pos
            grid_x, grid_y = mouse_x // GRID_SIZE, mouse_y // GRID_SIZE
            
            # 戦闘アニメーション中は処理しない
            if not self.game_manager.combat_animation_active:
                self.map_controller.handle_click(grid_x, grid_y)
                return True
        
        return False
    
    def show_action_menu(self, x, y):
        """行動メニューを表示"""
        # 画面外にならないように調整
        menu_x = min(x, SCREEN_WIDTH - self.action_menu.width)
        menu_y = min(y, SCREEN_HEIGHT - self.action_menu.height)
        
        self.action_menu.set_position(menu_x, menu_y)
        self.action_menu.visible = True
    
    def show_battle_forecast(self, attacker, defender):
        """戦闘予測を表示"""
        self.battle_forecast.update_forecast(attacker, defender)
        self.battle_forecast.visible = True
    
    def show_unit_info(self, unit):
        """ユニット情報ウィンドウを表示"""
        self.unit_info.update_unit(unit)
        self.unit_info.visible = True
    
    def toggle_unit_list(self):
        """ユニット一覧の表示/非表示を切り替え"""
        if self.unit_list.visible:
            self.unit_list.visible = False
        else:
            self.unit_list.update_units(self.game_manager.game_map.units)
            self.unit_list.visible = True
    
    def on_unit_list_selection(self, unit):
        """ユニット一覧からユニットが選択されたときの処理"""
        # マップ上の該当ユニットにカメラを移動する処理などを実装可能
        self.show_unit_info(unit)
    
    def end_turn(self):
        """ターン終了ボタンの処理"""
        if self.game_manager.turn_player == 0:  # プレイヤーのターンの場合のみ
            self.game_manager.end_player_turn()
            # 敵のターン実行
            self.game_manager.execute_ai_turn()
    
    def add_battle_log(self, text):
        """バトルログにテキストを追加"""
        # ログが表示されていない場合は表示
        if not self.battle_log.visible:
            self.battle_log.visible = True
        
        # 新しいログを追加
        y_pos = 0
        if self.battle_log.children:
            last_child = self.battle_log.children[-1]
            y_pos = last_child.y + last_child.height + 5
        
        log_label = Label(10, y_pos, text, self.small_font, 18, COLOR_WHITE)
        self.battle_log.add_child(log_label)
        
        # 古いログを削除（10件以上の場合）
        while len(self.battle_log.children) > 10:
            self.battle_log.remove_child(self.battle_log.children[0])
        
        # コンテンツ高さの更新
        self.battle_log.update_content_height()

================
File: unit.py
================
# unit.py
from typing import List, Dict, Optional
from constants import WeaponType
from weapon import Weapon
from skills import SkillTriggerType
from movement_system import MovementType  # 新たにインポート

class Unit:
    def __init__(self, name, unit_class, level, hp, strength, magic, skill, 
                 speed, luck, defense, resistance, movement, team, weapons=None, movement_type=MovementType.INFANTRY):  # 移動タイプを引数に追加):
        self.name = name
        self.unit_class = unit_class
        self.level = level
        self.max_hp = hp
        self.current_hp = hp
        self.strength = strength
        self.magic = magic
        self.skill = skill
        self.speed = speed
        self.luck = luck
        self.defense = defense
        self.resistance = resistance
        self.movement = movement
        self.team = team  # 0: プレイヤー, 1: 敵
        self.weapons = weapons or []
        self.equipped_weapon = weapons[0] if weapons else None
        self.x = 0
        self.y = 0
        self.has_moved = False
        self.has_attacked = False
        self.is_hero = False
        
        # 移動タイプを設定 - 新規追加
        self.movement_type = movement_type
        self._determine_movement_type_from_class()  # クラスに基づいて自動設定

        # スキル関連のフィールド
        self.skills = []
        self.temp_stat_modifiers = {}
        self.active_skills = []

        # 救出関連の属性を追加
        self.build = self._calculate_build()  # 体格（救出の判定に使用）
        self.is_mounted = "騎馬" in unit_class or "ペガサス" in unit_class or "ワイバーン" in unit_class
        self.is_flying = "ペガサス" in unit_class or "ワイバーン" in unit_class
        
        # 重要キャラフラグ（解雇不可キャラ用）- 新規追加
        self.is_important = False

        # 救出状態の管理
        self.rescuing = None  # 救出しているユニット
        self.rescued_by = None  # 救出されているユニット
        
        # アイテムボックス機能
        self.has_item_box_access = False  # アイテムボックスへのアクセス権

        # 特定の名前や条件の場合に主人公としてマーク
        if name == "Marth" or name == "主人公の名前":  # ゲームの主人公名に合わせて調整
            self.is_hero = True

        # AIの役割（敵ユニット用）
        self.ai_role = None  # "attacker", "defender", "healer", "support", "assassin", "tank"

    def _determine_movement_type_from_class(self):
        """ユニットクラスに基づいて移動タイプを自動設定"""
        # 職業名から移動タイプを推測
        class_name = self.unit_class.lower() if self.unit_class else ""
        
        # 自動判定ロジック
        if "ペガサス" in class_name or "pegasus" in class_name or "飛行" in class_name or "falcon" in class_name:
            self.movement_type = MovementType.FLYING
        elif "アーマー" in class_name or "armor" in class_name or "重騎士" in class_name or "general" in class_name:
            self.movement_type = MovementType.ARMORED
        elif "騎馬" in class_name or "paladin" in class_name or "cavalier" in class_name or "ソシアル" in class_name:
            self.movement_type = MovementType.CAVALRY
        elif "忍者" in class_name or "ninja" in class_name or "シーフ" in class_name or "thief" in class_name:
            self.movement_type = MovementType.NINJA
        elif "魔道" in class_name or "mage" in class_name or "sage" in class_name or "魔法" in class_name:
            self.movement_type = MovementType.MAGE
        elif "山賊" in class_name or "斧" in class_name or "berserker" in class_name:
            self.movement_type = MovementType.MOUNTAIN
        elif "海賊" in class_name or "sailor" in class_name or "海" in class_name:
            self.movement_type = MovementType.AQUATIC
        elif "森" in class_name or "猟兵" in class_name or "ranger" in class_name:
            self.movement_type = MovementType.FOREST
        elif "砂漠" in class_name or "desert" in class_name:
            self.movement_type = MovementType.DESERT
        elif "幽霊" in class_name or "ghost" in class_name or "亡霊" in class_name:
            self.movement_type = MovementType.GHOST
        else:
            # デフォルトは歩兵
            self.movement_type = MovementType.INFANTRY

    def get_attack_power(self) -> int:
        if not self.equipped_weapon:
            return 0
        if self.equipped_weapon.weapon_type == WeaponType.MAGIC:
            return self.magic + self.equipped_weapon.might
        return self.strength + self.equipped_weapon.might

    def get_hit_rate(self) -> int:
        if not self.equipped_weapon:
            return 0
        return self.equipped_weapon.hit + (self.skill * 2) + (self.luck // 2)

    def get_avoid(self) -> int:
        return (self.speed * 2) + self.luck

    def get_critical_rate(self) -> int:
        if not self.equipped_weapon:
            return 0
        return self.equipped_weapon.crit + (self.skill // 2)

    def get_attack_speed(self) -> int:
        if not self.equipped_weapon:
            return self.speed
        return max(0, self.speed - max(0, self.equipped_weapon.weight - (self.strength // 5)))
    
    def can_double_attack(self, target) -> bool:
        return self.get_attack_speed() >= target.get_attack_speed() + 4

    def is_dead(self) -> bool:
        return self.current_hp <= 0

    def end_turn(self):
        self.has_moved = False
        self.has_attacked = False
        
    # スキル関連のメソッド
    def add_skill(self, skill):
        """ユニットにスキルを追加する"""
        self.skills.append(skill)
        
    def remove_skill(self, skill_name):
        """ユニットからスキルを削除する"""
        self.skills = [s for s in self.skills if s.name != skill_name]
        self.active_skills = [s for s in self.active_skills if s.name != skill_name]
        
    def activate_skills(self, trigger_type, combat_data=None):
        """特定のトリガーに基づいてスキルをアクティブにする"""
        activated_skills = []
        for skill in self.skills:
            if skill.trigger_type == trigger_type:
                if skill.check_trigger(self, combat_data):
                    skill.is_active = True
                    self.active_skills.append(skill)
                    effect_result = skill.apply_effect(self, combat_data.get("target") if combat_data else None, combat_data)
                    activated_skills.append((skill, effect_result))
        return activated_skills
        
    def deactivate_skills(self):
        """アクティブなスキルを非アクティブにする"""
        for skill in self.active_skills:
            skill.is_active = False
        self.active_skills = []
        self.temp_stat_modifiers = {}
    
    def _calculate_build(self):
        """ユニットの体格を計算（救出判定用）"""
        # 体格の基本値（職業によって異なる）
        base_build = {
            "ロード": 5,
            "ソードマスター": 7,
            "ヒーロー": 8,
            "戦士": 9,
            "傭兵": 6,
            "アーマー": 13,
            "ナイト": 11,
            "ペガサスナイト": 5,
            "ワイバーンナイト": 9,
            "ソシアルナイト": 8,
            "魔道士": 5,
            "僧侶": 5,
            "シーフ": 6
        }
        
        # 基本値 + (力 / 5) を体格とする
        class_build = base_build.get(self.unit_class, 7)  # デフォルト値は7
        return class_build + (self.strength // 5)
    
    def can_rescue(self, target):
        """対象ユニットを救出できるかどうか判定"""
        # 自分が救出中または救出されている場合は不可
        if self.rescuing or self.rescued_by:
            return False
        
        # 対象が救出中または救出されている場合は不可
        if target.rescuing or target.rescued_by:
            return False
        
        # 敵ユニットは通常の救出不可（捕獲・投降用メソッドを別に用意）
        if self.team != target.team:
            return False
        
        # 騎馬・飛行ユニットは救出できない（捕獲例外あり）
        if self.is_mounted:
            return False
        
        # 体格チェック：救出側 > 被救出側
        # return self.build >= target.build
        
        # 全ての条件を満たした場合
        return True
    
    def rescue(self, target):
        """ユニットを救出する"""
        if not self.can_rescue(target):
            return False
        
        # 救出状態を設定
        self.rescuing = target
        target.rescued_by = self
        
        # ステータス修正（技・速さ半減）
        self.apply_rescue_penalty()
        
        return True
    
    def can_drop(self, x, y, game_map):
        """救出したユニットを指定マスに下ろせるか判定"""
        if not self.rescuing:
            return False
        
        # 指定マスが地形的に進入可能かチェック
        tile = game_map.tiles[y][x]
        if not self.rescuing.can_enter_terrain(tile.terrain_type):
            return False
        
        # 指定マスに他のユニットがいないかチェック
        if game_map.get_unit_at(x, y):
            return False
        
        # 指定マスが隣接しているかチェック
        if abs(self.x - x) + abs(self.y - y) != 1:
            return False
        
        return True
    
    def drop(self, x, y, game_map):
        """救出したユニットを指定マスに下ろす"""
        if not self.can_drop(x, y, game_map):
            return False
        
        dropped_unit = self.rescuing
        
        # 救出状態を解除
        self.rescuing = None
        dropped_unit.rescued_by = None
        
        # ステータス修正を元に戻す
        self.remove_rescue_penalty()
        
        # ユニットをマップに配置
        game_map.place_unit(dropped_unit, x, y)
        dropped_unit.has_moved = True  # そのターン行動済みにする
        
        return True
    
    def apply_rescue_penalty(self):
        """救出によるステータス修正を適用"""
        # 技・速さの半減
        self.skill = self.skill // 2
        self.speed = self.speed // 2
        
        # 歩兵は移動力も半減
        if not self.is_mounted:
            self.movement = max(1, self.movement // 2)
    
    def remove_rescue_penalty(self):
        """救出によるステータス修正を元に戻す"""
        # 元のステータスに戻す（元の値を保存しておく必要あり）
        # 実際の実装では、元の値を保存しておく仕組みが必要
        pass
    
    def can_capture(self, target):
        """対象ユニットを捕獲できるかどうか判定"""
        # 自分が救出中の場合は不可
        if self.rescuing:
            return False
        
        # 対象が敵ユニットでない場合は不可
        if self.team == target.team:
            return False
        
        # 対象が救出されている場合は不可
        if target.rescued_by:
            return False
        
        # 体格チェックは不要（捕獲は特殊な救出）
        
        return True
    
    def can_capture_without_battle(self, target):
        """対象ユニットを戦闘なしで捕獲（投降）できるかどうか判定"""
        # 通常の捕獲条件を満たしているか
        if not self.can_capture(target):
            return False
        
        # 対象のHPが1桁かチェック
        return target.current_hp < 10
    
    def get_capture_battle_stats(self):
        """捕獲時の戦闘ステータスを取得（技・速さ半減）"""
        # 技・速さが半減した一時的なステータスを返す
        stats = {
            "skill": self.skill // 2,
            "speed": self.speed // 2
        }
        return stats

================
File: weapon_shop.py
================
# weapon_shop.py
import pygame
from ui_system import Panel, Label, Button, ScrollPanel

class WeaponShop(Panel):
    def __init__(self, x, y, width, height, game_manager, on_close=None):
        super().__init__(x, y, width, height)
        self.game_manager = game_manager
        self.on_close = on_close
        self.inventory = []  # 販売アイテムリスト
        self.selected_weapon = None
        self.selected_unit = None
        
        # ショップタイトル
        title_label = Label(width // 2, 20, "武器屋", None, 30, (255, 255, 200), None, "center")
        self.add_child(title_label)
        
        # 所持金表示
        gold_label = Label(width - 20, 20, f"所持金: {game_manager.player_gold}G", None, 24, (255, 255, 0), None, "right")
        self.add_child(gold_label)
        self.gold_label = gold_label
        
        # 武器リスト（左側）
        weapons_panel = ScrollPanel(20, 70, width // 2 - 30, height - 150, height, (40, 40, 50), (0, 0, 0), 1, 220)
        self.add_child(weapons_panel)
        self.weapons_panel = weapons_panel
        
        # ユニットリスト（右上）
        units_panel = ScrollPanel(width // 2 + 10, 70, width // 2 - 30, height // 2 - 40, height, (40, 40, 50), (0, 0, 0), 1, 220)
        self.add_child(units_panel)
        self.units_panel = units_panel
        
        # 装備詳細（右下）
        details_panel = Panel(width // 2 + 10, height // 2 + 40, width // 2 - 30, height // 2 - 110, (40, 40, 50), (0, 0, 0), 1, 220)
        self.add_child(details_panel)
        self.details_panel = details_panel
        
        # ボタン類
        buy_btn = Button(width // 4 - 50, height - 60, 100, 40, "購入", None, 24,
                        (60, 100, 60), (255, 255, 255), (80, 150, 80),
                        (0, 0, 0), 1, self.buy_weapon)
        self.add_child(buy_btn)
        self.buy_btn = buy_btn
        
        equip_btn = Button(width // 4 * 3 - 50, height - 60, 100, 40, "装備", None, 24,
                          (60, 60, 100), (255, 255, 255), (80, 80, 150),
                          (0, 0, 0), 1, self.equip_weapon)
        self.add_child(equip_btn)
        self.equip_btn = equip_btn
        
        close_btn = Button(width - 80, 20, 60, 30, "閉じる", None, 20,
                          (100, 60, 60), (255, 255, 255), (150, 80, 80),
                          (0, 0, 0), 1, self.close_shop)
        self.add_child(close_btn)
        
        # 武器とユニットのリストを更新
        self.update_weapon_list()
        self.update_unit_list()
        
        # ボタンの初期状態
        self.buy_btn.set_active(False)
        self.equip_btn.set_active(False)
    
    def update_weapon_list(self):
        """販売武器リストを更新"""
        self.weapons_panel.clear_children()
        
        # 販売武器のデータ取得（実際はゲームマネージャーから取得）
        self.inventory = self.game_manager.get_shop_weapons()
        
        for i, weapon in enumerate(self.inventory):
            weapon_panel = Panel(10, i * 70 + 10, self.weapons_panel.width - 30, 60, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # 武器名
            weapon_panel.add_child(Label(10, 10, weapon.name, None, 20, (255, 255, 255)))
            
            # 武器性能
            stats_text = f"威力:{weapon.might} 命中:{weapon.hit} 重さ:{weapon.weight}"
            weapon_panel.add_child(Label(10, 35, stats_text, None, 16, (200, 200, 200)))
            
            # 価格
            price_text = f"{weapon.price}G"
            weapon_panel.add_child(Label(weapon_panel.width - 70, 10, price_text, None, 18, (255, 255, 0), None, "right"))
            
            # クリックハンドラを設定
            weapon_index = i
            
            def make_handler(idx):
                return lambda: self.select_weapon(self.inventory[idx])
            
            weapon_panel.handle_event = make_handler(weapon_index)
            
            self.weapons_panel.add_child(weapon_panel)
        
        # コンテンツ高さを更新
        self.weapons_panel.update_content_height()
    
    def update_unit_list(self):
        """ユニットリストを更新"""
        self.units_panel.clear_children()
        
        # プレイヤーユニットの取得
        units = [unit for unit in self.game_manager.game_map.units if unit.team == 0]
        
        for i, unit in enumerate(units):
            unit_panel = Panel(10, i * 60 + 10, self.units_panel.width - 30, 50, (50, 50, 60), (0, 0, 0), 1, 255)
            
            # ユニット名と職業
            unit_panel.add_child(Label(10, 10, f"{unit.name} (Lv.{unit.level} {unit.unit_class})", None, 18, (255, 255, 255)))
            
            # 装備中の武器
            equipped_text = f"装備: {unit.equipped_weapon.name if unit.equipped_weapon else '無し'}"
            unit_panel.add_child(Label(10, 30, equipped_text, None, 16, (200, 200, 200)))
            
            # クリックハンドラを設定
            unit_index = i
            
            def make_handler(idx):
                return lambda: self.select_unit(units[idx])
            
            unit_panel.handle_event = make_handler(unit_index)
            
            self.units_panel.add_child(unit_panel)
        
        # コンテンツ高さを更新
        self.units_panel.update_content_height()
    
    def select_weapon(self, weapon):
        """武器を選択"""
        self.selected_weapon = weapon
        self.update_details()
        
        # 購入ボタンの有効化
        self.buy_btn.set_active(True)
        
        # 装備ボタンの有効化（ユニットと武器の両方が選択されている場合）
        self.equip_btn.set_active(self.selected_unit is not None)
    
    def select_unit(self, unit):
        """ユニットを選択"""
        self.selected_unit = unit
        self.update_details()
        
        # 装備ボタンの有効化（ユニットと武器の両方が選択されている場合）
        self.equip_btn.set_active(self.selected_weapon is not None)
    
    # weapon_shop.py の続き
    def update_details(self):
        """詳細パネルを更新"""
        self.details_panel.clear_children()
        
        if not self.selected_weapon:
            return
        
        # 武器詳細
        self.details_panel.add_child(Label(10, 10, f"名前: {self.selected_weapon.name}", None, 18, (255, 255, 255)))
        self.details_panel.add_child(Label(10, 30, f"種類: {self.selected_weapon.weapon_type.name}", None, 16, (200, 200, 200)))
        self.details_panel.add_child(Label(10, 50, f"威力: {self.selected_weapon.might}", None, 16, (200, 200, 200)))
        self.details_panel.add_child(Label(10, 70, f"命中: {self.selected_weapon.hit}", None, 16, (200, 200, 200)))
        self.details_panel.add_child(Label(10, 90, f"必殺: {self.selected_weapon.crit}", None, 16, (200, 200, 200)))
        self.details_panel.add_child(Label(10, 110, f"重さ: {self.selected_weapon.weight}", None, 16, (200, 200, 200)))
        self.details_panel.add_child(Label(10, 130, f"射程: {self.selected_weapon.range_min}-{self.selected_weapon.range_max}", None, 16, (200, 200, 200)))
        self.details_panel.add_child(Label(10, 150, f"価格: {self.selected_weapon.price}G", None, 16, (255, 255, 0)))
        
        # 選択中のユニットとの相性を表示
        if self.selected_unit:
            # 背景枠
            compatibility_panel = Panel(self.details_panel.width // 2, 10, self.details_panel.width // 2 - 20, 160, (60, 60, 70), (0, 0, 0), 1, 200)
            self.details_panel.add_child(compatibility_panel)
            
            # ユニット名
            compatibility_panel.add_child(Label(10, 10, self.selected_unit.name, None, 18, (255, 255, 255)))
            
            # 武器との相性チェック
            can_equip = True  # デフォルトでは装備可能
            
            # レジェンダリー武器の場合は特別なチェック
            if hasattr(self.selected_weapon, 'can_equip'):
                can_equip = self.selected_weapon.can_equip(self.selected_unit)
            
            # 装備可能かどうかを表示
            equip_text = "装備可能" if can_equip else "装備不可"
            equip_color = (100, 255, 100) if can_equip else (255, 100, 100)
            compatibility_panel.add_child(Label(10, 30, equip_text, None, 16, equip_color))
            
            # 現在の装備と比較
            if self.selected_unit.equipped_weapon:
                current = self.selected_unit.equipped_weapon
                compatibility_panel.add_child(Label(10, 50, "現在装備中:", None, 16, (200, 200, 200)))
                compatibility_panel.add_child(Label(10, 70, current.name, None, 16, (180, 180, 230)))
                
                # 簡易ステータス比較
                might_diff = self.selected_weapon.might - current.might
                hit_diff = self.selected_weapon.hit - current.hit
                crit_diff = self.selected_weapon.crit - current.crit
                
                might_color = (100, 255, 100) if might_diff > 0 else (255, 100, 100) if might_diff < 0 else (200, 200, 200)
                hit_color = (100, 255, 100) if hit_diff > 0 else (255, 100, 100) if hit_diff < 0 else (200, 200, 200)
                crit_color = (100, 255, 100) if crit_diff > 0 else (255, 100, 100) if crit_diff < 0 else (200, 200, 200)
                
                compatibility_panel.add_child(Label(10, 90, f"威力: {might_diff:+d}", None, 16, might_color))
                compatibility_panel.add_child(Label(10, 110, f"命中: {hit_diff:+d}", None, 16, hit_color))
                compatibility_panel.add_child(Label(10, 130, f"必殺: {crit_diff:+d}", None, 16, crit_color))
    
    def buy_weapon(self):
        """武器を購入"""
        if not self.selected_weapon:
            return
        
        # 所持金チェック
        if self.game_manager.player_gold < self.selected_weapon.price:
            # お金が足りないメッセージ
            return
        
        # 購入処理
        self.game_manager.player_gold -= self.selected_weapon.price
        self.game_manager.add_item_to_inventory(self.selected_weapon)
        
        # 所持金表示の更新
        self.gold_label.set_text(f"所持金: {self.game_manager.player_gold}G")
        
        # 即座に装備するかどうかの確認（未実装）
    
    def equip_weapon(self):
        """武器を装備"""
        if not self.selected_weapon or not self.selected_unit:
            return
        
        # インベントリに武器があるか確認
        if self.selected_weapon not in self.game_manager.inventory:
            # 購入が必要なメッセージ
            return
        
        # 装備処理
        self.game_manager.equip_weapon(self.selected_unit, self.selected_weapon)
        
        # ユニットリストを更新
        self.update_unit_list()
    
    def close_shop(self):
        """ショップを閉じる"""
        if self.on_close:
            self.on_close()

================
File: weapon.py
================
# weapon.py
from constants import WeaponType

class Weapon:
    def __init__(self, name, weapon_type, might, hit, crit, weight, range_min, range_max, durability):
        self.name = name
        self.weapon_type = weapon_type
        self.might = might
        self.hit = hit
        self.crit = crit
        self.weight = weight
        self.range_min = range_min
        self.range_max = range_max
        self.durability = durability
        self.max_durability = durability
